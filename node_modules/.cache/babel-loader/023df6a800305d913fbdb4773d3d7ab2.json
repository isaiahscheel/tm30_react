{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar transformInsideText = require('../pie/plot').transformInsideText;\n\nvar styleOne = require('./style').styleOne;\n\nvar attachFxHandlers = require('./fx');\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers');\n\nexports.plot = function (gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var layer = fullLayout._sunburstlayer;\n  var join, onComplete; // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n\n  var isFullReplot = !transitionOpts;\n  var hasTransition = helpers.hasTransition(transitionOpts);\n  join = layer.selectAll('g.trace.sunburst').data(cdmodule, function (cd) {\n    return cd[0].trace.uid;\n  }); // using same 'stroke-linejoin' as pie traces\n\n  join.enter().append('g').classed('trace', true).classed('sunburst', true).attr('stroke-linejoin', 'round');\n  join.order();\n\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      layer.selectAll('g.trace').each(function (cd) {\n        plotOne(gd, cd, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (cd) {\n      plotOne(gd, cd, this, transitionOpts);\n    });\n  }\n\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n};\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n  var fullLayout = gd._fullLayout;\n  var hasTransition = helpers.hasTransition(transitionOpts);\n  var gTrace = d3.select(element);\n  var slices = gTrace.selectAll('g.slice');\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var maxDepth = helpers.getMaxDepth(trace);\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var rMax = 0.5 * Math.min(vpw, vph);\n  var cx = cd0.cx = gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cy = cd0.cy = gs.t + gs.h * (1 - domain.y[0]) - vph / 2;\n\n  if (!entry) {\n    return slices.remove();\n  } // previous root 'pt' (can be empty)\n\n\n  var prevEntry = null; // stash of 'previous' position data used by tweening functions\n\n  var prevLookup = {};\n\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    slices.each(function (pt) {\n      prevLookup[helpers.getPtId(pt)] = {\n        rpx0: pt.rpx0,\n        rpx1: pt.rpx1,\n        x0: pt.x0,\n        x1: pt.x1,\n        transform: pt.transform\n      };\n\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  } // N.B. slice data isn't the calcdata,\n  // grab corresponding calcdata item in sliceData[i].data.data\n\n\n  var sliceData = partition(entry).descendants();\n  var maxHeight = entry.height + 1;\n  var yOffset = 0;\n  var cutoff = maxDepth; // N.B. handle multiple-root special case\n\n  if (cd0.hasMultipleRoots && helpers.isHierarchyRoot(entry)) {\n    sliceData = sliceData.slice(1);\n    maxHeight -= 1;\n    yOffset = 1;\n    cutoff += 1;\n  } // filter out slices that won't show up on graph\n\n\n  sliceData = sliceData.filter(function (pt) {\n    return pt.y1 <= cutoff;\n  }); // partition span ('y') to sector radial px value\n\n  var maxY = Math.min(maxHeight, maxDepth);\n\n  var y2rpx = function (y) {\n    return (y - yOffset) / maxY * rMax;\n  }; // (radial px value, partition angle ('x'))  to px [x,y]\n\n\n  var rx2px = function (r, x) {\n    return [r * Math.cos(x), -r * Math.sin(x)];\n  }; // slice path generation fn\n\n\n  var pathSlice = function (d) {\n    return Lib.pathAnnulus(d.rpx0, d.rpx1, d.x0, d.x1, cx, cy);\n  }; // slice text translate x/y\n\n\n  var transTextX = function (d) {\n    return cx + d.pxmid[0] * d.transform.rCenter + (d.transform.x || 0);\n  };\n\n  var transTextY = function (d) {\n    return cy + d.pxmid[1] * d.transform.rCenter + (d.transform.y || 0);\n  };\n\n  slices = slices.data(sliceData, helpers.getPtId);\n  slices.enter().append('g').classed('slice', true);\n\n  if (hasTransition) {\n    slices.exit().transition().each(function () {\n      var sliceTop = d3.select(this);\n      var slicePath = sliceTop.select('path.surface');\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeExitSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n      var sliceTextGroup = sliceTop.select('g.slicetext');\n      sliceTextGroup.attr('opacity', 0);\n    }).remove();\n  } else {\n    slices.exit().remove();\n  }\n\n  slices.order(); // next x1 (i.e. sector end angle) of previous entry\n\n  var nextX1ofPrevEntry = null;\n\n  if (hasTransition && prevEntry) {\n    var prevEntryId = helpers.getPtId(prevEntry);\n    slices.each(function (pt) {\n      if (nextX1ofPrevEntry === null && helpers.getPtId(pt) === prevEntryId) {\n        nextX1ofPrevEntry = pt.x1;\n      }\n    });\n  }\n\n  var updateSlices = slices;\n\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: true,\n        hideOnLeaves: true,\n        isTransitioning: false\n      });\n    });\n  }\n\n  updateSlices.each(function (pt) {\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', 'all');\n    });\n    pt.rpx0 = y2rpx(pt.y0);\n    pt.rpx1 = y2rpx(pt.y1);\n    pt.xmid = (pt.x0 + pt.x1) / 2;\n    pt.pxmid = rx2px(pt.rpx1, pt.xmid);\n    pt.midangle = -(pt.xmid - Math.PI / 2);\n    pt.halfangle = 0.5 * Math.min(Lib.angleDelta(pt.x0, pt.x1) || Math.PI, Math.PI);\n    pt.ring = 1 - pt.rpx0 / pt.rpx1;\n    pt.rInscribed = getInscribedRadiusFraction(pt, trace);\n\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      hideOnRoot: true,\n      hideOnLeaves: true,\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace);\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    sliceText.text(exports.formatSliceLabel(pt, entry, trace, cd, fullLayout)).classed('slicetext', true).attr('text-anchor', 'middle').call(Drawing.font, helpers.determineTextFont(trace, pt, fullLayout.font)).call(svgTextUtils.convertToTspans, gd); // position the text relative to the slice\n\n    var textBB = Drawing.bBox(sliceText.node());\n    pt.transform = transformInsideText(textBB, pt, cd0);\n    pt.translateX = transTextX(pt);\n    pt.translateY = transTextY(pt);\n\n    var strTransform = function (d, textBB) {\n      return 'translate(' + d.translateX + ',' + d.translateY + ')' + (d.transform.scale < 1 ? 'scale(' + d.transform.scale + ')' : '') + (d.transform.rotate ? 'rotate(' + d.transform.rotate + ')' : '') + 'translate(' + -(textBB.left + textBB.right) / 2 + ',' + -(textBB.top + textBB.bottom) / 2 + ')';\n    };\n\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2);\n        return function (t) {\n          return strTransform(interp(t), textBB);\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt, textBB));\n    }\n  });\n\n  function makeExitSliceInterpolator(pt) {\n    var id = helpers.getPtId(pt);\n    var prev = prevLookup[id];\n    var entryPrev = prevLookup[helpers.getPtId(entry)];\n    var next;\n\n    if (entryPrev) {\n      var a = pt.x1 > entryPrev.x1 ? 2 * Math.PI : 0; // if pt to remove:\n      // - if 'below' where the root-node used to be: shrink it radially inward\n      // - otherwise, collapse it clockwise or counterclockwise which ever is shortest to theta=0\n\n      next = pt.rpx1 < entryPrev.rpx1 ? {\n        rpx0: 0,\n        rpx1: 0\n      } : {\n        x0: a,\n        x1: a\n      };\n    } else {\n      // this happens when maxdepth is set, when leaves must\n      // be removed and the rootPt is new (i.e. does not have a 'prev' object)\n      var parent;\n      var parentId = helpers.getPtId(pt.parent);\n      slices.each(function (pt2) {\n        if (helpers.getPtId(pt2) === parentId) {\n          return parent = pt2;\n        }\n      });\n      var parentChildren = parent.children;\n      var ci;\n      parentChildren.forEach(function (pt2, i) {\n        if (helpers.getPtId(pt2) === id) {\n          return ci = i;\n        }\n      });\n      var n = parentChildren.length;\n      var interp = d3.interpolate(parent.x0, parent.x1);\n      next = {\n        rpx0: rMax,\n        rpx1: rMax,\n        x0: interp(ci / n),\n        x1: interp((ci + 1) / n)\n      };\n    }\n\n    return d3.interpolate(prev, next);\n  }\n\n  function makeUpdateSliceInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var next = {\n      x0: pt.x0,\n      x1: pt.x1,\n      rpx0: pt.rpx0,\n      rpx1: pt.rpx1\n    };\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n            prev = {\n              x0: a,\n              x1: a\n            };\n          } else {\n            // if new leaf (when maxdepth is set),\n            // grow it radially and angularly from\n            // its parent node\n            prev = {\n              rpx0: rMax,\n              rpx1: rMax\n            };\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node, grow it radially\n          prev = {\n            rpx0: 0,\n            rpx1: 0\n          };\n        }\n      } else {\n        // start sector of new traces from theta=0\n        prev = {\n          x0: 0,\n          x1: 0\n        };\n      }\n    }\n\n    return d3.interpolate(prev, next);\n  }\n\n  function makeUpdateTextInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var transform = pt.transform;\n\n    if (prev0) {\n      prev = prev0;\n    } else {\n      prev = {\n        rpx1: pt.rpx1,\n        transform: {\n          scale: 0,\n          rotate: transform.rotate,\n          rCenter: transform.rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      }; // for new pts:\n\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n            prev.x0 = prev.x1 = a;\n          } else {\n            // if leaf\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node\n          prev.x0 = prev.x1 = 0;\n        }\n      } else {\n        // on new traces\n        prev.x0 = prev.x1 = 0;\n      }\n    }\n\n    var rpx1Fn = d3.interpolate(prev.rpx1, pt.rpx1);\n    var x0Fn = d3.interpolate(prev.x0, pt.x0);\n    var x1Fn = d3.interpolate(prev.x1, pt.x1);\n    var scaleFn = d3.interpolate(prev.transform.scale, transform.scale);\n    var rotateFn = d3.interpolate(prev.transform.rotate, transform.rotate); // smooth out start/end from entry, to try to keep text inside sector\n    // while keeping transition smooth\n\n    var pow = transform.rCenter === 0 ? 3 : prev.transform.rCenter === 0 ? 1 / 3 : 1;\n\n    var _rCenterFn = d3.interpolate(prev.transform.rCenter, transform.rCenter);\n\n    var rCenterFn = function (t) {\n      return _rCenterFn(Math.pow(t, pow));\n    };\n\n    return function (t) {\n      var rpx1 = rpx1Fn(t);\n      var x0 = x0Fn(t);\n      var x1 = x1Fn(t);\n      var rCenter = rCenterFn(t);\n      var d = {\n        pxmid: rx2px(rpx1, (x0 + x1) / 2),\n        transform: {\n          rCenter: rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      };\n      var out = {\n        rpx1: rpx1Fn(t),\n        translateX: transTextX(d),\n        translateY: transTextY(d),\n        transform: {\n          scale: scaleFn(t),\n          rotate: rotateFn(t),\n          rCenter: rCenter\n        }\n      };\n      return out;\n    };\n  }\n\n  function interpX0X1FromParent(pt) {\n    var parent = pt.parent;\n    var parentPrev = prevLookup[helpers.getPtId(parent)];\n    var out = {};\n\n    if (parentPrev) {\n      // if parent is visible\n      var parentChildren = parent.children;\n      var ci = parentChildren.indexOf(pt);\n      var n = parentChildren.length;\n      var interp = d3.interpolate(parentPrev.x0, parentPrev.x1);\n      out.x0 = interp(ci / n);\n      out.x1 = interp(ci / n);\n    } else {\n      // w/o visible parent\n      // TODO !!! HOW ???\n      out.x0 = out.x1 = 0;\n    }\n\n    return out;\n  }\n} // x[0-1] keys are angles [radians]\n// y[0-1] keys are hierarchy heights [integers]\n\n\nfunction partition(entry) {\n  return d3Hierarchy.partition().size([2 * Math.PI, entry.height + 1])(entry);\n}\n\nexports.formatSliceLabel = function (pt, entry, trace, cd, fullLayout) {\n  var texttemplate = trace.texttemplate;\n  var textinfo = trace.textinfo;\n\n  if (!texttemplate && (!textinfo || textinfo === 'none')) {\n    return '';\n  }\n\n  var separators = fullLayout.separators;\n  var cd0 = cd[0];\n  var cdi = pt.data.data;\n  var hierarchy = cd0.hierarchy;\n  var isRoot = helpers.isHierarchyRoot(pt);\n  var parent = helpers.getParent(hierarchy, pt);\n  var val = helpers.getValue(pt);\n\n  if (!texttemplate) {\n    var parts = textinfo.split('+');\n\n    var hasFlag = function (flag) {\n      return parts.indexOf(flag) !== -1;\n    };\n\n    var thisText = [];\n    var tx;\n\n    if (hasFlag('label') && cdi.label) {\n      thisText.push(cdi.label);\n    }\n\n    if (cdi.hasOwnProperty('v') && hasFlag('value')) {\n      thisText.push(helpers.formatValue(cdi.v, separators));\n    }\n\n    if (!isRoot) {\n      if (hasFlag('current path')) {\n        thisText.push(helpers.getPath(pt.data));\n      }\n\n      var nPercent = 0;\n      if (hasFlag('percent parent')) nPercent++;\n      if (hasFlag('percent entry')) nPercent++;\n      if (hasFlag('percent root')) nPercent++;\n      var hasMultiplePercents = nPercent > 1;\n\n      if (nPercent) {\n        var percent;\n\n        var addPercent = function (key) {\n          tx = helpers.formatPercent(percent, separators);\n          if (hasMultiplePercents) tx += ' of ' + key;\n          thisText.push(tx);\n        };\n\n        if (hasFlag('percent parent') && !isRoot) {\n          percent = val / helpers.getValue(parent);\n          addPercent('parent');\n        }\n\n        if (hasFlag('percent entry')) {\n          percent = val / helpers.getValue(entry);\n          addPercent('entry');\n        }\n\n        if (hasFlag('percent root')) {\n          percent = val / helpers.getValue(hierarchy);\n          addPercent('root');\n        }\n      }\n    }\n\n    if (hasFlag('text')) {\n      tx = Lib.castOption(trace, cdi.i, 'text');\n      if (Lib.isValidTextValue(tx)) thisText.push(tx);\n    }\n\n    return thisText.join('<br>');\n  }\n\n  var txt = Lib.castOption(trace, cdi.i, 'texttemplate');\n  if (!txt) return '';\n  var obj = {};\n  if (cdi.label) obj.label = cdi.label;\n\n  if (cdi.hasOwnProperty('v')) {\n    obj.value = cdi.v;\n    obj.valueLabel = helpers.formatValue(cdi.v, separators);\n  }\n\n  obj.currentPath = helpers.getPath(pt.data);\n\n  if (!isRoot) {\n    obj.percentParent = val / helpers.getValue(parent);\n    obj.percentParentLabel = helpers.formatPercent(obj.percentParent, separators);\n    obj.parent = helpers.getPtLabel(parent);\n  }\n\n  obj.percentEntry = val / helpers.getValue(entry);\n  obj.percentEntryLabel = helpers.formatPercent(obj.percentEntry, separators);\n  obj.entry = helpers.getPtLabel(entry);\n  obj.percentRoot = val / helpers.getValue(hierarchy);\n  obj.percentRootLabel = helpers.formatPercent(obj.percentRoot, separators);\n  obj.root = helpers.getPtLabel(hierarchy);\n\n  if (cdi.hasOwnProperty('color')) {\n    obj.color = cdi.color;\n  }\n\n  var ptTx = Lib.castOption(trace, cdi.i, 'text');\n  if (Lib.isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n  obj.customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  return Lib.texttemplateString(txt, obj, fullLayout._d3locale, obj, trace._meta || {});\n};\n\nfunction getInscribedRadiusFraction(pt) {\n  if (pt.rpx0 === 0 && Lib.isFullCircle([pt.x0, pt.x1])) {\n    // special case of 100% with no hole\n    return 1;\n  } else {\n    return Math.max(0, Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2));\n  }\n}","map":null,"metadata":{},"sourceType":"script"}