{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar createPointCloudRenderer = require('gl-pointcloud2d');\n\nvar str2RGBArray = require('../../lib/str2rgbarray');\n\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\n\nvar getTraceColor = require('../scatter/get_trace_color');\n\nfunction Pointcloud(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.type = 'pointcloud';\n  this.pickXData = [];\n  this.pickYData = [];\n  this.xData = [];\n  this.yData = [];\n  this.textLabels = [];\n  this.color = 'rgb(0, 0, 0)';\n  this.name = '';\n  this.hoverinfo = 'all';\n  this.idToIndex = new Int32Array(0);\n  this.bounds = [0, 0, 0, 0];\n  this.pointcloudOptions = {\n    positions: new Float32Array(0),\n    idToIndex: this.idToIndex,\n    sizemin: 0.5,\n    sizemax: 12,\n    color: [0, 0, 0, 1],\n    areaRatio: 1,\n    borderColor: [0, 0, 0, 1]\n  };\n  this.pointcloud = createPointCloudRenderer(scene.glplot, this.pointcloudOptions);\n  this.pointcloud._trace = this; // scene2d requires this prop\n}\n\nvar proto = Pointcloud.prototype;\n\nproto.handlePick = function (pickResult) {\n  var index = this.idToIndex[pickResult.pointId]; // prefer the readout from XY, if present\n\n  return {\n    trace: this,\n    dataCoord: pickResult.dataCoord,\n    traceCoord: this.pickXYData ? [this.pickXYData[index * 2], this.pickXYData[index * 2 + 1]] : [this.pickXData[index], this.pickYData[index]],\n    textLabel: Array.isArray(this.textLabels) ? this.textLabels[index] : this.textLabels,\n    color: this.color,\n    name: this.name,\n    pointIndex: index,\n    hoverinfo: this.hoverinfo\n  };\n};\n\nproto.update = function (options) {\n  this.index = options.index;\n  this.textLabels = options.text;\n  this.name = options.name;\n  this.hoverinfo = options.hoverinfo;\n  this.bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  this.updateFast(options);\n  this.color = getTraceColor(options, {});\n};\n\nproto.updateFast = function (options) {\n  var x = this.xData = this.pickXData = options.x;\n  var y = this.yData = this.pickYData = options.y;\n  var xy = this.pickXYData = options.xy;\n  var userBounds = options.xbounds && options.ybounds;\n  var index = options.indices;\n  var len;\n  var idToIndex;\n  var positions;\n  var bounds = this.bounds;\n  var xx, yy, i;\n\n  if (xy) {\n    positions = xy; // dividing xy.length by 2 and truncating to integer if xy.length was not even\n\n    len = xy.length >>> 1;\n\n    if (userBounds) {\n      bounds[0] = options.xbounds[0];\n      bounds[2] = options.xbounds[1];\n      bounds[1] = options.ybounds[0];\n      bounds[3] = options.ybounds[1];\n    } else {\n      for (i = 0; i < len; i++) {\n        xx = positions[i * 2];\n        yy = positions[i * 2 + 1];\n        if (xx < bounds[0]) bounds[0] = xx;\n        if (xx > bounds[2]) bounds[2] = xx;\n        if (yy < bounds[1]) bounds[1] = yy;\n        if (yy > bounds[3]) bounds[3] = yy;\n      }\n    }\n\n    if (index) {\n      idToIndex = index;\n    } else {\n      idToIndex = new Int32Array(len);\n\n      for (i = 0; i < len; i++) {\n        idToIndex[i] = i;\n      }\n    }\n  } else {\n    len = x.length;\n    positions = new Float32Array(2 * len);\n    idToIndex = new Int32Array(len);\n\n    for (i = 0; i < len; i++) {\n      xx = x[i];\n      yy = y[i];\n      idToIndex[i] = i;\n      positions[i * 2] = xx;\n      positions[i * 2 + 1] = yy;\n      if (xx < bounds[0]) bounds[0] = xx;\n      if (xx > bounds[2]) bounds[2] = xx;\n      if (yy < bounds[1]) bounds[1] = yy;\n      if (yy > bounds[3]) bounds[3] = yy;\n    }\n  }\n\n  this.idToIndex = idToIndex;\n  this.pointcloudOptions.idToIndex = idToIndex;\n  this.pointcloudOptions.positions = positions;\n  var markerColor = str2RGBArray(options.marker.color);\n  var borderColor = str2RGBArray(options.marker.border.color);\n  var opacity = options.opacity * options.marker.opacity;\n  markerColor[3] *= opacity;\n  this.pointcloudOptions.color = markerColor; // detect blending from the number of points, if undefined\n  // because large data with blending hits performance\n\n  var blend = options.marker.blend;\n\n  if (blend === null) {\n    var maxPoints = 100;\n    blend = x.length < maxPoints || y.length < maxPoints;\n  }\n\n  this.pointcloudOptions.blend = blend;\n  borderColor[3] *= opacity;\n  this.pointcloudOptions.borderColor = borderColor;\n  var markerSizeMin = options.marker.sizemin;\n  var markerSizeMax = Math.max(options.marker.sizemax, options.marker.sizemin);\n  this.pointcloudOptions.sizeMin = markerSizeMin;\n  this.pointcloudOptions.sizeMax = markerSizeMax;\n  this.pointcloudOptions.areaRatio = options.marker.border.arearatio;\n  this.pointcloud.update(this.pointcloudOptions); // add item for autorange routine\n\n  var xa = this.scene.xaxis;\n  var ya = this.scene.yaxis;\n  var pad = markerSizeMax / 2 || 0.5;\n  options._extremes[xa._id] = findExtremes(xa, [bounds[0], bounds[2]], {\n    ppad: pad\n  });\n  options._extremes[ya._id] = findExtremes(ya, [bounds[1], bounds[3]], {\n    ppad: pad\n  });\n};\n\nproto.dispose = function () {\n  this.pointcloud.dispose();\n};\n\nfunction createPointcloud(scene, data) {\n  var plot = new Pointcloud(scene, data.uid);\n  plot.update(data);\n  return plot;\n}\n\nmodule.exports = createPointcloud;","map":null,"metadata":{},"sourceType":"script"}