{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar createMatrix = require('regl-splom');\n\nvar Lib = require('../../lib');\n\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nmodule.exports = function plot(gd, _, splomCalcData) {\n  if (!splomCalcData.length) return;\n\n  for (var i = 0; i < splomCalcData.length; i++) {\n    plotOne(gd, splomCalcData[i][0]);\n  }\n};\n\nfunction plotOne(gd, cd0) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var trace = cd0.trace;\n  var stash = cd0.t;\n  var scene = fullLayout._splomScenes[trace.uid];\n  var matrixOpts = scene.matrixOptions;\n  var cdata = matrixOpts.cdata;\n\n  var regl = fullLayout._glcanvas.data()[0].regl;\n\n  var dragmode = fullLayout.dragmode;\n  var xa, ya;\n  var i, j, k;\n  if (cdata.length === 0) return; // augment options with proper upper/lower halves\n  // regl-splom's default grid starts from bottom-left\n\n  matrixOpts.lower = trace.showupperhalf;\n  matrixOpts.upper = trace.showlowerhalf;\n  matrixOpts.diagonal = trace.diagonal.visible;\n  var visibleDims = trace._visibleDims;\n  var visibleLength = cdata.length;\n  var viewOpts = scene.viewOpts = {};\n  viewOpts.ranges = new Array(visibleLength);\n  viewOpts.domains = new Array(visibleLength);\n\n  for (k = 0; k < visibleDims.length; k++) {\n    i = visibleDims[k];\n    var rng = viewOpts.ranges[k] = new Array(4);\n    var dmn = viewOpts.domains[k] = new Array(4);\n    xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n\n    if (xa) {\n      rng[0] = xa._rl[0];\n      rng[2] = xa._rl[1];\n      dmn[0] = xa.domain[0];\n      dmn[2] = xa.domain[1];\n    }\n\n    ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n\n    if (ya) {\n      rng[1] = ya._rl[0];\n      rng[3] = ya._rl[1];\n      dmn[1] = ya.domain[0];\n      dmn[3] = ya.domain[1];\n    }\n  }\n\n  viewOpts.viewport = [gs.l, gs.b, gs.w + gs.l, gs.h + gs.b];\n\n  if (scene.matrix === true) {\n    scene.matrix = createMatrix(regl);\n  }\n\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n  var selectMode = dragmode === 'lasso' || dragmode === 'select' || !!trace.selectedpoints || clickSelectEnabled;\n  var needsBaseUpdate = true;\n\n  if (selectMode) {\n    var commonLength = trace._length; // regenerate scene batch, if traces number changed during selection\n\n    if (trace.selectedpoints) {\n      scene.selectBatch = trace.selectedpoints;\n      var selPts = trace.selectedpoints;\n      var selDict = {};\n\n      for (i = 0; i < selPts.length; i++) {\n        selDict[selPts[i]] = true;\n      }\n\n      var unselPts = [];\n\n      for (i = 0; i < commonLength; i++) {\n        if (!selDict[i]) unselPts.push(i);\n      }\n\n      scene.unselectBatch = unselPts;\n    } // precalculate px coords since we are not going to pan during select\n\n\n    var xpx = stash.xpx = new Array(visibleLength);\n    var ypx = stash.ypx = new Array(visibleLength);\n\n    for (k = 0; k < visibleDims.length; k++) {\n      i = visibleDims[k];\n      xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n\n      if (xa) {\n        xpx[k] = new Array(commonLength);\n\n        for (j = 0; j < commonLength; j++) {\n          xpx[k][j] = xa.c2p(cdata[k][j]);\n        }\n      }\n\n      ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n\n      if (ya) {\n        ypx[k] = new Array(commonLength);\n\n        for (j = 0; j < commonLength; j++) {\n          ypx[k][j] = ya.c2p(cdata[k][j]);\n        }\n      }\n    }\n\n    if (scene.selectBatch.length || scene.unselectBatch.length) {\n      var unselOpts = Lib.extendFlat({}, matrixOpts, scene.unselectedOptions, viewOpts);\n      var selOpts = Lib.extendFlat({}, matrixOpts, scene.selectedOptions, viewOpts);\n      scene.matrix.update(unselOpts, selOpts);\n      needsBaseUpdate = false;\n    }\n  } else {\n    stash.xpx = stash.ypx = null;\n  }\n\n  if (needsBaseUpdate) {\n    var opts = Lib.extendFlat({}, matrixOpts, viewOpts);\n    scene.matrix.update(opts, null);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}