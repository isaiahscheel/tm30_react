{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar svgSdf = require('svg-path-sdf');\n\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\n\nvar subTypes = require('../scatter/subtypes');\n\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar constants = require('./constants');\n\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  left: 1,\n  end: -1,\n  right: -1,\n  middle: 0,\n  center: 0,\n  bottom: 1,\n  top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n  var i;\n  var opts = {\n    marker: undefined,\n    markerSel: undefined,\n    markerUnsel: undefined,\n    line: undefined,\n    fill: undefined,\n    errorX: undefined,\n    errorY: undefined,\n    text: undefined,\n    textSel: undefined,\n    textUnsel: undefined\n  };\n  if (trace.visible !== true) return opts;\n\n  if (subTypes.hasText(trace)) {\n    opts.text = convertTextStyle(trace, gd);\n    opts.textSel = convertTextSelection(trace, trace.selected);\n    opts.textUnsel = convertTextSelection(trace, trace.unselected);\n  }\n\n  if (subTypes.hasMarkers(trace)) {\n    opts.marker = convertMarkerStyle(trace);\n    opts.markerSel = convertMarkerSelection(trace, trace.selected);\n    opts.markerUnsel = convertMarkerSelection(trace, trace.unselected);\n\n    if (!trace.unselected && Array.isArray(trace.marker.opacity)) {\n      var mo = trace.marker.opacity;\n      opts.markerUnsel.opacity = new Array(mo.length);\n\n      for (i = 0; i < mo.length; i++) {\n        opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n      }\n    }\n  }\n\n  if (subTypes.hasLines(trace)) {\n    opts.line = {\n      overlay: true,\n      thickness: trace.line.width,\n      color: trace.line.color,\n      opacity: trace.opacity\n    };\n    var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n\n    for (i = 0; i < dashes.length; ++i) {\n      dashes[i] *= trace.line.width;\n    }\n\n    opts.line.dashes = dashes;\n  }\n\n  if (trace.error_x && trace.error_x.visible) {\n    opts.errorX = convertErrorBarStyle(trace, trace.error_x);\n  }\n\n  if (trace.error_y && trace.error_y.visible) {\n    opts.errorY = convertErrorBarStyle(trace, trace.error_y);\n  }\n\n  if (!!trace.fill && trace.fill !== 'none') {\n    opts.fill = {\n      closed: true,\n      fill: trace.fillcolor,\n      thickness: 0\n    };\n  }\n\n  return opts;\n}\n\nfunction convertTextStyle(trace, gd) {\n  var count = trace._length;\n  var textfontIn = trace.textfont;\n  var textpositionIn = trace.textposition;\n  var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n  var tfc = textfontIn.color;\n  var tfs = textfontIn.size;\n  var tff = textfontIn.family;\n  var optsOut = {};\n  var i;\n  var texttemplate = trace.texttemplate;\n\n  if (texttemplate) {\n    optsOut.text = [];\n    var isArray = Array.isArray(texttemplate);\n    var N = isArray ? Math.min(texttemplate.length, count) : count;\n    var txt = isArray ? function (i) {\n      return texttemplate[i];\n    } : function () {\n      return texttemplate;\n    };\n    var d3locale = gd._fullLayout._d3locale;\n\n    for (i = 0; i < N; i++) {\n      var pt = {};\n      appendArrayPointValue(pt, trace, i);\n      optsOut.text.push(Lib.texttemplateString(txt(i), pt, d3locale, pt, trace._meta || {}));\n    }\n  } else {\n    if (Array.isArray(trace.text) && trace.text.length < count) {\n      // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n      optsOut.text = trace.text.slice();\n    } else {\n      optsOut.text = trace.text;\n    }\n  } // pad text array with empty strings\n\n\n  if (Array.isArray(optsOut.text)) {\n    for (i = optsOut.text.length; i < count; i++) {\n      optsOut.text[i] = '';\n    }\n  }\n\n  optsOut.opacity = trace.opacity;\n  optsOut.font = {};\n  optsOut.align = [];\n  optsOut.baseline = [];\n\n  for (i = 0; i < textPos.length; i++) {\n    var tp = textPos[i].split(/\\s+/);\n\n    switch (tp[1]) {\n      case 'left':\n        optsOut.align.push('right');\n        break;\n\n      case 'right':\n        optsOut.align.push('left');\n        break;\n\n      default:\n        optsOut.align.push(tp[1]);\n    }\n\n    switch (tp[0]) {\n      case 'top':\n        optsOut.baseline.push('bottom');\n        break;\n\n      case 'bottom':\n        optsOut.baseline.push('top');\n        break;\n\n      default:\n        optsOut.baseline.push(tp[0]);\n    }\n  }\n\n  if (Array.isArray(tfc)) {\n    optsOut.color = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      optsOut.color[i] = tfc[i];\n    }\n  } else {\n    optsOut.color = tfc;\n  }\n\n  if (Array.isArray(tfs) || Array.isArray(tff)) {\n    // if any textfont param is array - make render a batch\n    optsOut.font = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      var fonti = optsOut.font[i] = {};\n      fonti.size = Array.isArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs;\n      fonti.family = Array.isArray(tff) ? tff[i] : tff;\n    }\n  } else {\n    // if both are single values, make render fast single-value\n    optsOut.font = {\n      size: tfs,\n      family: tff\n    };\n  }\n\n  return optsOut;\n}\n\nfunction convertMarkerStyle(trace) {\n  var count = trace._length;\n  var optsIn = trace.marker;\n  var optsOut = {};\n  var i;\n  var multiSymbol = Array.isArray(optsIn.symbol);\n  var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n  var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n  var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n  var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n  var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n  var isOpen;\n  if (!multiSymbol) isOpen = constants.OPEN_RE.test(optsIn.symbol); // prepare colors\n\n  if (multiSymbol || multiColor || multiLineColor || multiOpacity) {\n    optsOut.colors = new Array(count);\n    optsOut.borderColors = new Array(count);\n    var colors = formatColor(optsIn, optsIn.opacity, count);\n    var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n    if (!Array.isArray(borderColors[0])) {\n      var borderColor = borderColors;\n      borderColors = Array(count);\n\n      for (i = 0; i < count; i++) {\n        borderColors[i] = borderColor;\n      }\n    }\n\n    if (!Array.isArray(colors[0])) {\n      var color = colors;\n      colors = Array(count);\n\n      for (i = 0; i < count; i++) {\n        colors[i] = color;\n      }\n    }\n\n    optsOut.colors = colors;\n    optsOut.borderColors = borderColors;\n\n    for (i = 0; i < count; i++) {\n      if (multiSymbol) {\n        var symbol = optsIn.symbol[i];\n        isOpen = constants.OPEN_RE.test(symbol);\n      }\n\n      if (isOpen) {\n        borderColors[i] = colors[i].slice();\n        colors[i] = colors[i].slice();\n        colors[i][3] = 0;\n      }\n    }\n\n    optsOut.opacity = trace.opacity;\n  } else {\n    if (isOpen) {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.color[3] = 0;\n      optsOut.borderColor = rgba(optsIn.color, 'uint8');\n    } else {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n    }\n\n    optsOut.opacity = trace.opacity * optsIn.opacity;\n  } // prepare symbols\n\n\n  if (multiSymbol) {\n    optsOut.markers = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      optsOut.markers[i] = getSymbolSdf(optsIn.symbol[i]);\n    }\n  } else {\n    optsOut.marker = getSymbolSdf(optsIn.symbol);\n  } // prepare sizes\n\n\n  var markerSizeFunc = makeBubbleSizeFn(trace);\n  var s;\n\n  if (multiSize || multiLineWidth) {\n    var sizes = optsOut.sizes = new Array(count);\n    var borderSizes = optsOut.borderSizes = new Array(count);\n    var sizeTotal = 0;\n    var sizeAvg;\n\n    if (multiSize) {\n      for (i = 0; i < count; i++) {\n        sizes[i] = markerSizeFunc(optsIn.size[i]);\n        sizeTotal += sizes[i];\n      }\n\n      sizeAvg = sizeTotal / count;\n    } else {\n      s = markerSizeFunc(optsIn.size);\n\n      for (i = 0; i < count; i++) {\n        sizes[i] = s;\n      }\n    } // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n\n\n    if (multiLineWidth) {\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = optsIn.line.width[i] / 2;\n      }\n    } else {\n      s = optsIn.line.width / 2;\n\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = s;\n      }\n    }\n\n    optsOut.sizeAvg = sizeAvg;\n  } else {\n    optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n    optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n  }\n\n  return optsOut;\n}\n\nfunction convertMarkerSelection(trace, target) {\n  var optsIn = trace.marker;\n  var optsOut = {};\n  if (!target) return optsOut;\n\n  if (target.marker && target.marker.symbol) {\n    optsOut = convertMarkerStyle(Lib.extendFlat({}, optsIn, target.marker));\n  } else if (target.marker) {\n    if (target.marker.size) optsOut.size = target.marker.size / 2;\n    if (target.marker.color) optsOut.colors = target.marker.color;\n    if (target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n  }\n\n  return optsOut;\n}\n\nfunction convertTextSelection(trace, target) {\n  var optsOut = {};\n  if (!target) return optsOut;\n\n  if (target.textfont) {\n    var optsIn = {\n      opacity: 1,\n      text: trace.text,\n      textposition: trace.textposition,\n      textfont: Lib.extendFlat({}, trace.textfont)\n    };\n\n    if (target.textfont) {\n      Lib.extendFlat(optsIn.textfont, target.textfont);\n    }\n\n    optsOut = convertTextStyle(optsIn);\n  }\n\n  return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target) {\n  var optsOut = {\n    capSize: target.width * 2,\n    lineWidth: target.thickness,\n    color: target.color\n  };\n\n  if (target.copy_ystyle) {\n    optsOut = trace.error_y;\n  }\n\n  return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(symbol) {\n  if (symbol === 'circle') return null;\n  var symbolPath, symbolSdf;\n  var symbolNumber = Drawing.symbolNumber(symbol);\n  var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n  var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n  var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n  var isDot = constants.DOT_RE.test(symbol); // get symbol sdf from cache or generate it\n\n  if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n  if (isDot && !symbolNoDot) {\n    symbolPath = symbolFunc(SYMBOL_SIZE * 1.1) + SYMBOL_SVG_CIRCLE;\n  } else {\n    symbolPath = symbolFunc(SYMBOL_SIZE);\n  }\n\n  symbolSdf = svgSdf(symbolPath, {\n    w: SYMBOL_SDF_SIZE,\n    h: SYMBOL_SDF_SIZE,\n    viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n    stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n  });\n  SYMBOL_SDF[symbol] = symbolSdf;\n  return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n  var len = positions.length;\n  var count = len / 2;\n  var linePositions;\n  var i;\n\n  if (subTypes.hasLines(trace) && count) {\n    if (trace.line.shape === 'hv') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'hvh') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], midPtX, positions[i * 2 + 1], midPtX, positions[i * 2 + 3]);\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vhv') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], positions[i * 2], midPtY, positions[i * 2 + 2], midPtY);\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vh') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else {\n      linePositions = positions;\n    }\n  } // If we have data with gaps, we ought to use rect joins\n  // FIXME: get rid of this\n\n\n  var hasNaN = false;\n\n  for (i = 0; i < linePositions.length; i++) {\n    if (isNaN(linePositions[i])) {\n      hasNaN = true;\n      break;\n    }\n  }\n\n  var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? 'rect' : subTypes.hasMarkers(trace) ? 'rect' : 'round'; // fill gaps\n\n  if (hasNaN && trace.connectgaps) {\n    var lastX = linePositions[0];\n    var lastY = linePositions[1];\n\n    for (i = 0; i < linePositions.length; i += 2) {\n      if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n        linePositions[i] = lastX;\n        linePositions[i + 1] = lastY;\n      } else {\n        lastX = linePositions[i];\n        lastY = linePositions[i + 1];\n      }\n    }\n  }\n\n  return {\n    join: join,\n    positions: linePositions\n  };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n  var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n  var xa = AxisIDs.getFromId(gd, trace.xaxis);\n  var ya = AxisIDs.getFromId(gd, trace.yaxis);\n  var count = positions.length / 2;\n  var out = {};\n\n  function convertOneAxis(coords, ax) {\n    var axLetter = ax._id.charAt(0);\n\n    var opts = trace['error_' + axLetter];\n\n    if (opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n      var computeError = makeComputeError(opts);\n      var pOffset = {\n        x: 0,\n        y: 1\n      }[axLetter];\n      var eOffset = {\n        x: [0, 1, 2, 3],\n        y: [2, 3, 0, 1]\n      }[axLetter];\n      var errors = new Float64Array(4 * count);\n      var minShoe = Infinity;\n      var maxHat = -Infinity;\n\n      for (var i = 0, j = 0; i < count; i++, j += 4) {\n        var dc = coords[i];\n\n        if (isNumeric(dc)) {\n          var dl = positions[i * 2 + pOffset];\n          var vals = computeError(dc, i);\n          var lv = vals[0];\n          var hv = vals[1];\n\n          if (isNumeric(lv) && isNumeric(hv)) {\n            var shoe = dc - lv;\n            var hat = dc + hv;\n            errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n            errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n            errors[j + eOffset[2]] = 0;\n            errors[j + eOffset[3]] = 0;\n            minShoe = Math.min(minShoe, dc - lv);\n            maxHat = Math.max(maxHat, dc + hv);\n          }\n        }\n      }\n\n      out[axLetter] = {\n        positions: positions,\n        errors: errors,\n        _bnds: [minShoe, maxHat]\n      };\n    }\n  }\n\n  convertOneAxis(x, xa);\n  convertOneAxis(y, ya);\n  return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n  var count = trace._length;\n  var out = {};\n  var i; // corresponds to textPointPosition from component.drawing\n\n  if (subTypes.hasMarkers(trace)) {\n    var fontOpts = textOpts.font;\n    var align = textOpts.align;\n    var baseline = textOpts.baseline;\n    out.offset = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n      var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n      var a = Array.isArray(align) ? align.length > 1 ? align[i] : align[0] : align;\n      var b = Array.isArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;\n      var hSign = TEXTOFFSETSIGN[a];\n      var vSign = TEXTOFFSETSIGN[b];\n      var xPad = ms ? ms / 0.8 + 1 : 0;\n      var yPad = -vSign * xPad - vSign * 0.5;\n      out.offset[i] = [hSign * xPad / fs, yPad / fs];\n    }\n  }\n\n  return out;\n}\n\nmodule.exports = {\n  style: convertStyle,\n  markerStyle: convertMarkerStyle,\n  markerSelection: convertMarkerSelection,\n  linePositions: convertLinePositions,\n  errorBarPositions: convertErrorBarPositions,\n  textPosition: convertTextPosition\n};","map":null,"metadata":{},"sourceType":"script"}