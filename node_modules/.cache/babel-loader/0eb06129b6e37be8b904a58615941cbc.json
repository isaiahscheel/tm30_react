{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nvar tinycolor = require('tinycolor2');\n\nvar Color = require('../../components/color');\n\nvar extendedColorWayList = {};\n\nfunction calc(gd, trace) {\n  var cd = [];\n  var fullLayout = gd._fullLayout;\n  var hiddenLabels = fullLayout.hiddenlabels || [];\n  var labels = trace.labels;\n  var colors = trace.marker.colors || [];\n  var vals = trace.values;\n  var hasVals = isArrayOrTypedArray(vals) && vals.length;\n  var i, pt;\n\n  if (trace.dlabel) {\n    labels = new Array(vals.length);\n\n    for (i = 0; i < vals.length; i++) {\n      labels[i] = String(trace.label0 + i * trace.dlabel);\n    }\n  }\n\n  var allThisTraceLabels = {};\n  var pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n  var seriesLen = (hasVals ? vals : labels).length;\n  var vTotal = 0;\n  var isAggregated = false;\n\n  for (i = 0; i < seriesLen; i++) {\n    var v, label, hidden;\n\n    if (hasVals) {\n      v = vals[i];\n      if (!isNumeric(v)) continue;\n      v = +v;\n      if (v < 0) continue;\n    } else v = 1;\n\n    label = labels[i];\n    if (label === undefined || label === '') label = i;\n    label = String(label);\n    var thisLabelIndex = allThisTraceLabels[label];\n\n    if (thisLabelIndex === undefined) {\n      allThisTraceLabels[label] = cd.length;\n      hidden = hiddenLabels.indexOf(label) !== -1;\n      if (!hidden) vTotal += v;\n      cd.push({\n        v: v,\n        label: label,\n        color: pullColor(colors[i], label),\n        i: i,\n        pts: [i],\n        hidden: hidden\n      });\n    } else {\n      isAggregated = true;\n      pt = cd[thisLabelIndex];\n      pt.v += v;\n      pt.pts.push(i);\n      if (!pt.hidden) vTotal += v;\n\n      if (pt.color === false && colors[i]) {\n        pt.color = pullColor(colors[i], label);\n      }\n    }\n  }\n\n  var shouldSort = trace.type === 'funnelarea' ? isAggregated : trace.sort;\n  if (shouldSort) cd.sort(function (a, b) {\n    return b.v - a.v;\n  }); // include the sum of all values in the first point\n\n  if (cd[0]) cd[0].vTotal = vTotal;\n  return cd;\n}\n\nfunction makePullColorFn(colorMap) {\n  return function pullColor(color, id) {\n    if (!color) return false;\n    color = tinycolor(color);\n    if (!color.isValid()) return false;\n    color = Color.addOpacity(color, color.getAlpha());\n    if (!colorMap[id]) colorMap[id] = color;\n    return color;\n  };\n}\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\n\n\nfunction crossTraceCalc(gd, plotinfo) {\n  // TODO: should we name the second argument opts?\n  var desiredType = (plotinfo || {}).type;\n  if (!desiredType) desiredType = 'pie';\n  var fullLayout = gd._fullLayout;\n  var calcdata = gd.calcdata;\n  var colorWay = fullLayout[desiredType + 'colorway'];\n  var colorMap = fullLayout['_' + desiredType + 'colormap'];\n\n  if (fullLayout['extend' + desiredType + 'colors']) {\n    colorWay = generateExtendedColors(colorWay, extendedColorWayList);\n  }\n\n  var dfltColorCount = 0;\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var traceType = cd[0].trace.type;\n    if (traceType !== desiredType) continue;\n\n    for (var j = 0; j < cd.length; j++) {\n      var pt = cd[j];\n\n      if (pt.color === false) {\n        // have we seen this label and assigned a color to it in a previous trace?\n        if (colorMap[pt.label]) {\n          pt.color = colorMap[pt.label];\n        } else {\n          colorMap[pt.label] = pt.color = colorWay[dfltColorCount % colorWay.length];\n          dfltColorCount++;\n        }\n      }\n    }\n  }\n}\n/**\n * pick a default color from the main default set, augmented by\n * itself lighter then darker before repeating\n */\n\n\nfunction generateExtendedColors(colorList, extendedColorWays) {\n  var i;\n  var colorString = JSON.stringify(colorList);\n  var colors = extendedColorWays[colorString];\n\n  if (!colors) {\n    colors = colorList.slice();\n\n    for (i = 0; i < colorList.length; i++) {\n      colors.push(tinycolor(colorList[i]).lighten(20).toHexString());\n    }\n\n    for (i = 0; i < colorList.length; i++) {\n      colors.push(tinycolor(colorList[i]).darken(20).toHexString());\n    }\n\n    extendedColorWays[colorString] = colors;\n  }\n\n  return colors;\n}\n\nmodule.exports = {\n  calc: calc,\n  crossTraceCalc: crossTraceCalc,\n  makePullColorFn: makePullColorFn,\n  generateExtendedColors: generateExtendedColors\n};","map":null,"metadata":{},"sourceType":"script"}