{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar createScatter = require('regl-scatter2d');\n\nvar createLine = require('regl-line2d');\n\nvar createError = require('regl-error2d');\n\nvar Text = require('gl-text');\n\nvar Lib = require('../../lib');\n\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar linkTraces = require('../scatter/link_traces');\n\nvar styleTextSelection = require('./edit_style').styleTextSelection;\n\nfunction getViewport(fullLayout, xaxis, yaxis) {\n  var gs = fullLayout._size;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  return [gs.l + xaxis.domain[0] * gs.w, gs.b + yaxis.domain[0] * gs.h, width - gs.r - (1 - xaxis.domain[1]) * gs.w, height - gs.t - (1 - yaxis.domain[1]) * gs.h];\n}\n\nmodule.exports = function plot(gd, subplot, cdata) {\n  if (!cdata.length) return;\n  var fullLayout = gd._fullLayout;\n  var scene = subplot._scene;\n  var xaxis = subplot.xaxis;\n  var yaxis = subplot.yaxis;\n  var i, j; // we may have more subplots than initialized data due to Axes.getSubplots method\n\n  if (!scene) return;\n  var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n\n  if (!success) {\n    scene.init();\n    return;\n  }\n\n  var count = scene.count;\n\n  var regl = fullLayout._glcanvas.data()[0].regl; // that is needed for fills\n\n\n  linkTraces(gd, subplot, cdata);\n\n  if (scene.dirty) {\n    // make sure scenes are created\n    if (scene.error2d === true) {\n      scene.error2d = createError(regl);\n    }\n\n    if (scene.line2d === true) {\n      scene.line2d = createLine(regl);\n    }\n\n    if (scene.scatter2d === true) {\n      scene.scatter2d = createScatter(regl);\n    }\n\n    if (scene.fill2d === true) {\n      scene.fill2d = createLine(regl);\n    }\n\n    if (scene.glText === true) {\n      scene.glText = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i] = new Text(regl);\n      }\n    } // update main marker options\n\n\n    if (scene.glText) {\n      if (count > scene.glText.length) {\n        // add gl text marker\n        var textsToAdd = count - scene.glText.length;\n\n        for (i = 0; i < textsToAdd; i++) {\n          scene.glText.push(new Text(regl));\n        }\n      } else if (count < scene.glText.length) {\n        // remove gl text marker\n        var textsToRemove = scene.glText.length - count;\n        var removedTexts = scene.glText.splice(count, textsToRemove);\n        removedTexts.forEach(function (text) {\n          text.destroy();\n        });\n      }\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i].update(scene.textOptions[i]);\n      }\n    }\n\n    if (scene.line2d) {\n      scene.line2d.update(scene.lineOptions);\n      scene.lineOptions = scene.lineOptions.map(function (lineOptions) {\n        if (lineOptions && lineOptions.positions) {\n          var srcPos = lineOptions.positions;\n          var firstptdef = 0;\n\n          while (firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n            firstptdef += 2;\n          }\n\n          var lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n            lastptdef -= 2;\n          }\n\n          lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n        }\n\n        return lineOptions;\n      });\n      scene.line2d.update(scene.lineOptions);\n    }\n\n    if (scene.error2d) {\n      var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n      scene.error2d.update(errorBatch);\n    }\n\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    } // fill requires linked traces, so we generate it's positions here\n\n\n    scene.fillOrder = Lib.repeat(null, count);\n\n    if (scene.fill2d) {\n      scene.fillOptions = scene.fillOptions.map(function (fillOptions, i) {\n        var cdscatter = cdata[i];\n        if (!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n        var cd = cdscatter[0];\n        var trace = cd.trace;\n        var stash = cd.t;\n        var lineOptions = scene.lineOptions[i];\n        var last, j;\n        var fillData = [];\n        if (trace._ownfill) fillData.push(i);\n        if (trace._nexttrace) fillData.push(i + 1);\n        if (fillData.length) scene.fillOrder[i] = fillData;\n        var pos = [];\n        var srcPos = lineOptions && lineOptions.positions || stash.positions;\n        var firstptdef, lastptdef;\n\n        if (trace.fill === 'tozeroy') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef + 1] !== 0) {\n            pos = [srcPos[firstptdef], 0];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef + 1] !== 0) {\n            pos = pos.concat([srcPos[lastptdef], 0]);\n          }\n        } else if (trace.fill === 'tozerox') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef] !== 0) {\n            pos = [0, srcPos[firstptdef + 1]];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef] !== 0) {\n            pos = pos.concat([0, srcPos[lastptdef + 1]]);\n          }\n        } else if (trace.fill === 'toself' || trace.fill === 'tonext') {\n          pos = [];\n          last = 0;\n\n          for (j = 0; j < srcPos.length; j += 2) {\n            if (isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n              pos = pos.concat(srcPos.slice(last, j));\n              pos.push(srcPos[last], srcPos[last + 1]);\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(srcPos.slice(last));\n\n          if (last) {\n            pos.push(srcPos[last], srcPos[last + 1]);\n          }\n        } else {\n          var nextTrace = trace._nexttrace;\n\n          if (nextTrace) {\n            var nextOptions = scene.lineOptions[i + 1];\n\n            if (nextOptions) {\n              var nextPos = nextOptions.positions;\n\n              if (trace.fill === 'tonexty') {\n                pos = srcPos.slice();\n\n                for (i = Math.floor(nextPos.length / 2); i--;) {\n                  var xx = nextPos[i * 2];\n                  var yy = nextPos[i * 2 + 1];\n                  if (isNaN(xx) || isNaN(yy)) continue;\n                  pos.push(xx, yy);\n                }\n\n                fillOptions.fill = nextTrace.fillcolor;\n              }\n            }\n          }\n        } // detect prev trace positions to exclude from current fill\n\n\n        if (trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n          var prevLinePos = scene.lineOptions[i - 1].positions; // FIXME: likely this logic should be tested better\n\n          var offset = pos.length / 2;\n          last = offset;\n          var hole = [last];\n\n          for (j = 0; j < prevLinePos.length; j += 2) {\n            if (isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n              hole.push(j / 2 + offset + 1);\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(prevLinePos);\n          fillOptions.hole = hole;\n        }\n\n        fillOptions.fillmode = trace.fill;\n        fillOptions.opacity = trace.opacity;\n        fillOptions.positions = pos;\n        return fillOptions;\n      });\n      scene.fill2d.update(scene.fillOptions);\n    }\n  } // form batch arrays, and check for selected points\n\n\n  var dragmode = fullLayout.dragmode;\n  var selectMode = dragmode === 'lasso' || dragmode === 'select';\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n  for (i = 0; i < count; i++) {\n    var cd0 = cdata[i][0];\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var index = stash.index;\n    var len = trace._length;\n    var x = stash.x;\n    var y = stash.y;\n\n    if (trace.selectedpoints || selectMode || clickSelectEnabled) {\n      if (!selectMode) selectMode = true; // regenerate scene batch, if traces number changed during selection\n\n      if (trace.selectedpoints) {\n        var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n        var selDict = {};\n\n        for (j = 0; j < selPts.length; j++) {\n          selDict[selPts[j]] = 1;\n        }\n\n        var unselPts = [];\n\n        for (j = 0; j < len; j++) {\n          if (!selDict[j]) unselPts.push(j);\n        }\n\n        scene.unselectBatch[index] = unselPts;\n      } // precalculate px coords since we are not going to pan during select\n      // TODO, could do better here e.g.\n      // - spin that in a webworker\n      // - compute selection from polygons in data coordinates\n      //   (maybe just for linear axes)\n\n\n      var xpx = stash.xpx = new Array(len);\n      var ypx = stash.ypx = new Array(len);\n\n      for (j = 0; j < len; j++) {\n        xpx[j] = xaxis.c2p(x[j]);\n        ypx[j] = yaxis.c2p(y[j]);\n      }\n    } else {\n      stash.xpx = stash.ypx = null;\n    }\n  }\n\n  if (selectMode) {\n    // create scatter instance by cloning scatter2d\n    if (!scene.select2d) {\n      scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n    } // use unselected styles on 'context' canvas\n\n\n    if (scene.scatter2d) {\n      var unselOpts = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ? scene.markerUnselectedOptions[i] : {};\n      }\n\n      scene.scatter2d.update(unselOpts);\n    } // use selected style on 'focus' canvas\n\n\n    if (scene.select2d) {\n      scene.select2d.update(scene.markerOptions);\n      scene.select2d.update(scene.markerSelectedOptions);\n    }\n\n    if (scene.glText) {\n      cdata.forEach(function (cdscatter) {\n        var trace = ((cdscatter || [])[0] || {}).trace || {};\n\n        if (subTypes.hasText(trace)) {\n          styleTextSelection(cdscatter);\n        }\n      });\n    }\n  } else {\n    // reset 'context' scatter2d opts to base opts,\n    // thus unsetting markerUnselectedOptions from selection\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    }\n  } // provide viewport and range\n\n\n  var vpRange0 = {\n    viewport: getViewport(fullLayout, xaxis, yaxis),\n    // TODO do we need those fallbacks?\n    range: [(xaxis._rl || xaxis.range)[0], (yaxis._rl || yaxis.range)[0], (xaxis._rl || xaxis.range)[1], (yaxis._rl || yaxis.range)[1]]\n  };\n  var vpRange = Lib.repeat(vpRange0, scene.count); // upload viewport/range data to GPU\n\n  if (scene.fill2d) {\n    scene.fill2d.update(vpRange);\n  }\n\n  if (scene.line2d) {\n    scene.line2d.update(vpRange);\n  }\n\n  if (scene.error2d) {\n    scene.error2d.update(vpRange.concat(vpRange));\n  }\n\n  if (scene.scatter2d) {\n    scene.scatter2d.update(vpRange);\n  }\n\n  if (scene.select2d) {\n    scene.select2d.update(vpRange);\n  }\n\n  if (scene.glText) {\n    scene.glText.forEach(function (text) {\n      text.update(vpRange0);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}