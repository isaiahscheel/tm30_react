{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar c = require('./constants');\n\nvar d3 = require('d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar d3Sankey = require('@plotly/d3-sankey');\n\nvar d3SankeyCircular = require('@plotly/d3-sankey-circular');\n\nvar d3Force = require('d3-force');\n\nvar Lib = require('../../lib');\n\nvar gup = require('../../lib/gup');\n\nvar keyFun = gup.keyFun;\nvar repeat = gup.repeat;\nvar unwrap = gup.unwrap;\n\nvar interpolateNumber = require('d3-interpolate').interpolateNumber;\n\nvar Registry = require('../../registry'); // view models\n\n\nfunction sankeyModel(layout, d, traceIndex) {\n  var calcData = unwrap(d);\n  var trace = calcData.trace;\n  var domain = trace.domain;\n  var horizontal = trace.orientation === 'h';\n  var nodePad = trace.node.pad;\n  var nodeThickness = trace.node.thickness;\n  var width = layout.width * (domain.x[1] - domain.x[0]);\n  var height = layout.height * (domain.y[1] - domain.y[0]);\n  var nodes = calcData._nodes;\n  var links = calcData._links;\n  var circular = calcData.circular; // Select Sankey generator\n\n  var sankey;\n\n  if (circular) {\n    sankey = d3SankeyCircular.sankeyCircular().circularLinkGap(0);\n  } else {\n    sankey = d3Sankey.sankey();\n  }\n\n  sankey.iterations(c.sankeyIterations).size(horizontal ? [width, height] : [height, width]).nodeWidth(nodeThickness).nodePadding(nodePad).nodeId(function (d) {\n    return d.pointNumber;\n  }).nodes(nodes).links(links);\n  var graph = sankey();\n\n  if (sankey.nodePadding() < nodePad) {\n    Lib.warn('node.pad was reduced to ', sankey.nodePadding(), ' to fit within the figure.');\n  } // Counters for nested loops\n\n\n  var i, j, k; // Create transient nodes for animations\n\n  for (var nodePointNumber in calcData._groupLookup) {\n    var groupIndex = parseInt(calcData._groupLookup[nodePointNumber]); // Find node representing groupIndex\n\n    var groupingNode;\n\n    for (i = 0; i < graph.nodes.length; i++) {\n      if (graph.nodes[i].pointNumber === groupIndex) {\n        groupingNode = graph.nodes[i];\n        break;\n      }\n    } // If groupinNode is undefined, no links are targeting this group\n\n\n    if (!groupingNode) continue;\n    var child = {\n      pointNumber: parseInt(nodePointNumber),\n      x0: groupingNode.x0,\n      x1: groupingNode.x1,\n      y0: groupingNode.y0,\n      y1: groupingNode.y1,\n      partOfGroup: true,\n      sourceLinks: [],\n      targetLinks: []\n    };\n    graph.nodes.unshift(child);\n    groupingNode.childrenNodes.unshift(child);\n  }\n\n  function computeLinkConcentrations() {\n    for (i = 0; i < graph.nodes.length; i++) {\n      var node = graph.nodes[i]; // Links connecting the same two nodes are part of a flow\n\n      var flows = {};\n      var flowKey;\n      var link;\n\n      for (j = 0; j < node.targetLinks.length; j++) {\n        link = node.targetLinks[j];\n        flowKey = link.source.pointNumber + ':' + link.target.pointNumber;\n        if (!flows.hasOwnProperty(flowKey)) flows[flowKey] = [];\n        flows[flowKey].push(link);\n      } // Compute statistics for each flow\n\n\n      var keys = Object.keys(flows);\n\n      for (j = 0; j < keys.length; j++) {\n        flowKey = keys[j];\n        var flowLinks = flows[flowKey]; // Find the total size of the flow and total size per label\n\n        var total = 0;\n        var totalPerLabel = {};\n\n        for (k = 0; k < flowLinks.length; k++) {\n          link = flowLinks[k];\n          if (!totalPerLabel[link.label]) totalPerLabel[link.label] = 0;\n          totalPerLabel[link.label] += link.value;\n          total += link.value;\n        } // Find the ratio of the link's value and the size of the flow\n\n\n        for (k = 0; k < flowLinks.length; k++) {\n          link = flowLinks[k];\n          link.flow = {\n            value: total,\n            labelConcentration: totalPerLabel[link.label] / total,\n            concentration: link.value / total,\n            links: flowLinks\n          };\n\n          if (link.concentrationscale) {\n            link.color = tinycolor(link.concentrationscale(link.flow.labelConcentration));\n          }\n        }\n      } // Gather statistics of all links at current node\n\n\n      var totalOutflow = 0;\n\n      for (j = 0; j < node.sourceLinks.length; j++) {\n        totalOutflow += node.sourceLinks[j].value;\n      }\n\n      for (j = 0; j < node.sourceLinks.length; j++) {\n        link = node.sourceLinks[j];\n        link.concentrationOut = link.value / totalOutflow;\n      }\n\n      var totalInflow = 0;\n\n      for (j = 0; j < node.targetLinks.length; j++) {\n        totalInflow += node.targetLinks[j].value;\n      }\n\n      for (j = 0; j < node.targetLinks.length; j++) {\n        link = node.targetLinks[j];\n        link.concenrationIn = link.value / totalInflow;\n      }\n    }\n  }\n\n  computeLinkConcentrations(); // Push any overlapping nodes down.\n\n  function resolveCollisionsTopToBottom(columns) {\n    columns.forEach(function (nodes) {\n      var node;\n      var dy;\n      var y = 0;\n      var n = nodes.length;\n      var i;\n      nodes.sort(function (a, b) {\n        return a.y0 - b.y0;\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n\n        if (node.y0 >= y) {// No overlap\n        } else {\n          dy = y - node.y0;\n          if (dy > 1e-6) node.y0 += dy, node.y1 += dy;\n        }\n\n        y = node.y1 + nodePad;\n      }\n    });\n  } // Group nodes into columns based on their x position\n\n\n  function snapToColumns(nodes) {\n    // Sort nodes by x position\n    var orderedNodes = nodes.map(function (n, i) {\n      return {\n        x0: n.x0,\n        index: i\n      };\n    }).sort(function (a, b) {\n      return a.x0 - b.x0;\n    });\n    var columns = [];\n    var colNumber = -1;\n    var colX; // Position of column\n\n    var lastX = -Infinity; // Position of last node\n\n    var dx;\n\n    for (i = 0; i < orderedNodes.length; i++) {\n      var node = nodes[orderedNodes[i].index]; // If the node does not overlap with the last one\n\n      if (node.x0 > lastX + nodeThickness) {\n        // Start a new column\n        colNumber += 1;\n        colX = node.x0;\n      }\n\n      lastX = node.x0; // Add node to its associated column\n\n      if (!columns[colNumber]) columns[colNumber] = [];\n      columns[colNumber].push(node); // Change node's x position to align it with its column\n\n      dx = colX - node.x0;\n      node.x0 += dx, node.x1 += dx;\n    }\n\n    return columns;\n  } // Force node position\n\n\n  if (trace.node.x.length && trace.node.y.length) {\n    for (i = 0; i < Math.min(trace.node.x.length, trace.node.y.length, graph.nodes.length); i++) {\n      if (trace.node.x[i] && trace.node.y[i]) {\n        var pos = [trace.node.x[i] * width, trace.node.y[i] * height];\n        graph.nodes[i].x0 = pos[0] - nodeThickness / 2;\n        graph.nodes[i].x1 = pos[0] + nodeThickness / 2;\n        var nodeHeight = graph.nodes[i].y1 - graph.nodes[i].y0;\n        graph.nodes[i].y0 = pos[1] - nodeHeight / 2;\n        graph.nodes[i].y1 = pos[1] + nodeHeight / 2;\n      }\n    }\n\n    if (trace.arrangement === 'snap') {\n      nodes = graph.nodes;\n      var columns = snapToColumns(nodes);\n      resolveCollisionsTopToBottom(columns);\n    } // Update links\n\n\n    sankey.update(graph);\n  }\n\n  return {\n    circular: circular,\n    key: traceIndex,\n    trace: trace,\n    guid: Lib.randstr(),\n    horizontal: horizontal,\n    width: width,\n    height: height,\n    nodePad: trace.node.pad,\n    nodeLineColor: trace.node.line.color,\n    nodeLineWidth: trace.node.line.width,\n    linkLineColor: trace.link.line.color,\n    linkLineWidth: trace.link.line.width,\n    valueFormat: trace.valueformat,\n    valueSuffix: trace.valuesuffix,\n    textFont: trace.textfont,\n    translateX: domain.x[0] * layout.width + layout.margin.l,\n    translateY: layout.height - domain.y[1] * layout.height + layout.margin.t,\n    dragParallel: horizontal ? height : width,\n    dragPerpendicular: horizontal ? width : height,\n    arrangement: trace.arrangement,\n    sankey: sankey,\n    graph: graph,\n    forceLayouts: {},\n    interactionState: {\n      dragInProgress: false,\n      hovered: false\n    }\n  };\n}\n\nfunction linkModel(d, l, i) {\n  var tc = tinycolor(l.color);\n  var basicKey = l.source.label + '|' + l.target.label;\n  var key = basicKey + '__' + i; // for event data\n\n  l.trace = d.trace;\n  l.curveNumber = d.trace.index;\n  return {\n    circular: d.circular,\n    key: key,\n    traceId: d.key,\n    pointNumber: l.pointNumber,\n    link: l,\n    tinyColorHue: Color.tinyRGB(tc),\n    tinyColorAlpha: tc.getAlpha(),\n    linkPath: linkPath,\n    linkLineColor: d.linkLineColor,\n    linkLineWidth: d.linkLineWidth,\n    valueFormat: d.valueFormat,\n    valueSuffix: d.valueSuffix,\n    sankey: d.sankey,\n    parent: d,\n    interactionState: d.interactionState,\n    flow: l.flow\n  };\n}\n\nfunction createCircularClosedPathString(link) {\n  // Using coordinates computed by d3-sankey-circular\n  var pathString = '';\n  var offset = link.width / 2;\n  var coords = link.circularPathData;\n\n  if (link.circularLinkType === 'top') {\n    // Top path\n    pathString = // start at the left of the target node\n    'M ' + coords.targetX + ' ' + (coords.targetY + offset) + ' ' + 'L' + coords.rightInnerExtent + ' ' + (coords.targetY + offset) + 'A' + (coords.rightLargeArcRadius + offset) + ' ' + (coords.rightSmallArcRadius + offset) + ' 0 0 1 ' + (coords.rightFullExtent - offset) + ' ' + (coords.targetY - coords.rightSmallArcRadius) + 'L' + (coords.rightFullExtent - offset) + ' ' + coords.verticalRightInnerExtent + 'A' + (coords.rightLargeArcRadius + offset) + ' ' + (coords.rightLargeArcRadius + offset) + ' 0 0 1 ' + coords.rightInnerExtent + ' ' + (coords.verticalFullExtent - offset) + 'L' + coords.leftInnerExtent + ' ' + (coords.verticalFullExtent - offset) + 'A' + (coords.leftLargeArcRadius + offset) + ' ' + (coords.leftLargeArcRadius + offset) + ' 0 0 1 ' + (coords.leftFullExtent + offset) + ' ' + coords.verticalLeftInnerExtent + 'L' + (coords.leftFullExtent + offset) + ' ' + (coords.sourceY - coords.leftSmallArcRadius) + 'A' + (coords.leftLargeArcRadius + offset) + ' ' + (coords.leftSmallArcRadius + offset) + ' 0 0 1 ' + coords.leftInnerExtent + ' ' + (coords.sourceY + offset) + 'L' + coords.sourceX + ' ' + (coords.sourceY + offset) + // Walking back\n    'L' + coords.sourceX + ' ' + (coords.sourceY - offset) + 'L' + coords.leftInnerExtent + ' ' + (coords.sourceY - offset) + 'A' + (coords.leftLargeArcRadius - offset) + ' ' + (coords.leftSmallArcRadius - offset) + ' 0 0 0 ' + (coords.leftFullExtent - offset) + ' ' + (coords.sourceY - coords.leftSmallArcRadius) + 'L' + (coords.leftFullExtent - offset) + ' ' + coords.verticalLeftInnerExtent + 'A' + (coords.leftLargeArcRadius - offset) + ' ' + (coords.leftLargeArcRadius - offset) + ' 0 0 0 ' + coords.leftInnerExtent + ' ' + (coords.verticalFullExtent + offset) + 'L' + coords.rightInnerExtent + ' ' + (coords.verticalFullExtent + offset) + 'A' + (coords.rightLargeArcRadius - offset) + ' ' + (coords.rightLargeArcRadius - offset) + ' 0 0 0 ' + (coords.rightFullExtent + offset) + ' ' + coords.verticalRightInnerExtent + 'L' + (coords.rightFullExtent + offset) + ' ' + (coords.targetY - coords.rightSmallArcRadius) + 'A' + (coords.rightLargeArcRadius - offset) + ' ' + (coords.rightSmallArcRadius - offset) + ' 0 0 0 ' + coords.rightInnerExtent + ' ' + (coords.targetY - offset) + 'L' + coords.targetX + ' ' + (coords.targetY - offset) + 'Z';\n  } else {\n    // Bottom path\n    pathString = // start at the left of the target node\n    'M ' + coords.targetX + ' ' + (coords.targetY - offset) + ' ' + 'L' + coords.rightInnerExtent + ' ' + (coords.targetY - offset) + 'A' + (coords.rightLargeArcRadius + offset) + ' ' + (coords.rightSmallArcRadius + offset) + ' 0 0 0 ' + (coords.rightFullExtent - offset) + ' ' + (coords.targetY + coords.rightSmallArcRadius) + 'L' + (coords.rightFullExtent - offset) + ' ' + coords.verticalRightInnerExtent + 'A' + (coords.rightLargeArcRadius + offset) + ' ' + (coords.rightLargeArcRadius + offset) + ' 0 0 0 ' + coords.rightInnerExtent + ' ' + (coords.verticalFullExtent + offset) + 'L' + coords.leftInnerExtent + ' ' + (coords.verticalFullExtent + offset) + 'A' + (coords.leftLargeArcRadius + offset) + ' ' + (coords.leftLargeArcRadius + offset) + ' 0 0 0 ' + (coords.leftFullExtent + offset) + ' ' + coords.verticalLeftInnerExtent + 'L' + (coords.leftFullExtent + offset) + ' ' + (coords.sourceY + coords.leftSmallArcRadius) + 'A' + (coords.leftLargeArcRadius + offset) + ' ' + (coords.leftSmallArcRadius + offset) + ' 0 0 0 ' + coords.leftInnerExtent + ' ' + (coords.sourceY - offset) + 'L' + coords.sourceX + ' ' + (coords.sourceY - offset) + // Walking back\n    'L' + coords.sourceX + ' ' + (coords.sourceY + offset) + 'L' + coords.leftInnerExtent + ' ' + (coords.sourceY + offset) + 'A' + (coords.leftLargeArcRadius - offset) + ' ' + (coords.leftSmallArcRadius - offset) + ' 0 0 1 ' + (coords.leftFullExtent - offset) + ' ' + (coords.sourceY + coords.leftSmallArcRadius) + 'L' + (coords.leftFullExtent - offset) + ' ' + coords.verticalLeftInnerExtent + 'A' + (coords.leftLargeArcRadius - offset) + ' ' + (coords.leftLargeArcRadius - offset) + ' 0 0 1 ' + coords.leftInnerExtent + ' ' + (coords.verticalFullExtent - offset) + 'L' + coords.rightInnerExtent + ' ' + (coords.verticalFullExtent - offset) + 'A' + (coords.rightLargeArcRadius - offset) + ' ' + (coords.rightLargeArcRadius - offset) + ' 0 0 1 ' + (coords.rightFullExtent + offset) + ' ' + coords.verticalRightInnerExtent + 'L' + (coords.rightFullExtent + offset) + ' ' + (coords.targetY + coords.rightSmallArcRadius) + 'A' + (coords.rightLargeArcRadius - offset) + ' ' + (coords.rightSmallArcRadius - offset) + ' 0 0 1 ' + coords.rightInnerExtent + ' ' + (coords.targetY + offset) + 'L' + coords.targetX + ' ' + (coords.targetY + offset) + 'Z';\n  }\n\n  return pathString;\n}\n\nfunction linkPath() {\n  var curvature = 0.5;\n\n  function path(d) {\n    if (d.link.circular) {\n      return createCircularClosedPathString(d.link);\n    } else {\n      var x0 = d.link.source.x1;\n      var x1 = d.link.target.x0;\n      var xi = interpolateNumber(x0, x1);\n      var x2 = xi(curvature);\n      var x3 = xi(1 - curvature);\n      var y0a = d.link.y0 - d.link.width / 2;\n      var y0b = d.link.y0 + d.link.width / 2;\n      var y1a = d.link.y1 - d.link.width / 2;\n      var y1b = d.link.y1 + d.link.width / 2;\n      return 'M' + x0 + ',' + y0a + 'C' + x2 + ',' + y0a + ' ' + x3 + ',' + y1a + ' ' + x1 + ',' + y1a + 'L' + x1 + ',' + y1b + 'C' + x3 + ',' + y1b + ' ' + x2 + ',' + y0b + ' ' + x0 + ',' + y0b + 'Z';\n    }\n  }\n\n  return path;\n}\n\nfunction nodeModel(d, n) {\n  var tc = tinycolor(n.color);\n  var zoneThicknessPad = c.nodePadAcross;\n  var zoneLengthPad = d.nodePad / 2;\n  n.dx = n.x1 - n.x0;\n  n.dy = n.y1 - n.y0;\n  var visibleThickness = n.dx;\n  var visibleLength = Math.max(0.5, n.dy);\n  var key = 'node_' + n.pointNumber; // If it's a group, it's mutable and should be unique\n\n  if (n.group) {\n    key = Lib.randstr();\n  } // for event data\n\n\n  n.trace = d.trace;\n  n.curveNumber = d.trace.index;\n  return {\n    index: n.pointNumber,\n    key: key,\n    partOfGroup: n.partOfGroup || false,\n    group: n.group,\n    traceId: d.key,\n    trace: d.trace,\n    node: n,\n    nodePad: d.nodePad,\n    nodeLineColor: d.nodeLineColor,\n    nodeLineWidth: d.nodeLineWidth,\n    textFont: d.textFont,\n    size: d.horizontal ? d.height : d.width,\n    visibleWidth: Math.ceil(visibleThickness),\n    visibleHeight: visibleLength,\n    zoneX: -zoneThicknessPad,\n    zoneY: -zoneLengthPad,\n    zoneWidth: visibleThickness + 2 * zoneThicknessPad,\n    zoneHeight: visibleLength + 2 * zoneLengthPad,\n    labelY: d.horizontal ? n.dy / 2 + 1 : n.dx / 2 + 1,\n    left: n.originalLayer === 1,\n    sizeAcross: d.width,\n    forceLayouts: d.forceLayouts,\n    horizontal: d.horizontal,\n    darkBackground: tc.getBrightness() <= 128,\n    tinyColorHue: Color.tinyRGB(tc),\n    tinyColorAlpha: tc.getAlpha(),\n    valueFormat: d.valueFormat,\n    valueSuffix: d.valueSuffix,\n    sankey: d.sankey,\n    graph: d.graph,\n    arrangement: d.arrangement,\n    uniqueNodeLabelPathId: [d.guid, d.key, key].join('_'),\n    interactionState: d.interactionState,\n    figure: d\n  };\n} // rendering snippets\n\n\nfunction updateNodePositions(sankeyNode) {\n  sankeyNode.attr('transform', function (d) {\n    return 'translate(' + d.node.x0.toFixed(3) + ', ' + d.node.y0.toFixed(3) + ')';\n  });\n}\n\nfunction updateNodeShapes(sankeyNode) {\n  sankeyNode.call(updateNodePositions);\n}\n\nfunction updateShapes(sankeyNode, sankeyLink) {\n  sankeyNode.call(updateNodeShapes);\n  sankeyLink.attr('d', linkPath());\n}\n\nfunction sizeNode(rect) {\n  rect.attr('width', function (d) {\n    return d.node.x1 - d.node.x0;\n  }).attr('height', function (d) {\n    return d.visibleHeight;\n  });\n}\n\nfunction salientEnough(d) {\n  return d.link.width > 1 || d.linkLineWidth > 0;\n}\n\nfunction sankeyTransform(d) {\n  var offset = 'translate(' + d.translateX + ',' + d.translateY + ')';\n  return offset + (d.horizontal ? 'matrix(1 0 0 1 0 0)' : 'matrix(0 1 1 0 0 0)');\n}\n\nfunction nodeCentering(d) {\n  return 'translate(' + (d.horizontal ? 0 : d.labelY) + ' ' + (d.horizontal ? d.labelY : 0) + ')';\n}\n\nfunction textGuidePath(d) {\n  return d3.svg.line()([[d.horizontal ? d.left ? -d.sizeAcross : d.visibleWidth + c.nodeTextOffsetHorizontal : c.nodeTextOffsetHorizontal, 0], [d.horizontal ? d.left ? -c.nodeTextOffsetHorizontal : d.sizeAcross : d.visibleHeight - c.nodeTextOffsetHorizontal, 0]]);\n}\n\nfunction sankeyInverseTransform(d) {\n  return d.horizontal ? 'matrix(1 0 0 1 0 0)' : 'matrix(0 1 1 0 0 0)';\n}\n\nfunction textFlip(d) {\n  return d.horizontal ? 'scale(1 1)' : 'scale(-1 1)';\n}\n\nfunction nodeTextColor(d) {\n  return d.darkBackground && !d.horizontal ? 'rgb(255,255,255)' : 'rgb(0,0,0)';\n}\n\nfunction nodeTextOffset(d) {\n  return d.horizontal && d.left ? '100%' : '0%';\n} // event handling\n\n\nfunction attachPointerEvents(selection, sankey, eventSet) {\n  selection.on('.basic', null) // remove any preexisting handlers\n  .on('mouseover.basic', function (d) {\n    if (!d.interactionState.dragInProgress && !d.partOfGroup) {\n      eventSet.hover(this, d, sankey);\n      d.interactionState.hovered = [this, d];\n    }\n  }).on('mousemove.basic', function (d) {\n    if (!d.interactionState.dragInProgress && !d.partOfGroup) {\n      eventSet.follow(this, d);\n      d.interactionState.hovered = [this, d];\n    }\n  }).on('mouseout.basic', function (d) {\n    if (!d.interactionState.dragInProgress && !d.partOfGroup) {\n      eventSet.unhover(this, d, sankey);\n      d.interactionState.hovered = false;\n    }\n  }).on('click.basic', function (d) {\n    if (d.interactionState.hovered) {\n      eventSet.unhover(this, d, sankey);\n      d.interactionState.hovered = false;\n    }\n\n    if (!d.interactionState.dragInProgress && !d.partOfGroup) {\n      eventSet.select(this, d, sankey);\n    }\n  });\n}\n\nfunction attachDragHandler(sankeyNode, sankeyLink, callbacks, gd) {\n  var dragBehavior = d3.behavior.drag().origin(function (d) {\n    return {\n      x: d.node.x0 + d.visibleWidth / 2,\n      y: d.node.y0 + d.visibleHeight / 2\n    };\n  }).on('dragstart', function (d) {\n    if (d.arrangement === 'fixed') return;\n    Lib.ensureSingle(gd._fullLayout._infolayer, 'g', 'dragcover', function (s) {\n      gd._fullLayout._dragCover = s;\n    });\n    Lib.raiseToTop(this);\n    d.interactionState.dragInProgress = d.node;\n    saveCurrentDragPosition(d.node);\n\n    if (d.interactionState.hovered) {\n      callbacks.nodeEvents.unhover.apply(0, d.interactionState.hovered);\n      d.interactionState.hovered = false;\n    }\n\n    if (d.arrangement === 'snap') {\n      var forceKey = d.traceId + '|' + d.key;\n\n      if (d.forceLayouts[forceKey]) {\n        d.forceLayouts[forceKey].alpha(1);\n      } else {\n        // make a forceLayout if needed\n        attachForce(sankeyNode, forceKey, d, gd);\n      }\n\n      startForce(sankeyNode, sankeyLink, d, forceKey, gd);\n    }\n  }).on('drag', function (d) {\n    if (d.arrangement === 'fixed') return;\n    var x = d3.event.x;\n    var y = d3.event.y;\n\n    if (d.arrangement === 'snap') {\n      d.node.x0 = x - d.visibleWidth / 2;\n      d.node.x1 = x + d.visibleWidth / 2;\n      d.node.y0 = y - d.visibleHeight / 2;\n      d.node.y1 = y + d.visibleHeight / 2;\n    } else {\n      if (d.arrangement === 'freeform') {\n        d.node.x0 = x - d.visibleWidth / 2;\n        d.node.x1 = x + d.visibleWidth / 2;\n      }\n\n      y = Math.max(0, Math.min(d.size - d.visibleHeight / 2, y));\n      d.node.y0 = y - d.visibleHeight / 2;\n      d.node.y1 = y + d.visibleHeight / 2;\n    }\n\n    saveCurrentDragPosition(d.node);\n\n    if (d.arrangement !== 'snap') {\n      d.sankey.update(d.graph);\n      updateShapes(sankeyNode.filter(sameLayer(d)), sankeyLink);\n    }\n  }).on('dragend', function (d) {\n    if (d.arrangement === 'fixed') return;\n    d.interactionState.dragInProgress = false;\n\n    for (var i = 0; i < d.node.childrenNodes.length; i++) {\n      d.node.childrenNodes[i].x = d.node.x;\n      d.node.childrenNodes[i].y = d.node.y;\n    }\n\n    if (d.arrangement !== 'snap') persistFinalNodePositions(d, gd);\n  });\n  sankeyNode.on('.drag', null) // remove possible previous handlers\n  .call(dragBehavior);\n}\n\nfunction attachForce(sankeyNode, forceKey, d, gd) {\n  // Attach force to nodes in the same column (same x coordinate)\n  switchToForceFormat(d.graph.nodes);\n  var nodes = d.graph.nodes.filter(function (n) {\n    return n.originalX === d.node.originalX;\n  }) // Filter out children\n  .filter(function (n) {\n    return !n.partOfGroup;\n  });\n  d.forceLayouts[forceKey] = d3Force.forceSimulation(nodes).alphaDecay(0).force('collide', d3Force.forceCollide().radius(function (n) {\n    return n.dy / 2 + d.nodePad / 2;\n  }).strength(1).iterations(c.forceIterations)).force('constrain', snappingForce(sankeyNode, forceKey, nodes, d, gd)).stop();\n}\n\nfunction startForce(sankeyNode, sankeyLink, d, forceKey, gd) {\n  window.requestAnimationFrame(function faster() {\n    var i;\n\n    for (i = 0; i < c.forceTicksPerFrame; i++) {\n      d.forceLayouts[forceKey].tick();\n    }\n\n    var nodes = d.graph.nodes;\n    switchToSankeyFormat(nodes);\n    d.sankey.update(d.graph);\n    updateShapes(sankeyNode.filter(sameLayer(d)), sankeyLink);\n\n    if (d.forceLayouts[forceKey].alpha() > 0) {\n      window.requestAnimationFrame(faster);\n    } else {\n      // Make sure the final x position is equal to its original value\n      // because the force simulation will have numerical error\n      var x = d.node.originalX;\n      d.node.x0 = x - d.visibleWidth / 2;\n      d.node.x1 = x + d.visibleWidth / 2;\n      persistFinalNodePositions(d, gd);\n    }\n  });\n}\n\nfunction snappingForce(sankeyNode, forceKey, nodes, d) {\n  return function _snappingForce() {\n    var maxVelocity = 0;\n\n    for (var i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n\n      if (n === d.interactionState.dragInProgress) {\n        // constrain node position to the dragging pointer\n        n.x = n.lastDraggedX;\n        n.y = n.lastDraggedY;\n      } else {\n        n.vx = (n.originalX - n.x) / c.forceTicksPerFrame; // snap to layer\n\n        n.y = Math.min(d.size - n.dy / 2, Math.max(n.dy / 2, n.y)); // constrain to extent\n      }\n\n      maxVelocity = Math.max(maxVelocity, Math.abs(n.vx), Math.abs(n.vy));\n    }\n\n    if (!d.interactionState.dragInProgress && maxVelocity < 0.1 && d.forceLayouts[forceKey].alpha() > 0) {\n      d.forceLayouts[forceKey].alpha(0); // This will stop the animation loop\n    }\n  };\n} // basic data utilities\n\n\nfunction persistFinalNodePositions(d, gd) {\n  var x = [];\n  var y = [];\n\n  for (var i = 0; i < d.graph.nodes.length; i++) {\n    var nodeX = (d.graph.nodes[i].x0 + d.graph.nodes[i].x1) / 2;\n    var nodeY = (d.graph.nodes[i].y0 + d.graph.nodes[i].y1) / 2;\n    x.push(nodeX / d.figure.width);\n    y.push(nodeY / d.figure.height);\n  }\n\n  Registry.call('_guiRestyle', gd, {\n    'node.x': [x],\n    'node.y': [y]\n  }, d.trace.index).then(function () {\n    if (gd._fullLayout._dragCover) gd._fullLayout._dragCover.remove();\n  });\n}\n\nfunction persistOriginalPlace(nodes) {\n  var distinctLayerPositions = [];\n  var i;\n\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].originalX = (nodes[i].x0 + nodes[i].x1) / 2;\n    nodes[i].originalY = (nodes[i].y0 + nodes[i].y1) / 2;\n\n    if (distinctLayerPositions.indexOf(nodes[i].originalX) === -1) {\n      distinctLayerPositions.push(nodes[i].originalX);\n    }\n  }\n\n  distinctLayerPositions.sort(function (a, b) {\n    return a - b;\n  });\n\n  for (i = 0; i < nodes.length; i++) {\n    nodes[i].originalLayerIndex = distinctLayerPositions.indexOf(nodes[i].originalX);\n    nodes[i].originalLayer = nodes[i].originalLayerIndex / (distinctLayerPositions.length - 1);\n  }\n}\n\nfunction saveCurrentDragPosition(d) {\n  d.lastDraggedX = d.x0 + d.dx / 2;\n  d.lastDraggedY = d.y0 + d.dy / 2;\n}\n\nfunction sameLayer(d) {\n  return function (n) {\n    return n.node.originalX === d.node.originalX;\n  };\n}\n\nfunction switchToForceFormat(nodes) {\n  // force uses x, y as centers\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].y = (nodes[i].y0 + nodes[i].y1) / 2;\n    nodes[i].x = (nodes[i].x0 + nodes[i].x1) / 2;\n  }\n}\n\nfunction switchToSankeyFormat(nodes) {\n  // sankey uses x0, x1, y0, y1\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].y0 = nodes[i].y - nodes[i].dy / 2;\n    nodes[i].y1 = nodes[i].y0 + nodes[i].dy;\n    nodes[i].x0 = nodes[i].x - nodes[i].dx / 2;\n    nodes[i].x1 = nodes[i].x0 + nodes[i].dx;\n  }\n} // scene graph\n\n\nmodule.exports = function (gd, svg, calcData, layout, callbacks) {\n  // To prevent animation on first render\n  var firstRender = false;\n  Lib.ensureSingle(gd._fullLayout._infolayer, 'g', 'first-render', function () {\n    firstRender = true;\n  }); // To prevent animation on dragging\n\n  var dragcover = gd._fullLayout._dragCover;\n  var styledData = calcData.filter(function (d) {\n    return unwrap(d).trace.visible;\n  }).map(sankeyModel.bind(null, layout));\n  var sankey = svg.selectAll('.' + c.cn.sankey).data(styledData, keyFun);\n  sankey.exit().remove();\n  sankey.enter().append('g').classed(c.cn.sankey, true).style('box-sizing', 'content-box').style('position', 'absolute').style('left', 0).style('shape-rendering', 'geometricPrecision').style('pointer-events', 'auto').attr('transform', sankeyTransform);\n  sankey.each(function (d, i) {\n    gd._fullData[i]._sankey = d; // Create dragbox if missing\n\n    var dragboxClassName = 'bgsankey-' + d.trace.uid + '-' + i;\n    Lib.ensureSingle(gd._fullLayout._draggers, 'rect', dragboxClassName);\n    gd._fullData[i]._bgRect = d3.select('.' + dragboxClassName); // Style dragbox\n\n    gd._fullData[i]._bgRect.style('pointer-events', 'all').attr('width', d.width).attr('height', d.height).attr('x', d.translateX).attr('y', d.translateY).classed('bgsankey', true).style({\n      fill: 'transparent',\n      'stroke-width': 0\n    });\n  });\n  sankey.transition().ease(c.ease).duration(c.duration).attr('transform', sankeyTransform);\n  var sankeyLinks = sankey.selectAll('.' + c.cn.sankeyLinks).data(repeat, keyFun);\n  sankeyLinks.enter().append('g').classed(c.cn.sankeyLinks, true).style('fill', 'none');\n  var sankeyLink = sankeyLinks.selectAll('.' + c.cn.sankeyLink).data(function (d) {\n    var links = d.graph.links;\n    return links.filter(function (l) {\n      return l.value;\n    }).map(linkModel.bind(null, d));\n  }, keyFun);\n  sankeyLink.enter().append('path').classed(c.cn.sankeyLink, true).call(attachPointerEvents, sankey, callbacks.linkEvents);\n  sankeyLink.style('stroke', function (d) {\n    return salientEnough(d) ? Color.tinyRGB(tinycolor(d.linkLineColor)) : d.tinyColorHue;\n  }).style('stroke-opacity', function (d) {\n    return salientEnough(d) ? Color.opacity(d.linkLineColor) : d.tinyColorAlpha;\n  }).style('fill', function (d) {\n    return d.tinyColorHue;\n  }).style('fill-opacity', function (d) {\n    return d.tinyColorAlpha;\n  }).style('stroke-width', function (d) {\n    return salientEnough(d) ? d.linkLineWidth : 1;\n  }).attr('d', linkPath());\n  sankeyLink.style('opacity', function () {\n    return gd._context.staticPlot || firstRender || dragcover ? 1 : 0;\n  }).transition().ease(c.ease).duration(c.duration).style('opacity', 1);\n  sankeyLink.exit().transition().ease(c.ease).duration(c.duration).style('opacity', 0).remove();\n  var sankeyNodeSet = sankey.selectAll('.' + c.cn.sankeyNodeSet).data(repeat, keyFun);\n  sankeyNodeSet.enter().append('g').classed(c.cn.sankeyNodeSet, true);\n  sankeyNodeSet.style('cursor', function (d) {\n    switch (d.arrangement) {\n      case 'fixed':\n        return 'default';\n\n      case 'perpendicular':\n        return 'ns-resize';\n\n      default:\n        return 'move';\n    }\n  });\n  var sankeyNode = sankeyNodeSet.selectAll('.' + c.cn.sankeyNode).data(function (d) {\n    var nodes = d.graph.nodes;\n    persistOriginalPlace(nodes);\n    return nodes.map(nodeModel.bind(null, d));\n  }, keyFun);\n  sankeyNode.enter().append('g').classed(c.cn.sankeyNode, true).call(updateNodePositions).style('opacity', function (n) {\n    return (gd._context.staticPlot || firstRender) && !n.partOfGroup ? 1 : 0;\n  });\n  sankeyNode.call(attachPointerEvents, sankey, callbacks.nodeEvents).call(attachDragHandler, sankeyLink, callbacks, gd); // has to be here as it binds sankeyLink\n\n  sankeyNode.transition().ease(c.ease).duration(c.duration).call(updateNodePositions).style('opacity', function (n) {\n    return n.partOfGroup ? 0 : 1;\n  });\n  sankeyNode.exit().transition().ease(c.ease).duration(c.duration).style('opacity', 0).remove();\n  var nodeRect = sankeyNode.selectAll('.' + c.cn.nodeRect).data(repeat);\n  nodeRect.enter().append('rect').classed(c.cn.nodeRect, true).call(sizeNode);\n  nodeRect.style('stroke-width', function (d) {\n    return d.nodeLineWidth;\n  }).style('stroke', function (d) {\n    return Color.tinyRGB(tinycolor(d.nodeLineColor));\n  }).style('stroke-opacity', function (d) {\n    return Color.opacity(d.nodeLineColor);\n  }).style('fill', function (d) {\n    return d.tinyColorHue;\n  }).style('fill-opacity', function (d) {\n    return d.tinyColorAlpha;\n  });\n  nodeRect.transition().ease(c.ease).duration(c.duration).call(sizeNode);\n  var nodeCapture = sankeyNode.selectAll('.' + c.cn.nodeCapture).data(repeat);\n  nodeCapture.enter().append('rect').classed(c.cn.nodeCapture, true).style('fill-opacity', 0);\n  nodeCapture.attr('x', function (d) {\n    return d.zoneX;\n  }).attr('y', function (d) {\n    return d.zoneY;\n  }).attr('width', function (d) {\n    return d.zoneWidth;\n  }).attr('height', function (d) {\n    return d.zoneHeight;\n  });\n  var nodeCentered = sankeyNode.selectAll('.' + c.cn.nodeCentered).data(repeat);\n  nodeCentered.enter().append('g').classed(c.cn.nodeCentered, true).attr('transform', nodeCentering);\n  nodeCentered.transition().ease(c.ease).duration(c.duration).attr('transform', nodeCentering);\n  var nodeLabelGuide = nodeCentered.selectAll('.' + c.cn.nodeLabelGuide).data(repeat);\n  nodeLabelGuide.enter().append('path').classed(c.cn.nodeLabelGuide, true).attr('id', function (d) {\n    return d.uniqueNodeLabelPathId;\n  }).attr('d', textGuidePath).attr('transform', sankeyInverseTransform);\n  nodeLabelGuide.transition().ease(c.ease).duration(c.duration).attr('d', textGuidePath).attr('transform', sankeyInverseTransform);\n  var nodeLabel = nodeCentered.selectAll('.' + c.cn.nodeLabel).data(repeat);\n  nodeLabel.enter().append('text').classed(c.cn.nodeLabel, true).attr('transform', textFlip).style('user-select', 'none').style('cursor', 'default').style('fill', 'black');\n  nodeLabel.style('text-shadow', function (d) {\n    return d.horizontal ? '-1px 1px 1px #fff, 1px 1px 1px #fff, 1px -1px 1px #fff, -1px -1px 1px #fff' : 'none';\n  }).each(function (d) {\n    Drawing.font(nodeLabel, d.textFont);\n  });\n  nodeLabel.transition().ease(c.ease).duration(c.duration).attr('transform', textFlip);\n  var nodeLabelTextPath = nodeLabel.selectAll('.' + c.cn.nodeLabelTextPath).data(repeat);\n  nodeLabelTextPath.enter().append('textPath').classed(c.cn.nodeLabelTextPath, true).attr('alignment-baseline', 'middle').attr('xlink:href', function (d) {\n    return '#' + d.uniqueNodeLabelPathId;\n  }).attr('startOffset', nodeTextOffset).style('fill', nodeTextColor);\n  nodeLabelTextPath.text(function (d) {\n    return d.horizontal || d.node.dy > 5 ? d.node.label : '';\n  }).attr('text-anchor', function (d) {\n    return d.horizontal && d.left ? 'end' : 'start';\n  });\n  nodeLabelTextPath.transition().ease(c.ease).duration(c.duration).attr('startOffset', nodeTextOffset).style('fill', nodeTextColor);\n};","map":null,"metadata":{},"sourceType":"script"}