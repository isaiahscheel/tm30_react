{"ast":null,"code":"'use strict';\n\nconst rgba = require('color-normalize');\n\nconst getBounds = require('array-bounds');\n\nconst extend = require('object-assign');\n\nconst glslify = require('glslify');\n\nconst pick = require('pick-by-alias');\n\nconst flatten = require('flatten-vertex-data');\n\nconst triangulate = require('earcut');\n\nconst normalize = require('array-normalize');\n\nconst _require = require('to-float32'),\n      float32 = _require.float32,\n      fract32 = _require.fract32;\n\nconst WeakMap = require('es6-weak-map');\n\nconst parseRect = require('parse-rect');\n\nmodule.exports = Line2D;\n/** @constructor */\n\nfunction Line2D(regl, options) {\n  if (!(this instanceof Line2D)) return new Line2D(regl, options);\n\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n  }\n\n  if (options.length) options.positions = options;\n  regl = options.regl;\n\n  if (!regl.hasExtension('ANGLE_instanced_arrays')) {\n    throw Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n  } // persistent variables\n\n\n  this.gl = regl._gl;\n  this.regl = regl; // list of options for lines\n\n  this.passes = []; // cached shaders instance\n\n  this.shaders = Line2D.shaders.has(regl) ? Line2D.shaders.get(regl) : Line2D.shaders.set(regl, Line2D.createShaders(regl)).get(regl); // init defaults\n\n  this.update(options);\n}\n\nLine2D.dashMult = 2;\nLine2D.maxPatternLength = 256;\nLine2D.precisionThreshold = 3e6;\nLine2D.maxPoints = 1e4;\nLine2D.maxLines = 2048; // cache of created draw calls per-regl instance\n\nLine2D.shaders = new WeakMap(); // create static shaders once\n\nLine2D.createShaders = function (regl) {\n  let offsetBuffer = regl.buffer({\n    usage: 'static',\n    type: 'float',\n    data: [0, 1, 0, 0, 1, 1, 1, 0]\n  });\n  let shaderOptions = {\n    primitive: 'triangle strip',\n    instances: regl.prop('count'),\n    count: 4,\n    offset: 0,\n    uniforms: {\n      miterMode: (ctx, prop) => prop.join === 'round' ? 2 : 1,\n      miterLimit: regl.prop('miterLimit'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      thickness: regl.prop('thickness'),\n      dashPattern: regl.prop('dashTexture'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      dashSize: regl.prop('dashLength'),\n      viewport: (c, p) => [p.viewport.x, p.viewport.y, c.viewportWidth, c.viewportHeight],\n      depth: regl.prop('depth')\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 0],\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    depth: {\n      enable: (c, p) => {\n        return !p.overlay;\n      }\n    },\n    stencil: {\n      enable: false\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport') // simplified rectangular line shader\n\n  };\n  let drawRectLine = regl(extend({\n    vert: glslify('./rect-vert.glsl'),\n    frag: glslify('./rect-frag.glsl'),\n    attributes: {\n      // if point is at the end of segment\n      lineEnd: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 0\n      },\n      // if point is at the top of segment\n      lineTop: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 4\n      },\n      // beginning of line coordinate\n      aCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      // end of line coordinate\n      bCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      aCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      bCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      color: {\n        buffer: regl.prop('colorBuffer'),\n        stride: 4,\n        offset: 0,\n        divisor: 1\n      }\n    }\n  }, shaderOptions)); // create regl draw\n\n  let drawMiterLine;\n\n  try {\n    drawMiterLine = regl(extend({\n      // culling removes polygon creasing\n      cull: {\n        enable: true,\n        face: 'back'\n      },\n      vert: glslify('./miter-vert.glsl'),\n      frag: glslify('./miter-frag.glsl'),\n      attributes: {\n        // is line end\n        lineEnd: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 0\n        },\n        // is line top\n        lineTop: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 4\n        },\n        // left color\n        aColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 0,\n          divisor: 1\n        },\n        // right color\n        bColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 4,\n          divisor: 1\n        },\n        prevCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 0,\n          divisor: 1\n        },\n        aCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 8,\n          divisor: 1\n        },\n        bCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 16,\n          divisor: 1\n        },\n        nextCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 24,\n          divisor: 1\n        }\n      }\n    }, shaderOptions));\n  } catch (e) {\n    // IE/bad Webkit fallback\n    drawMiterLine = drawRectLine;\n  } // fill shader\n\n\n  let drawFill = regl({\n    primitive: 'triangle',\n    elements: (ctx, prop) => prop.triangles,\n    offset: 0,\n    vert: glslify('./fill-vert.glsl'),\n    frag: glslify('./fill-frag.glsl'),\n    uniforms: {\n      scale: regl.prop('scale'),\n      color: regl.prop('fill'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      viewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]\n    },\n    attributes: {\n      position: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8\n      },\n      positionFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8\n      }\n    },\n    blend: shaderOptions.blend,\n    depth: {\n      enable: false\n    },\n    scissor: shaderOptions.scissor,\n    stencil: shaderOptions.stencil,\n    viewport: shaderOptions.viewport\n  });\n  return {\n    fill: drawFill,\n    rect: drawRectLine,\n    miter: drawMiterLine\n  };\n}; // used to for new lines instances\n\n\nLine2D.defaults = {\n  dashes: null,\n  join: 'miter',\n  miterLimit: 1,\n  thickness: 10,\n  cap: 'square',\n  color: 'black',\n  opacity: 1,\n  overlay: false,\n  viewport: null,\n  range: null,\n  close: false,\n  fill: null\n};\n\nLine2D.prototype.render = function (...args) {\n  if (args.length) {\n    this.update(...args);\n  }\n\n  this.draw();\n};\n\nLine2D.prototype.draw = function (...args) {\n  // render multiple polylines via regl batch\n  (args.length ? args : this.passes).forEach((s, i) => {\n    // render array pass as a list of passes\n    if (s && Array.isArray(s)) return this.draw(...s);\n    if (typeof s === 'number') s = this.passes[s];\n    if (!(s && s.count > 1 && s.opacity)) return;\n\n    this.regl._refresh();\n\n    if (s.fill && s.triangles && s.triangles.length > 2) {\n      this.shaders.fill(s);\n    }\n\n    if (!s.thickness) return; // high scale is only available for rect mode with precision\n\n    if (s.scale[0] * s.viewport.width > Line2D.precisionThreshold || s.scale[1] * s.viewport.height > Line2D.precisionThreshold) {\n      this.shaders.rect(s);\n    } // thin this.passes or too many points are rendered as simplified rect shader\n    else if (s.join === 'rect' || !s.join && (s.thickness <= 2 || s.count >= Line2D.maxPoints)) {\n        this.shaders.rect(s);\n      } else {\n        this.shaders.miter(s);\n      }\n  });\n  return this;\n};\n\nLine2D.prototype.update = function (options) {\n  if (!options) return;\n\n  if (options.length != null) {\n    if (typeof options[0] === 'number') options = [{\n      positions: options\n    }];\n  } // make options a batch\n  else if (!Array.isArray(options)) options = [options];\n\n  let regl = this.regl,\n      gl = this.gl; // process per-line settings\n\n  options.forEach((o, i) => {\n    let state = this.passes[i];\n    if (o === undefined) return; // null-argument removes pass\n\n    if (o === null) {\n      this.passes[i] = null;\n      return;\n    }\n\n    if (typeof o[0] === 'number') o = {\n      positions: o // handle aliases\n\n    };\n    o = pick(o, {\n      positions: 'positions points data coords',\n      thickness: 'thickness lineWidth lineWidths line-width linewidth width stroke-width strokewidth strokeWidth',\n      join: 'lineJoin linejoin join type mode',\n      miterLimit: 'miterlimit miterLimit',\n      dashes: 'dash dashes dasharray dash-array dashArray',\n      color: 'color colour stroke colors colours stroke-color strokeColor',\n      fill: 'fill fill-color fillColor',\n      opacity: 'alpha opacity',\n      overlay: 'overlay crease overlap intersect',\n      close: 'closed close closed-path closePath',\n      range: 'range dataBox',\n      viewport: 'viewport viewBox',\n      hole: 'holes hole hollow'\n    }); // init state\n\n    if (!state) {\n      this.passes[i] = state = {\n        id: i,\n        scale: null,\n        scaleFract: null,\n        translate: null,\n        translateFract: null,\n        count: 0,\n        hole: [],\n        depth: 0,\n        dashLength: 1,\n        dashTexture: regl.texture({\n          channels: 1,\n          data: new Uint8Array([255]),\n          width: 1,\n          height: 1,\n          mag: 'linear',\n          min: 'linear'\n        }),\n        colorBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'uint8',\n          data: new Uint8Array()\n        }),\n        positionBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        }),\n        positionFractBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        })\n      };\n      o = extend({}, Line2D.defaults, o);\n    }\n\n    if (o.thickness != null) state.thickness = parseFloat(o.thickness);\n    if (o.opacity != null) state.opacity = parseFloat(o.opacity);\n    if (o.miterLimit != null) state.miterLimit = parseFloat(o.miterLimit);\n\n    if (o.overlay != null) {\n      state.overlay = !!o.overlay;\n\n      if (i < Line2D.maxLines) {\n        state.depth = 2 * (Line2D.maxLines - 1 - i % Line2D.maxLines) / Line2D.maxLines - 1.;\n      }\n    }\n\n    if (o.join != null) state.join = o.join;\n    if (o.hole != null) state.hole = o.hole;\n    if (o.fill != null) state.fill = !o.fill ? null : rgba(o.fill, 'uint8');\n    if (o.viewport != null) state.viewport = parseRect(o.viewport);\n\n    if (!state.viewport) {\n      state.viewport = parseRect([gl.drawingBufferWidth, gl.drawingBufferHeight]);\n    }\n\n    if (o.close != null) state.close = o.close; // reset positions\n\n    if (o.positions === null) o.positions = [];\n\n    if (o.positions) {\n      let positions, count; // if positions are an object with x/y\n\n      if (o.positions.x && o.positions.y) {\n        let xPos = o.positions.x;\n        let yPos = o.positions.y;\n        count = state.count = Math.max(xPos.length, yPos.length);\n        positions = new Float64Array(count * 2);\n\n        for (let i = 0; i < count; i++) {\n          positions[i * 2] = xPos[i];\n          positions[i * 2 + 1] = yPos[i];\n        }\n      } else {\n        positions = flatten(o.positions, 'float64');\n        count = state.count = Math.floor(positions.length / 2);\n      }\n\n      let bounds = state.bounds = getBounds(positions, 2); // create fill positions\n      // FIXME: fill positions can be set only along with positions\n\n      if (state.fill) {\n        let pos = []; // filter bad vertices and remap triangles to ensure shape\n\n        let ids = {};\n        let lastId = 0;\n\n        for (let i = 0, ptr = 0, l = state.count; i < l; i++) {\n          let x = positions[i * 2];\n          let y = positions[i * 2 + 1];\n\n          if (isNaN(x) || isNaN(y) || x == null || y == null) {\n            x = positions[lastId * 2];\n            y = positions[lastId * 2 + 1];\n            ids[i] = lastId;\n          } else {\n            lastId = i;\n          }\n\n          pos[ptr++] = x;\n          pos[ptr++] = y;\n        }\n\n        let triangles = triangulate(pos, state.hole || []);\n\n        for (let i = 0, l = triangles.length; i < l; i++) {\n          if (ids[triangles[i]] != null) triangles[i] = ids[triangles[i]];\n        }\n\n        state.triangles = triangles;\n      } // update position buffers\n\n\n      let npos = new Float64Array(positions);\n      normalize(npos, 2, bounds);\n      let positionData = new Float64Array(count * 2 + 6); // rotate first segment join\n\n      if (state.close) {\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[0] = npos[count * 2 - 4];\n          positionData[1] = npos[count * 2 - 3];\n        } else {\n          positionData[0] = npos[count * 2 - 2];\n          positionData[1] = npos[count * 2 - 1];\n        }\n      } else {\n        positionData[0] = npos[0];\n        positionData[1] = npos[1];\n      }\n\n      positionData.set(npos, 2); // add last segment\n\n      if (state.close) {\n        // ignore coinciding start/end\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[count * 2 + 2] = npos[2];\n          positionData[count * 2 + 3] = npos[3];\n          state.count -= 1;\n        } else {\n          positionData[count * 2 + 2] = npos[0];\n          positionData[count * 2 + 3] = npos[1];\n          positionData[count * 2 + 4] = npos[2];\n          positionData[count * 2 + 5] = npos[3];\n        }\n      } // add stub\n      else {\n          positionData[count * 2 + 2] = npos[count * 2 - 2];\n          positionData[count * 2 + 3] = npos[count * 2 - 1];\n          positionData[count * 2 + 4] = npos[count * 2 - 2];\n          positionData[count * 2 + 5] = npos[count * 2 - 1];\n        }\n\n      state.positionBuffer(float32(positionData));\n      state.positionFractBuffer(fract32(positionData));\n    }\n\n    if (o.range) {\n      state.range = o.range;\n    } else if (!state.range) {\n      state.range = state.bounds;\n    }\n\n    if ((o.range || o.positions) && state.count) {\n      let bounds = state.bounds;\n      let boundsW = bounds[2] - bounds[0],\n          boundsH = bounds[3] - bounds[1];\n      let rangeW = state.range[2] - state.range[0],\n          rangeH = state.range[3] - state.range[1];\n      state.scale = [boundsW / rangeW, boundsH / rangeH];\n      state.translate = [-state.range[0] / rangeW + bounds[0] / rangeW || 0, -state.range[1] / rangeH + bounds[1] / rangeH || 0];\n      state.scaleFract = fract32(state.scale);\n      state.translateFract = fract32(state.translate);\n    }\n\n    if (o.dashes) {\n      let dashLength = 0.,\n          dashData;\n\n      if (!o.dashes || o.dashes.length < 2) {\n        dashLength = 1.;\n        dashData = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]);\n      } else {\n        dashLength = 0.;\n\n        for (let i = 0; i < o.dashes.length; ++i) {\n          dashLength += o.dashes[i];\n        }\n\n        dashData = new Uint8Array(dashLength * Line2D.dashMult);\n        let ptr = 0;\n        let fillColor = 255; // repeat texture two times to provide smooth 0-step\n\n        for (let k = 0; k < 2; k++) {\n          for (let i = 0; i < o.dashes.length; ++i) {\n            for (let j = 0, l = o.dashes[i] * Line2D.dashMult * .5; j < l; ++j) {\n              dashData[ptr++] = fillColor;\n            }\n\n            fillColor ^= 255;\n          }\n        }\n      }\n\n      state.dashLength = dashLength;\n      state.dashTexture({\n        channels: 1,\n        data: dashData,\n        width: dashData.length,\n        height: 1,\n        mag: 'linear',\n        min: 'linear'\n      }, 0, 0);\n    }\n\n    if (o.color) {\n      let count = state.count;\n      let colors = o.color;\n      if (!colors) colors = 'transparent';\n      let colorData = new Uint8Array(count * 4 + 4); // convert colors to typed arrays\n\n      if (!Array.isArray(colors) || typeof colors[0] === 'number') {\n        let c = rgba(colors, 'uint8');\n\n        for (let i = 0; i < count + 1; i++) {\n          colorData.set(c, i * 4);\n        }\n      } else {\n        for (let i = 0; i < count; i++) {\n          let c = rgba(colors[i], 'uint8');\n          colorData.set(c, i * 4);\n        }\n\n        colorData.set(rgba(colors[0], 'uint8'), count * 4);\n      }\n\n      state.colorBuffer({\n        usage: 'dynamic',\n        type: 'uint8',\n        data: colorData\n      });\n    }\n  }); // remove unmentioned passes\n\n  if (options.length < this.passes.length) {\n    for (let i = options.length; i < this.passes.length; i++) {\n      let pass = this.passes[i];\n      if (!pass) continue;\n      pass.colorBuffer.destroy();\n      pass.positionBuffer.destroy();\n      pass.dashTexture.destroy();\n    }\n\n    this.passes.length = options.length;\n  } // remove null items\n\n\n  let passes = [];\n\n  for (let i = 0; i < this.passes.length; i++) {\n    if (this.passes[i] !== null) passes.push(this.passes[i]);\n  }\n\n  this.passes = passes;\n  return this;\n};\n\nLine2D.prototype.destroy = function () {\n  this.passes.forEach(pass => {\n    pass.colorBuffer.destroy();\n    pass.positionBuffer.destroy();\n    pass.dashTexture.destroy();\n  });\n  this.passes.length = 0;\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}