{"ast":null,"code":"'use strict';\n\nconst getBounds = require('array-bounds');\n\nconst rgba = require('color-normalize');\n\nconst updateDiff = require('update-diff');\n\nconst pick = require('pick-by-alias');\n\nconst extend = require('object-assign');\n\nconst flatten = require('flatten-vertex-data');\n\nconst _require = require('to-float32'),\n      float32 = _require.float32,\n      fract32 = _require.fract32;\n\nmodule.exports = Error2D;\nconst WEIGHTS = [//direction, lineWidth shift, capSize shift\n// x-error bar\n[1, 0, 0, 1, 0, 0], [1, 0, 0, -1, 0, 0], [-1, 0, 0, -1, 0, 0], [-1, 0, 0, -1, 0, 0], [-1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0], // x-error right cap\n[1, 0, -1, 0, 0, 1], [1, 0, -1, 0, 0, -1], [1, 0, 1, 0, 0, -1], [1, 0, 1, 0, 0, -1], [1, 0, 1, 0, 0, 1], [1, 0, -1, 0, 0, 1], // x-error left cap\n[-1, 0, -1, 0, 0, 1], [-1, 0, -1, 0, 0, -1], [-1, 0, 1, 0, 0, -1], [-1, 0, 1, 0, 0, -1], [-1, 0, 1, 0, 0, 1], [-1, 0, -1, 0, 0, 1], // y-error bar\n[0, 1, 1, 0, 0, 0], [0, 1, -1, 0, 0, 0], [0, -1, -1, 0, 0, 0], [0, -1, -1, 0, 0, 0], [0, 1, 1, 0, 0, 0], [0, -1, 1, 0, 0, 0], // y-error top cap\n[0, 1, 0, -1, 1, 0], [0, 1, 0, -1, -1, 0], [0, 1, 0, 1, -1, 0], [0, 1, 0, 1, 1, 0], [0, 1, 0, -1, 1, 0], [0, 1, 0, 1, -1, 0], // y-error bottom cap\n[0, -1, 0, -1, 1, 0], [0, -1, 0, -1, -1, 0], [0, -1, 0, 1, -1, 0], [0, -1, 0, 1, 1, 0], [0, -1, 0, -1, 1, 0], [0, -1, 0, 1, -1, 0]];\n\nfunction Error2D(regl, options) {\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n  }\n\n  if (options.length) options.positions = options;\n  regl = options.regl;\n\n  if (!regl.hasExtension('ANGLE_instanced_arrays')) {\n    throw Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n  } // persistent variables\n\n\n  let gl = regl._gl,\n      drawErrors,\n      positionBuffer,\n      positionFractBuffer,\n      colorBuffer,\n      errorBuffer,\n      meshBuffer,\n      defaults = {\n    color: 'black',\n    capSize: 5,\n    lineWidth: 1,\n    opacity: 1,\n    viewport: null,\n    range: null,\n    offset: 0,\n    count: 0,\n    bounds: null,\n    positions: [],\n    errors: []\n  },\n      groups = []; //color per-point\n\n  colorBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'uint8',\n    data: new Uint8Array(0)\n  }); //xy-position per-point\n\n  positionBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'float',\n    data: new Uint8Array(0)\n  }); //xy-position float32-fraction\n\n  positionFractBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'float',\n    data: new Uint8Array(0)\n  }); //4 errors per-point\n\n  errorBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'float',\n    data: new Uint8Array(0)\n  }); //error bar mesh\n\n  meshBuffer = regl.buffer({\n    usage: 'static',\n    type: 'float',\n    data: WEIGHTS\n  });\n  update(options); //drawing method\n\n  drawErrors = regl({\n    vert: \"\\n\\t\\tprecision highp float;\\n\\n\\t\\tattribute vec2 position, positionFract;\\n\\t\\tattribute vec4 error;\\n\\t\\tattribute vec4 color;\\n\\n\\t\\tattribute vec2 direction, lineOffset, capOffset;\\n\\n\\t\\tuniform vec4 viewport;\\n\\t\\tuniform float lineWidth, capSize;\\n\\t\\tuniform vec2 scale, scaleFract, translate, translateFract;\\n\\n\\t\\tvarying vec4 fragColor;\\n\\n\\t\\tvoid main() {\\n\\t\\t\\tfragColor = color / 255.;\\n\\n\\t\\t\\tvec2 pixelOffset = lineWidth * lineOffset + (capSize + lineWidth) * capOffset;\\n\\n\\t\\t\\tvec2 dxy = -step(.5, direction.xy) * error.xz + step(direction.xy, vec2(-.5)) * error.yw;\\n\\n\\t\\t\\tvec2 position = position + dxy;\\n\\n\\t\\t\\tvec2 pos = (position + translate) * scale\\n\\t\\t\\t\\t+ (positionFract + translateFract) * scale\\n\\t\\t\\t\\t+ (position + translate) * scaleFract\\n\\t\\t\\t\\t+ (positionFract + translateFract) * scaleFract;\\n\\n\\t\\t\\tpos += pixelOffset / viewport.zw;\\n\\n\\t\\t\\tgl_Position = vec4(pos * 2. - 1., 0, 1);\\n\\t\\t}\\n\\t\\t\",\n    frag: \"\\n\\t\\tprecision highp float;\\n\\n\\t\\tvarying vec4 fragColor;\\n\\n\\t\\tuniform float opacity;\\n\\n\\t\\tvoid main() {\\n\\t\\t\\tgl_FragColor = fragColor;\\n\\t\\t\\tgl_FragColor.a *= opacity;\\n\\t\\t}\\n\\t\\t\",\n    uniforms: {\n      range: regl.prop('range'),\n      lineWidth: regl.prop('lineWidth'),\n      capSize: regl.prop('capSize'),\n      opacity: regl.prop('opacity'),\n      scale: regl.prop('scale'),\n      translate: regl.prop('translate'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      viewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]\n    },\n    attributes: {\n      //dynamic attributes\n      color: {\n        buffer: colorBuffer,\n        offset: (ctx, prop) => prop.offset * 4,\n        divisor: 1\n      },\n      position: {\n        buffer: positionBuffer,\n        offset: (ctx, prop) => prop.offset * 8,\n        divisor: 1\n      },\n      positionFract: {\n        buffer: positionFractBuffer,\n        offset: (ctx, prop) => prop.offset * 8,\n        divisor: 1\n      },\n      error: {\n        buffer: errorBuffer,\n        offset: (ctx, prop) => prop.offset * 16,\n        divisor: 1\n      },\n      //static attributes\n      direction: {\n        buffer: meshBuffer,\n        stride: 24,\n        offset: 0\n      },\n      lineOffset: {\n        buffer: meshBuffer,\n        stride: 24,\n        offset: 8\n      },\n      capOffset: {\n        buffer: meshBuffer,\n        stride: 24,\n        offset: 16\n      }\n    },\n    primitive: 'triangles',\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 0],\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    depth: {\n      enable: false\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport'),\n    stencil: false,\n    instances: regl.prop('count'),\n    count: WEIGHTS.length\n  }); //expose API\n\n  extend(error2d, {\n    update: update,\n    draw: draw,\n    destroy: destroy,\n    regl: regl,\n    gl: gl,\n    canvas: gl.canvas,\n    groups: groups\n  });\n  return error2d;\n\n  function error2d(opts) {\n    //update\n    if (opts) {\n      update(opts);\n    } //destroy\n    else if (opts === null) {\n        destroy();\n      }\n\n    draw();\n  } //main draw method\n\n\n  function draw(options) {\n    if (typeof options === 'number') return drawGroup(options); //make options a batch\n\n    if (options && !Array.isArray(options)) options = [options];\n\n    regl._refresh(); //render multiple polylines via regl batch\n\n\n    groups.forEach((s, i) => {\n      if (!s) return;\n\n      if (options) {\n        if (!options[i]) s.draw = false;else s.draw = true;\n      } //ignore draw flag for one pass\n\n\n      if (!s.draw) {\n        s.draw = true;\n        return;\n      }\n\n      drawGroup(i);\n    });\n  } //draw single error group by id\n\n\n  function drawGroup(s) {\n    if (typeof s === 'number') s = groups[s];\n    if (s == null) return;\n    if (!(s && s.count && s.color && s.opacity && s.positions && s.positions.length > 1)) return;\n    s.scaleRatio = [s.scale[0] * s.viewport.width, s.scale[1] * s.viewport.height];\n    drawErrors(s);\n    if (s.after) s.after(s);\n  }\n\n  function update(options) {\n    if (!options) return; //direct points argument\n\n    if (options.length != null) {\n      if (typeof options[0] === 'number') options = [{\n        positions: options\n      }];\n    } //make options a batch\n    else if (!Array.isArray(options)) options = [options]; //global count of points\n\n\n    let pointCount = 0,\n        errorCount = 0;\n    error2d.groups = groups = options.map((options, i) => {\n      let group = groups[i];\n      if (!options) return group;else if (typeof options === 'function') options = {\n        after: options\n      };else if (typeof options[0] === 'number') options = {\n        positions: options //copy options to avoid mutation & handle aliases\n\n      };\n      options = pick(options, {\n        color: 'color colors fill',\n        capSize: 'capSize cap capsize cap-size',\n        lineWidth: 'lineWidth line-width width line thickness',\n        opacity: 'opacity alpha',\n        range: 'range dataBox',\n        viewport: 'viewport viewBox',\n        errors: 'errors error',\n        positions: 'positions position data points'\n      });\n\n      if (!group) {\n        groups[i] = group = {\n          id: i,\n          scale: null,\n          translate: null,\n          scaleFract: null,\n          translateFract: null,\n          draw: true\n        };\n        options = extend({}, defaults, options);\n      }\n\n      updateDiff(group, options, [{\n        lineWidth: v => +v * .5,\n        capSize: v => +v * .5,\n        opacity: parseFloat,\n        errors: errors => {\n          errors = flatten(errors);\n          errorCount += errors.length;\n          return errors;\n        },\n        positions: (positions, state) => {\n          positions = flatten(positions, 'float64');\n          state.count = Math.floor(positions.length / 2);\n          state.bounds = getBounds(positions, 2);\n          state.offset = pointCount;\n          pointCount += state.count;\n          return positions;\n        }\n      }, {\n        color: (colors, state) => {\n          let count = state.count;\n          if (!colors) colors = 'transparent'; // 'black' or [0,0,0,0] case\n\n          if (!Array.isArray(colors) || typeof colors[0] === 'number') {\n            let color = colors;\n            colors = Array(count);\n\n            for (let i = 0; i < count; i++) {\n              colors[i] = color;\n            }\n          }\n\n          if (colors.length < count) throw Error('Not enough colors');\n          let colorData = new Uint8Array(count * 4); //convert colors to float arrays\n\n          for (let i = 0; i < count; i++) {\n            let c = rgba(colors[i], 'uint8');\n            colorData.set(c, i * 4);\n          }\n\n          return colorData;\n        },\n        range: (range, state, options) => {\n          let bounds = state.bounds;\n          if (!range) range = bounds;\n          state.scale = [1 / (range[2] - range[0]), 1 / (range[3] - range[1])];\n          state.translate = [-range[0], -range[1]];\n          state.scaleFract = fract32(state.scale);\n          state.translateFract = fract32(state.translate);\n          return range;\n        },\n        viewport: vp => {\n          let viewport;\n\n          if (Array.isArray(vp)) {\n            viewport = {\n              x: vp[0],\n              y: vp[1],\n              width: vp[2] - vp[0],\n              height: vp[3] - vp[1]\n            };\n          } else if (vp) {\n            viewport = {\n              x: vp.x || vp.left || 0,\n              y: vp.y || vp.top || 0\n            };\n            if (vp.right) viewport.width = vp.right - viewport.x;else viewport.width = vp.w || vp.width || 0;\n            if (vp.bottom) viewport.height = vp.bottom - viewport.y;else viewport.height = vp.h || vp.height || 0;\n          } else {\n            viewport = {\n              x: 0,\n              y: 0,\n              width: gl.drawingBufferWidth,\n              height: gl.drawingBufferHeight\n            };\n          }\n\n          return viewport;\n        }\n      }]);\n      return group;\n    });\n\n    if (pointCount || errorCount) {\n      let len = groups.reduce((acc, group, i) => {\n        return acc + (group ? group.count : 0);\n      }, 0);\n      let positionData = new Float64Array(len * 2);\n      let colorData = new Uint8Array(len * 4);\n      let errorData = new Float32Array(len * 4);\n      groups.forEach((group, i) => {\n        if (!group) return;\n        let positions = group.positions,\n            count = group.count,\n            offset = group.offset,\n            color = group.color,\n            errors = group.errors;\n        if (!count) return;\n        colorData.set(color, offset * 4);\n        errorData.set(errors, offset * 4);\n        positionData.set(positions, offset * 2);\n      });\n      positionBuffer(float32(positionData));\n      positionFractBuffer(fract32(positionData));\n      colorBuffer(colorData);\n      errorBuffer(errorData);\n    }\n  }\n\n  function destroy() {\n    positionBuffer.destroy();\n    positionFractBuffer.destroy();\n    colorBuffer.destroy();\n    errorBuffer.destroy();\n    meshBuffer.destroy();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}