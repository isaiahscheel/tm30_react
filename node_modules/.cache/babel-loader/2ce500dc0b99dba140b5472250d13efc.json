{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar constants = require('./constants'); // Calculate all the marching indices, for ALL levels at once.\n// since we want to be exhaustive we'll check for contour crossings\n// at every intersection, rather than just following a path\n// TODO: shorten the inner loop to only the relevant levels\n\n\nmodule.exports = function makeCrossings(pathinfo) {\n  var z = pathinfo[0].z;\n  var m = z.length;\n  var n = z[0].length; // we already made sure z isn't ragged in interp2d\n\n  var twoWide = m === 2 || n === 2;\n  var xi;\n  var yi;\n  var startIndices;\n  var ystartIndices;\n  var label;\n  var corners;\n  var mi;\n  var pi;\n  var i;\n\n  for (yi = 0; yi < m - 1; yi++) {\n    ystartIndices = [];\n    if (yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);\n    if (yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);\n\n    for (xi = 0; xi < n - 1; xi++) {\n      startIndices = ystartIndices.slice();\n      if (xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);\n      if (xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);\n      label = xi + ',' + yi;\n      corners = [[z[yi][xi], z[yi][xi + 1]], [z[yi + 1][xi], z[yi + 1][xi + 1]]];\n\n      for (i = 0; i < pathinfo.length; i++) {\n        pi = pathinfo[i];\n        mi = getMarchingIndex(pi.level, corners);\n        if (!mi) continue;\n        pi.crossings[label] = mi;\n\n        if (startIndices.indexOf(mi) !== -1) {\n          pi.starts.push([xi, yi]);\n\n          if (twoWide && startIndices.indexOf(mi, startIndices.indexOf(mi) + 1) !== -1) {\n            // the same square has starts from opposite sides\n            // it's not possible to have starts on opposite edges\n            // of a corner, only a start and an end...\n            // but if the array is only two points wide (either way)\n            // you can have starts on opposite sides.\n            pi.starts.push([xi, yi]);\n          }\n        }\n      }\n    }\n  }\n}; // modified marching squares algorithm,\n// so we disambiguate the saddle points from the start\n// and we ignore the cases with no crossings\n// the index I'm using is based on:\n// http://en.wikipedia.org/wiki/Marching_squares\n// except that the saddles bifurcate and I represent them\n// as the decimal combination of the two appropriate\n// non-saddle indices\n\n\nfunction getMarchingIndex(val, corners) {\n  var mi = (corners[0][0] > val ? 0 : 1) + (corners[0][1] > val ? 0 : 2) + (corners[1][1] > val ? 0 : 4) + (corners[1][0] > val ? 0 : 8);\n\n  if (mi === 5 || mi === 10) {\n    var avg = (corners[0][0] + corners[0][1] + corners[1][0] + corners[1][1]) / 4; // two peaks with a big valley\n\n    if (val > avg) return mi === 5 ? 713 : 1114; // two valleys with a big ridge\n\n    return mi === 5 ? 104 : 208;\n  }\n\n  return mi === 15 ? 0 : mi;\n}","map":null,"metadata":{},"sourceType":"script"}