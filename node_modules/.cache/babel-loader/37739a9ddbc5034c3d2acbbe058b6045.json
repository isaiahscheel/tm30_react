{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar nestedProperty = require('./nested_property');\n\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/; // bitmask for deciding what's updated. Sometimes the name needs to be updated,\n// sometimes the value needs to be updated, and sometimes both do. This is just\n// a simple way to track what's updated such that it's a simple OR operation to\n// assimilate new updates.\n//\n// The only exception is the UNSET bit that tracks when we need to explicitly\n// unset and remove the property. This concrn arises because of the special\n// way in which nestedProperty handles null/undefined. When you specify `null`,\n// it prunes any unused items in the tree. I ran into some issues with it getting\n// null vs undefined confused, so UNSET is just a bit that forces the property\n// update to send `null`, removing the property explicitly rather than setting\n// it to undefined.\n\nvar NONE = 0;\nvar NAME = 1;\nvar VALUE = 2;\nvar BOTH = 3;\nvar UNSET = 4;\n\nmodule.exports = function keyedContainer(baseObj, path, keyName, valueName) {\n  keyName = keyName || 'name';\n  valueName = valueName || 'value';\n  var i, arr, baseProp;\n  var changeTypes = {};\n\n  if (path && path.length) {\n    baseProp = nestedProperty(baseObj, path);\n    arr = baseProp.get();\n  } else {\n    arr = baseObj;\n  }\n\n  path = path || ''; // Construct an index:\n\n  var indexLookup = {};\n\n  if (arr) {\n    for (i = 0; i < arr.length; i++) {\n      indexLookup[arr[i][keyName]] = i;\n    }\n  }\n\n  var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);\n  var obj = {\n    set: function (name, value) {\n      var changeType = value === null ? UNSET : NONE; // create the base array if necessary\n\n      if (!arr) {\n        if (!baseProp || changeType === UNSET) return;\n        arr = [];\n        baseProp.set(arr);\n      }\n\n      var idx = indexLookup[name];\n\n      if (idx === undefined) {\n        if (changeType === UNSET) return;\n        changeType = changeType | BOTH;\n        idx = arr.length;\n        indexLookup[name] = idx;\n      } else if (value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {\n        changeType = changeType | VALUE;\n      }\n\n      var newValue = arr[idx] = arr[idx] || {};\n      newValue[keyName] = name;\n\n      if (isSimpleValueProp) {\n        newValue[valueName] = value;\n      } else {\n        nestedProperty(newValue, valueName).set(value);\n      } // If it's not an unset, force that bit to be unset. This is all related to the fact\n      // that undefined and null are a bit specially implemented in nestedProperties.\n\n\n      if (value !== null) {\n        changeType = changeType & ~UNSET;\n      }\n\n      changeTypes[idx] = changeTypes[idx] | changeType;\n      return obj;\n    },\n    get: function (name) {\n      if (!arr) return;\n      var idx = indexLookup[name];\n\n      if (idx === undefined) {\n        return undefined;\n      } else if (isSimpleValueProp) {\n        return arr[idx][valueName];\n      } else {\n        return nestedProperty(arr[idx], valueName).get();\n      }\n    },\n    rename: function (name, newName) {\n      var idx = indexLookup[name];\n      if (idx === undefined) return obj;\n      changeTypes[idx] = changeTypes[idx] | NAME;\n      indexLookup[newName] = idx;\n      delete indexLookup[name];\n      arr[idx][keyName] = newName;\n      return obj;\n    },\n    remove: function (name) {\n      var idx = indexLookup[name];\n      if (idx === undefined) return obj;\n      var object = arr[idx];\n\n      if (Object.keys(object).length > 2) {\n        // This object contains more than just the key/value, so unset\n        // the value without modifying the entry otherwise:\n        changeTypes[idx] = changeTypes[idx] | VALUE;\n        return obj.set(name, null);\n      }\n\n      if (isSimpleValueProp) {\n        for (i = idx; i < arr.length; i++) {\n          changeTypes[i] = changeTypes[i] | BOTH;\n        }\n\n        for (i = idx; i < arr.length; i++) {\n          indexLookup[arr[i][keyName]]--;\n        }\n\n        arr.splice(idx, 1);\n        delete indexLookup[name];\n      } else {\n        // Perform this update *strictly* so we can check whether the result's\n        // been pruned. If so, it's a removal. If not, it's a value unset only.\n        nestedProperty(object, valueName).set(null); // Now check if the top level nested property has any keys left. If so,\n        // the object still has values so we only want to unset the key. If not,\n        // the entire object can be removed since there's no other data.\n        // var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);\n\n        changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;\n      }\n\n      return obj;\n    },\n    constructUpdate: function () {\n      var astr, idx;\n      var update = {};\n      var changed = Object.keys(changeTypes);\n\n      for (var i = 0; i < changed.length; i++) {\n        idx = changed[i];\n        astr = path + '[' + idx + ']';\n\n        if (arr[idx]) {\n          if (changeTypes[idx] & NAME) {\n            update[astr + '.' + keyName] = arr[idx][keyName];\n          }\n\n          if (changeTypes[idx] & VALUE) {\n            if (isSimpleValueProp) {\n              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : arr[idx][valueName];\n            } else {\n              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : nestedProperty(arr[idx], valueName).get();\n            }\n          }\n        } else {\n          update[astr] = null;\n        }\n      }\n\n      return update;\n    }\n  };\n  return obj;\n};","map":null,"metadata":{},"sourceType":"script"}