{"ast":null,"code":"\"use strict\";\n\nmodule.exports = planarDual;\n\nvar compareAngle = require(\"compare-angle\");\n\nfunction planarDual(cells, positions) {\n  var numVertices = positions.length | 0;\n  var numEdges = cells.length;\n  var adj = [new Array(numVertices), new Array(numVertices)];\n\n  for (var i = 0; i < numVertices; ++i) {\n    adj[0][i] = [];\n    adj[1][i] = [];\n  }\n\n  for (var i = 0; i < numEdges; ++i) {\n    var c = cells[i];\n    adj[0][c[0]].push(c);\n    adj[1][c[1]].push(c);\n  }\n\n  var cycles = []; //Add isolated vertices as trivial case\n\n  for (var i = 0; i < numVertices; ++i) {\n    if (adj[0][i].length + adj[1][i].length === 0) {\n      cycles.push([i]);\n    }\n  } //Remove a half edge\n\n\n  function cut(c, i) {\n    var a = adj[i][c[i]];\n    a.splice(a.indexOf(c), 1);\n  } //Find next vertex and cut edge\n\n\n  function next(a, b, noCut) {\n    var nextCell, nextVertex, nextDir;\n\n    for (var i = 0; i < 2; ++i) {\n      if (adj[i][b].length > 0) {\n        nextCell = adj[i][b][0];\n        nextDir = i;\n        break;\n      }\n    }\n\n    nextVertex = nextCell[nextDir ^ 1];\n\n    for (var dir = 0; dir < 2; ++dir) {\n      var nbhd = adj[dir][b];\n\n      for (var k = 0; k < nbhd.length; ++k) {\n        var e = nbhd[k];\n        var p = e[dir ^ 1];\n        var cmp = compareAngle(positions[a], positions[b], positions[nextVertex], positions[p]);\n\n        if (cmp > 0) {\n          nextCell = e;\n          nextVertex = p;\n          nextDir = dir;\n        }\n      }\n    }\n\n    if (noCut) {\n      return nextVertex;\n    }\n\n    if (nextCell) {\n      cut(nextCell, nextDir);\n    }\n\n    return nextVertex;\n  }\n\n  function extractCycle(v, dir) {\n    var e0 = adj[dir][v][0];\n    var cycle = [v];\n    cut(e0, dir);\n    var u = e0[dir ^ 1];\n    var d0 = dir;\n\n    while (true) {\n      while (u !== v) {\n        cycle.push(u);\n        u = next(cycle[cycle.length - 2], u, false);\n      }\n\n      if (adj[0][v].length + adj[1][v].length === 0) {\n        break;\n      }\n\n      var a = cycle[cycle.length - 1];\n      var b = v;\n      var c = cycle[1];\n      var d = next(a, b, true);\n\n      if (compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {\n        break;\n      }\n\n      cycle.push(v);\n      u = next(a, b);\n    }\n\n    return cycle;\n  }\n\n  function shouldGlue(pcycle, ncycle) {\n    return ncycle[1] === ncycle[ncycle.length - 1];\n  }\n\n  for (var i = 0; i < numVertices; ++i) {\n    for (var j = 0; j < 2; ++j) {\n      var pcycle = [];\n\n      while (adj[j][i].length > 0) {\n        var ni = adj[0][i].length;\n        var ncycle = extractCycle(i, j);\n\n        if (shouldGlue(pcycle, ncycle)) {\n          //Glue together trivial cycles\n          pcycle.push.apply(pcycle, ncycle);\n        } else {\n          if (pcycle.length > 0) {\n            cycles.push(pcycle);\n          }\n\n          pcycle = ncycle;\n        }\n      }\n\n      if (pcycle.length > 0) {\n        cycles.push(pcycle);\n      }\n    }\n  } //Combine paths and loops together\n\n\n  return cycles;\n}","map":null,"metadata":{},"sourceType":"script"}