{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing'); // constants for dynamic jitter (ie less jitter for sparser points)\n\n\nvar JITTERCOUNT = 5; // points either side of this to include\n\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(boxLayer, cdbox, 'trace boxes').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace; // whisker width\n\n    t.wdPos = t.bdPos * trace.whiskerwidth;\n\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n\n    var posAxis, valAxis;\n\n    if (trace.orientation === 'h') {\n      posAxis = ya;\n      valAxis = xa;\n    } else {\n      posAxis = xa;\n      valAxis = ya;\n    }\n\n    plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t);\n    plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n    plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t);\n  });\n}\n\nfunction plotBoxAndWhiskers(sel, axes, trace, t) {\n  var posAxis = axes.pos;\n  var valAxis = axes.val;\n  var bPos = t.bPos;\n  var wdPos = t.wdPos || 0;\n  var bPosPxOffset = t.bPosPxOffset || 0;\n  var whiskerWidth = trace.whiskerwidth || 0;\n  var notched = trace.notched || false;\n  var nw = notched ? 1 - 2 * trace.notchwidth : 1; // to support for one-sided box\n\n  var bdPos0;\n  var bdPos1;\n\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n\n  var paths = sel.selectAll('path.box').data(trace.type !== 'violin' || trace.box.visible ? Lib.identity : []);\n  paths.enter().append('path').style('vector-effect', 'non-scaling-stroke').attr('class', 'box');\n  paths.exit().remove();\n  paths.each(function (d) {\n    if (d.empty) return 'M0,0Z';\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var posc = posAxis.l2p(lcenter) + bPosPxOffset;\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var posw0 = posAxis.l2p(lcenter - wdPos) + bPosPxOffset;\n    var posw1 = posAxis.l2p(lcenter + wdPos) + bPosPxOffset;\n    var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;\n    var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;\n    var q1 = valAxis.c2p(d.q1, true);\n    var q3 = valAxis.c2p(d.q3, true); // make sure median isn't identical to either of the\n    // quartiles, so we can see it\n\n    var m = Lib.constrain(valAxis.c2p(d.med, true), Math.min(q1, q3) + 1, Math.max(q1, q3) - 1); // for compatibility with box, violin, and candlestick\n    // perhaps we should put this into cd0.t instead so it's more explicit,\n    // but what we have now is:\n    // - box always has d.lf, but boxpoints can be anything\n    // - violin has d.lf and should always use it (boxpoints is undefined)\n    // - candlestick has only min/max\n\n    var useExtremes = d.lf === undefined || trace.boxpoints === false;\n    var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n    var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n    var ln = valAxis.c2p(d.ln, true);\n    var un = valAxis.c2p(d.un, true);\n\n    if (trace.orientation === 'h') {\n      d3.select(this).attr('d', 'M' + m + ',' + posm0 + 'V' + posm1 + // median line\n      'M' + q1 + ',' + pos0 + 'V' + pos1 + ( // left edge\n      notched ? 'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 : '') + // top notched edge\n      'H' + q3 + // end of the top edge\n      'V' + pos0 + ( // right edge\n      notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') + // bottom notched edge\n      'Z' + // end of the box\n      'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + ( // whiskers\n      whiskerWidth === 0 ? '' : // whisker caps\n      'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1));\n    } else {\n      d3.select(this).attr('d', 'M' + posm0 + ',' + m + 'H' + posm1 + // median line\n      'M' + pos0 + ',' + q1 + 'H' + pos1 + ( // top of the box\n      notched ? 'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un : '') + // notched right edge\n      'V' + q3 + // end of the right edge\n      'H' + pos0 + ( // bottom of the box\n      notched ? 'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln : '') + // notched left edge\n      'Z' + // end of the box\n      'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + ( // whiskers\n      whiskerWidth === 0 ? '' : // whisker caps\n      'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1));\n    }\n  });\n}\n\nfunction plotPoints(sel, axes, trace, t) {\n  var xa = axes.x;\n  var ya = axes.y;\n  var bdPos = t.bdPos;\n  var bPos = t.bPos; // to support violin points\n\n  var mode = trace.boxpoints || trace.points; // repeatable pseudo-random number generator\n\n  Lib.seedPseudoRandom(); // since box plot points get an extra level of nesting, each\n  // box needs the trace styling info\n\n  var fn = function (d) {\n    d.forEach(function (v) {\n      v.t = t;\n      v.trace = trace;\n    });\n    return d;\n  };\n\n  var gPoints = sel.selectAll('g.points').data(mode ? fn : []);\n  gPoints.enter().append('g').attr('class', 'points');\n  gPoints.exit().remove();\n  var paths = gPoints.selectAll('path').data(function (d) {\n    var i;\n    var pts = d.pts2; // normally use IQR, but if this is 0 or too small, use max-min\n\n    var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n    var minSpread = typicalSpread * 1e-9;\n    var spreadLimit = typicalSpread * JITTERSPREAD;\n    var jitterFactors = [];\n    var maxJitterFactor = 0;\n    var newJitter; // dynamic jitter\n\n    if (trace.jitter) {\n      if (typicalSpread === 0) {\n        // edge case of no spread at all: fall back to max jitter\n        maxJitterFactor = 1;\n        jitterFactors = new Array(pts.length);\n\n        for (i = 0; i < pts.length; i++) {\n          jitterFactors[i] = 1;\n        }\n      } else {\n        for (i = 0; i < pts.length; i++) {\n          var i0 = Math.max(0, i - JITTERCOUNT);\n          var pmin = pts[i0].v;\n          var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n          var pmax = pts[i1].v;\n\n          if (mode !== 'all') {\n            if (pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);else pmin = Math.max(pmin, d.uf);\n          }\n\n          var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n          jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n          jitterFactors.push(jitterFactor);\n          maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n        }\n      }\n\n      newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n    } // fills in 'x' and 'y' in calcdata 'pts' item\n\n\n    for (i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var v = pt.v;\n      var jitterOffset = trace.jitter ? newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5) : 0;\n      var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n\n      if (trace.orientation === 'h') {\n        pt.y = posPx;\n        pt.x = v;\n      } else {\n        pt.x = posPx;\n        pt.y = v;\n      } // tag suspected outliers\n\n\n      if (mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n        pt.so = true;\n      }\n    }\n\n    return pts;\n  });\n  paths.enter().append('path').classed('point', true);\n  paths.exit().remove();\n  paths.call(Drawing.translatePoints, xa, ya);\n}\n\nfunction plotBoxMean(sel, axes, trace, t) {\n  var posAxis = axes.pos;\n  var valAxis = axes.val;\n  var bPos = t.bPos;\n  var bPosPxOffset = t.bPosPxOffset || 0; // to support violin mean lines\n\n  var mode = trace.boxmean || (trace.meanline || {}).visible; // to support for one-sided box\n\n  var bdPos0;\n  var bdPos1;\n\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n\n  var paths = sel.selectAll('path.mean').data(trace.type === 'box' && trace.boxmean || trace.type === 'violin' && trace.box.visible && trace.meanline.visible ? Lib.identity : []);\n  paths.enter().append('path').attr('class', 'mean').style({\n    fill: 'none',\n    'vector-effect': 'non-scaling-stroke'\n  });\n  paths.exit().remove();\n  paths.each(function (d) {\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var posc = posAxis.l2p(lcenter) + bPosPxOffset;\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var m = valAxis.c2p(d.mean, true);\n    var sl = valAxis.c2p(d.mean - d.sd, true);\n    var sh = valAxis.c2p(d.mean + d.sd, true);\n\n    if (trace.orientation === 'h') {\n      d3.select(this).attr('d', 'M' + m + ',' + pos0 + 'V' + pos1 + (mode === 'sd' ? 'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' : ''));\n    } else {\n      d3.select(this).attr('d', 'M' + pos0 + ',' + m + 'H' + pos1 + (mode === 'sd' ? 'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' : ''));\n    }\n  });\n}\n\nmodule.exports = {\n  plot: plot,\n  plotBoxAndWhiskers: plotBoxAndWhiskers,\n  plotPoints: plotPoints,\n  plotBoxMean: plotBoxMean\n};","map":null,"metadata":{},"sourceType":"script"}