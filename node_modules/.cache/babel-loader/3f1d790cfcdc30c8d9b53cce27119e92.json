{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../lib');\n\nvar PlotSchema = require('../plot_api/plot_schema');\n\nvar Plots = require('../plots/plots');\n\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nexports.moduleType = 'transform';\nexports.name = 'groupby';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    role: 'info',\n    editType: 'calc',\n    description: ['Determines whether this group-by transform is enabled or disabled.'].join(' ')\n  },\n  groups: {\n    valType: 'data_array',\n    dflt: [],\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the groups in which the trace data will be split.', 'For example, with `x` set to *[1, 2, 3, 4]* and', '`groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*,', 'the groupby transform with split in one trace', 'with `x` [1, 3] and one trace with `x` [2, 4].'].join(' ')\n  },\n  nameformat: {\n    valType: 'string',\n    role: 'info',\n    editType: 'calc',\n    description: ['Pattern by which grouped traces are named. If only one trace is present,', 'defaults to the group name (`\"%{group}\"`), otherwise defaults to the group name', 'with trace name (`\"%{group} (%{trace})\"`). Available escape sequences are `%{group}`, which', 'inserts the group name, and `%{trace}`, which inserts the trace name. If grouping', 'GDP data by country when more than one trace is present, for example, the', 'default \"%{group} (%{trace})\" would return \"Monaco (GDP per capita)\".'].join(' ')\n  },\n  styles: {\n    _isLinkedToArray: 'style',\n    target: {\n      valType: 'string',\n      role: 'info',\n      editType: 'calc',\n      description: ['The group value which receives these styles.'].join(' ')\n    },\n    value: {\n      valType: 'any',\n      role: 'info',\n      dflt: {},\n      editType: 'calc',\n      description: ['Sets each group styles.', 'For example, with `groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*', 'and `styles` set to *[{target: \\'a\\', value: { marker: { color: \\'red\\' } }}]', 'marker points in group *\\'a\\'* will be drawn in red.'].join(' '),\n      _compareAsJSON: true\n    },\n    editType: 'calc'\n  },\n  editType: 'calc'\n};\n/**\n * Supply transform attributes defaults\n *\n * @param {object} transformIn\n *  object linked to trace.transforms[i] with 'type' set to exports.name\n * @param {object} traceOut\n *  the _fullData trace this transform applies to\n * @param {object} layout\n *  the plot's (not-so-full) layout\n * @param {object} traceIn\n *  the input data trace this transform applies to\n *\n * @return {object} transformOut\n *  copy of transformIn that contains attribute defaults\n */\n\nexports.supplyDefaults = function (transformIn, traceOut, layout) {\n  var i;\n  var transformOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n\n  var enabled = coerce('enabled');\n  if (!enabled) return transformOut;\n  coerce('groups');\n  coerce('nameformat', layout._dataLength > 1 ? '%{group} (%{trace})' : '%{group}');\n  var styleIn = transformIn.styles;\n  var styleOut = transformOut.styles = [];\n\n  if (styleIn) {\n    for (i = 0; i < styleIn.length; i++) {\n      var thisStyle = styleOut[i] = {};\n      Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'target');\n      var value = Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'value'); // so that you can edit value in place and have Plotly.react notice it, or\n      // rebuild it every time and have Plotly.react NOT think it changed:\n      // use _compareAsJSON to say we should diff the _JSON_value\n\n      if (Lib.isPlainObject(value)) thisStyle.value = Lib.extendDeep({}, value);else if (value) delete thisStyle.value;\n    }\n  }\n\n  return transformOut;\n};\n/**\n * Apply transform !!!\n *\n * @param {array} data\n *  array of transformed traces (is [fullTrace] upon first transform)\n *\n * @param {object} state\n *  state object which includes:\n *      - transform {object} full transform attributes\n *      - fullTrace {object} full trace object which is being transformed\n *      - fullData {array} full pre-transform(s) data array\n *      - layout {object} the plot's (not-so-full) layout\n *\n * @return {object} newData\n *  array of transformed traces\n */\n\n\nexports.transform = function (data, state) {\n  var newTraces, i, j;\n  var newData = [];\n\n  for (i = 0; i < data.length; i++) {\n    newTraces = transformOne(data[i], state);\n\n    for (j = 0; j < newTraces.length; j++) {\n      newData.push(newTraces[j]);\n    }\n  }\n\n  return newData;\n};\n\nfunction transformOne(trace, state) {\n  var i, j, k, attr, srcArray, groupName, newTrace, transforms, arrayLookup;\n  var groupNameObj;\n  var opts = state.transform;\n  var transformIndex = state.transformIndex;\n  var groups = trace.transforms[transformIndex].groups;\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n\n  if (!Array.isArray(groups) || groups.length === 0) {\n    return [trace];\n  }\n\n  var groupNames = Lib.filterUnique(groups);\n  var newData = new Array(groupNames.length);\n  var len = groups.length;\n  var arrayAttrs = PlotSchema.findArrayAttributes(trace);\n  var styles = opts.styles || [];\n  var styleLookup = {};\n\n  for (i = 0; i < styles.length; i++) {\n    styleLookup[styles[i].target] = styles[i].value;\n  }\n\n  if (opts.styles) {\n    groupNameObj = Lib.keyedContainer(opts, 'styles', 'target', 'value.name');\n  } // An index to map group name --> expanded trace index\n\n\n  var indexLookup = {};\n  var indexCnts = {};\n\n  for (i = 0; i < groupNames.length; i++) {\n    groupName = groupNames[i];\n    indexLookup[groupName] = i;\n    indexCnts[groupName] = 0; // Start with a deep extend that just copies array references.\n\n    newTrace = newData[i] = Lib.extendDeepNoArrays({}, trace);\n    newTrace._group = groupName;\n    newTrace.transforms[transformIndex]._indexToPoints = {};\n    var suppliedName = null;\n\n    if (groupNameObj) {\n      suppliedName = groupNameObj.get(groupName);\n    }\n\n    if (suppliedName || suppliedName === '') {\n      newTrace.name = suppliedName;\n    } else {\n      newTrace.name = Lib.templateString(opts.nameformat, {\n        trace: trace.name,\n        group: groupName\n      });\n    } // In order for groups to apply correctly to other transform data (e.g.\n    // a filter transform), we have to break the connection and clone the\n    // transforms so that each group writes grouped values into a different\n    // destination. This function does not break the array reference\n    // connection between the split transforms it creates. That's handled in\n    // initialize, which creates a new empty array for each arrayAttr.\n\n\n    transforms = newTrace.transforms;\n    newTrace.transforms = [];\n\n    for (j = 0; j < transforms.length; j++) {\n      newTrace.transforms[j] = Lib.extendDeepNoArrays({}, transforms[j]);\n    } // Initialize empty arrays for the arrayAttrs, to be split in the next step\n\n\n    for (j = 0; j < arrayAttrs.length; j++) {\n      Lib.nestedProperty(newTrace, arrayAttrs[j]).set([]);\n    }\n  } // For each array attribute including those nested inside this and other\n  // transforms (small note that we technically only need to do this for\n  // transforms that have not yet been applied):\n\n\n  for (k = 0; k < arrayAttrs.length; k++) {\n    attr = arrayAttrs[k]; // Cache all the arrays to which we'll push:\n\n    for (j = 0, arrayLookup = []; j < groupNames.length; j++) {\n      arrayLookup[j] = Lib.nestedProperty(newData[j], attr).get();\n    } // Get the input data:\n\n\n    srcArray = Lib.nestedProperty(trace, attr).get(); // Send each data point to the appropriate expanded trace:\n\n    for (j = 0; j < len; j++) {\n      // Map group data --> trace index --> array and push data onto it\n      arrayLookup[indexLookup[groups[j]]].push(srcArray[j]);\n    }\n  }\n\n  for (j = 0; j < len; j++) {\n    newTrace = newData[indexLookup[groups[j]]];\n    var indexToPoints = newTrace.transforms[transformIndex]._indexToPoints;\n    indexToPoints[indexCnts[groups[j]]] = originalPointsAccessor(j);\n    indexCnts[groups[j]]++;\n  }\n\n  for (i = 0; i < groupNames.length; i++) {\n    groupName = groupNames[i];\n    newTrace = newData[i];\n    Plots.clearExpandedTraceDefaultColors(newTrace); // there's no need to coerce styleLookup[groupName] here\n    // as another round of supplyDefaults is done on the transformed traces\n\n    newTrace = Lib.extendDeepNoArrays(newTrace, styleLookup[groupName] || {});\n  }\n\n  return newData;\n}","map":null,"metadata":{},"sourceType":"script"}