{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar handleTypeDefaults = require('./type_defaults');\n\nvar handleAxisDefaults = require('./axis_defaults');\n\nvar handleConstraintDefaults = require('./constraints').handleConstraintDefaults;\n\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\n\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar Registry = require('../../registry');\n\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n  if (Array.isArray(cont[k])) cont[k].push(item);else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  var ax2traces = {};\n  var xaMayHide = {};\n  var yaMayHide = {};\n  var xaMustDisplay = {};\n  var yaMustDisplay = {};\n  var yaMustNotReverse = {};\n  var yaMayReverse = {};\n  var axHasImage = {};\n  var outerTicks = {};\n  var noGrids = {};\n  var i, j; // look for axes in the data\n\n  for (i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n    var xaName;\n\n    if (trace.xaxis) {\n      xaName = id2name(trace.xaxis);\n      appendList(ax2traces, xaName, trace);\n    } else if (trace.xaxes) {\n      for (j = 0; j < trace.xaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n      }\n    }\n\n    var yaName;\n\n    if (trace.yaxis) {\n      yaName = id2name(trace.yaxis);\n      appendList(ax2traces, yaName, trace);\n    } else if (trace.yaxes) {\n      for (j = 0; j < trace.yaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n      }\n    } // logic for funnels\n\n\n    if (trace.type === 'funnel') {\n      if (trace.orientation === 'h') {\n        if (xaName) xaMayHide[xaName] = true;\n        if (yaName) yaMayReverse[yaName] = true;\n      } else {\n        if (yaName) yaMayHide[yaName] = true;\n      }\n    } else if (trace.type === 'image') {\n      if (yaName) axHasImage[yaName] = true;\n      if (xaName) axHasImage[xaName] = true;\n    } else {\n      if (yaName) {\n        yaMustDisplay[yaName] = true;\n        yaMustNotReverse[yaName] = true;\n      }\n\n      if (!traceIs(trace, 'carpet') || trace.type === 'carpet' && !trace._cheater) {\n        if (xaName) xaMustDisplay[xaName] = true;\n      }\n    } // Two things trigger axis visibility:\n    // 1. is not carpet\n    // 2. carpet that's not cheater\n    // The above check for definitely-not-cheater is not adequate. This\n    // second list tracks which axes *could* be a cheater so that the\n    // full condition triggering hiding is:\n    //   *could* be a cheater and *is not definitely visible*\n\n\n    if (trace.type === 'carpet' && trace._cheater) {\n      if (xaName) xaMayHide[xaName] = true;\n    } // check for default formatting tweaks\n\n\n    if (traceIs(trace, '2dMap')) {\n      outerTicks[xaName] = true;\n      outerTicks[yaName] = true;\n    }\n\n    if (traceIs(trace, 'oriented')) {\n      var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n      noGrids[positionAxis] = true;\n    }\n  }\n\n  var subplots = layoutOut._subplots;\n  var xIds = subplots.xaxis;\n  var yIds = subplots.yaxis;\n  var xNames = Lib.simpleMap(xIds, id2name);\n  var yNames = Lib.simpleMap(yIds, id2name);\n  var axNames = xNames.concat(yNames); // plot_bgcolor only makes sense if there's a (2D) plot!\n  // TODO: bgcolor for each subplot, to inherit from the main one\n\n  var plotBgColor = Color.background;\n\n  if (xIds.length && yIds.length) {\n    plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n  }\n\n  var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);\n  var axName, axLetter, axLayoutIn, axLayoutOut;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function coerce2(attr, dflt) {\n    return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function getCounterAxes(axLetter) {\n    return axLetter === 'x' ? yIds : xIds;\n  }\n\n  var counterAxes = {\n    x: getCounterAxes('x'),\n    y: getCounterAxes('y')\n  };\n  var allAxisIds = counterAxes.x.concat(counterAxes.y);\n\n  function getOverlayableAxes(axLetter, axName) {\n    var list = axLetter === 'x' ? xNames : yNames;\n    var out = [];\n\n    for (var j = 0; j < list.length; j++) {\n      var axName2 = list[j];\n\n      if (axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n        out.push(name2id(axName2));\n      }\n    }\n\n    return out;\n  } // first pass creates the containers, determines types, and handles most of the settings\n\n\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    var traces = ax2traces[axName] || [];\n    axLayoutOut._traceIndices = traces.map(function (t) {\n      return t._expandedIndex;\n    });\n    axLayoutOut._annIndices = [];\n    axLayoutOut._shapeIndices = [];\n    axLayoutOut._imgIndices = [];\n    axLayoutOut._subplotsWith = [];\n    axLayoutOut._counterAxes = []; // set up some private properties\n\n    axLayoutOut._name = axLayoutOut._attr = axName;\n    var id = axLayoutOut._id = name2id(axName);\n    var overlayableAxes = getOverlayableAxes(axLetter, axName);\n    var visibleDflt = axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName];\n    var reverseDflt = axLetter === 'y' && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);\n    var defaultOptions = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: traces,\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: visibleDflt,\n      reverseDflt: reverseDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[id]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n    var spikecolor = coerce2('spikecolor');\n    var spikethickness = coerce2('spikethickness');\n    var spikedash = coerce2('spikedash');\n    var spikemode = coerce2('spikemode');\n    var spikesnap = coerce2('spikesnap');\n    var showSpikes = coerce('showspikes', !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n    if (!showSpikes) {\n      delete axLayoutOut.spikecolor;\n      delete axLayoutOut.spikethickness;\n      delete axLayoutOut.spikedash;\n      delete axLayoutOut.spikemode;\n      delete axLayoutOut.spikesnap;\n    }\n\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: overlayableAxes,\n      grid: layoutOut.grid\n    });\n    coerce('title.standoff');\n    axLayoutOut._input = axLayoutIn;\n  } // quick second pass for range slider and selector defaults\n\n\n  var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n  var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n  for (i = 0; i < xNames.length; i++) {\n    axName = xNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n    if (axLayoutOut.type === 'date') {\n      rangeSelectorDefaults(axLayoutIn, axLayoutOut, layoutOut, yNames, axLayoutOut.calendar);\n    }\n\n    coerce('fixedrange');\n  }\n\n  for (i = 0; i < yNames.length; i++) {\n    axName = yNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n    var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n    coerce('fixedrange', fixedRangeDflt);\n  } // Finally, handle scale constraints and matching axes.\n  //\n  // We need to do this after all axes have coerced both `type`\n  // (so we link only axes of the same type) and\n  // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n  // sets of axes linked by `scaleanchor` along with the scaleratios compounded\n  // together, populated in handleConstraintDefaults\n\n\n  var constraintGroups = layoutOut._axisConstraintGroups = []; // similar to _axisConstraintGroups, but for matching axes\n\n  var matchGroups = layoutOut._axisMatchGroups = [];\n\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axLetter = axName.charAt(0);\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var scaleanchorDflt;\n\n    if (axLetter === 'y' && !axLayoutIn.hasOwnProperty('scaleanchor') && axHasImage[axName]) {\n      scaleanchorDflt = axLayoutOut.anchor;\n    } else {\n      scaleanchorDflt = undefined;\n    }\n\n    var constrainDflt;\n\n    if (!axLayoutIn.hasOwnProperty('constrain') && axHasImage[axName]) {\n      constrainDflt = 'domain';\n    } else {\n      constrainDflt = undefined;\n    }\n\n    handleConstraintDefaults(axLayoutIn, axLayoutOut, coerce, {\n      allAxisIds: allAxisIds,\n      layoutOut: layoutOut,\n      scaleanchorDflt: scaleanchorDflt,\n      constrainDflt: constrainDflt\n    });\n  }\n\n  for (i = 0; i < matchGroups.length; i++) {\n    var group = matchGroups[i];\n    var rng = null;\n    var autorange = null;\n    var axId; // find 'matching' range attrs\n\n    for (axId in group) {\n      axLayoutOut = layoutOut[id2name(axId)];\n\n      if (!axLayoutOut.matches) {\n        rng = axLayoutOut.range;\n        autorange = axLayoutOut.autorange;\n      }\n    } // if `ax.matches` values are reciprocal,\n    // pick values of first axis in group\n\n\n    if (rng === null || autorange === null) {\n      for (axId in group) {\n        axLayoutOut = layoutOut[id2name(axId)];\n        rng = axLayoutOut.range;\n        autorange = axLayoutOut.autorange;\n        break;\n      }\n    } // apply matching range attrs\n\n\n    for (axId in group) {\n      axLayoutOut = layoutOut[id2name(axId)];\n\n      if (axLayoutOut.matches) {\n        axLayoutOut.range = rng.slice();\n        axLayoutOut.autorange = autorange;\n      }\n\n      axLayoutOut._matchGroup = group;\n    } // remove matching axis from scaleanchor constraint groups (for now)\n\n\n    if (constraintGroups.length) {\n      for (axId in group) {\n        for (j = 0; j < constraintGroups.length; j++) {\n          var group2 = constraintGroups[j];\n\n          for (var axId2 in group2) {\n            if (axId === axId2) {\n              Lib.warn('Axis ' + axId2 + ' is set with both ' + 'a *scaleanchor* and *matches* constraint; ' + 'ignoring the scale constraint.');\n              delete group2[axId2];\n\n              if (Object.keys(group2).length < 2) {\n                constraintGroups.splice(j, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}