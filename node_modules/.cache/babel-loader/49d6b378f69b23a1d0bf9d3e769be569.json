{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n/* global PlotlyGeoAssets:false */\n\nvar mapboxgl = require('mapbox-gl');\n\nvar d3 = require('d3');\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../cartesian/axes');\n\nvar dragElement = require('../../components/dragelement');\n\nvar prepSelect = require('../cartesian/select').prepSelect;\n\nvar selectOnClick = require('../cartesian/select').selectOnClick;\n\nvar constants = require('./constants');\n\nvar createMapboxLayer = require('./layers');\n\nfunction Mapbox(gd, id) {\n  this.id = id;\n  this.gd = gd;\n  var fullLayout = gd._fullLayout;\n  var context = gd._context;\n  this.container = fullLayout._glcontainer.node();\n  this.isStatic = context.staticPlot; // unique id for this Mapbox instance\n\n  this.uid = fullLayout._uid + '-' + this.id; // create framework on instantiation for a smoother first plot call\n\n  this.div = null;\n  this.xaxis = null;\n  this.yaxis = null;\n  this.createFramework(fullLayout); // state variables used to infer how and what to update\n\n  this.map = null;\n  this.accessToken = null;\n  this.styleObj = null;\n  this.traceHash = {};\n  this.layerList = [];\n  this.belowLookup = {};\n}\n\nvar proto = Mapbox.prototype;\n\nproto.plot = function (calcData, fullLayout, promises) {\n  var self = this;\n  var opts = fullLayout[self.id]; // remove map and create a new map if access token has change\n\n  if (self.map && opts.accesstoken !== self.accessToken) {\n    self.map.remove();\n    self.map = null;\n    self.styleObj = null;\n    self.traceHash = [];\n    self.layerList = {};\n  }\n\n  var promise;\n\n  if (!self.map) {\n    promise = new Promise(function (resolve, reject) {\n      self.createMap(calcData, fullLayout, resolve, reject);\n    });\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      self.updateMap(calcData, fullLayout, resolve, reject);\n    });\n  }\n\n  promises.push(promise);\n};\n\nproto.createMap = function (calcData, fullLayout, resolve, reject) {\n  var self = this;\n  var opts = fullLayout[self.id]; // store style id and URL or object\n\n  var styleObj = self.styleObj = getStyleObj(opts.style); // store access token associated with this map\n\n  self.accessToken = opts.accesstoken; // create the map!\n\n  var map = self.map = new mapboxgl.Map({\n    container: self.div,\n    style: styleObj.style,\n    center: convertCenter(opts.center),\n    zoom: opts.zoom,\n    bearing: opts.bearing,\n    pitch: opts.pitch,\n    interactive: !self.isStatic,\n    preserveDrawingBuffer: self.isStatic,\n    doubleClickZoom: false,\n    boxZoom: false,\n    attributionControl: false\n  }).addControl(new mapboxgl.AttributionControl({\n    compact: true\n  })); // make sure canvas does not inherit left and top css\n\n  map._canvas.style.left = '0px';\n  map._canvas.style.top = '0px';\n  self.rejectOnError(reject);\n\n  if (!self.isStatic) {\n    self.initFx(calcData, fullLayout);\n  }\n\n  var promises = [];\n  promises.push(new Promise(function (resolve) {\n    map.once('load', resolve);\n  }));\n  promises = promises.concat(self.fetchMapData(calcData, fullLayout));\n  Promise.all(promises).then(function () {\n    self.fillBelowLookup(calcData, fullLayout);\n    self.updateData(calcData);\n    self.updateLayout(fullLayout);\n    self.resolveOnRender(resolve);\n  }).catch(reject);\n};\n\nproto.fetchMapData = function (calcData) {\n  var promises = [];\n\n  function fetch(url) {\n    return new Promise(function (resolve, reject) {\n      d3.json(url, function (err, d) {\n        if (err) {\n          delete PlotlyGeoAssets[url];\n          var msg = err.status === 404 ? 'GeoJSON at URL \"' + url + '\" does not exist.' : 'Unexpected error while fetching from ' + url;\n          return reject(new Error(msg));\n        }\n\n        PlotlyGeoAssets[url] = d;\n        resolve(d);\n      });\n    });\n  }\n\n  for (var i = 0; i < calcData.length; i++) {\n    var trace = calcData[i][0].trace;\n    var url = trace.geojson;\n\n    if (typeof url === 'string' && !PlotlyGeoAssets[url]) {\n      PlotlyGeoAssets[url] = 'pending';\n      promises.push(fetch(url));\n    }\n  }\n\n  return promises;\n};\n\nproto.updateMap = function (calcData, fullLayout, resolve, reject) {\n  var self = this;\n  var map = self.map;\n  var opts = fullLayout[this.id];\n  self.rejectOnError(reject);\n  var promises = [];\n  var styleObj = getStyleObj(opts.style);\n\n  if (self.styleObj.id !== styleObj.id) {\n    self.styleObj = styleObj;\n    map.setStyle(styleObj.style); // need to rebuild trace layers on reload\n    // to avoid 'lost event' errors\n\n    self.traceHash = {};\n    promises.push(new Promise(function (resolve) {\n      map.once('styledata', resolve);\n    }));\n  }\n\n  promises = promises.concat(self.fetchMapData(calcData, fullLayout));\n  Promise.all(promises).then(function () {\n    self.fillBelowLookup(calcData, fullLayout);\n    self.updateData(calcData);\n    self.updateLayout(fullLayout);\n    self.resolveOnRender(resolve);\n  }).catch(reject);\n};\n\nproto.fillBelowLookup = function (calcData, fullLayout) {\n  var opts = fullLayout[this.id];\n  var layers = opts.layers;\n  var i, val;\n  var belowLookup = this.belowLookup = {};\n  var hasTraceAtTop = false;\n\n  for (i = 0; i < calcData.length; i++) {\n    var trace = calcData[i][0].trace;\n    var _module = trace._module;\n\n    if (typeof trace.below === 'string') {\n      val = trace.below;\n    } else if (_module.getBelow) {\n      // 'smart' default that depend the map's base layers\n      val = _module.getBelow(trace, this);\n    }\n\n    if (val === '') {\n      hasTraceAtTop = true;\n    }\n\n    belowLookup['trace-' + trace.uid] = val || '';\n  }\n\n  for (i = 0; i < layers.length; i++) {\n    var item = layers[i];\n\n    if (typeof item.below === 'string') {\n      val = item.below;\n    } else if (hasTraceAtTop) {\n      // if one or more trace(s) set `below:''` and\n      // layers[i].below is unset,\n      // place layer below traces\n      val = 'traces';\n    } else {\n      val = '';\n    }\n\n    belowLookup['layout-' + i] = val;\n  } // N.B. If multiple layers have the 'below' value,\n  // we must clear the stashed 'below' field in order\n  // to make `traceHash[k].update()` and `layerList[i].update()`\n  // remove/add the all those layers to have preserve\n  // the correct layer ordering\n\n\n  var val2list = {};\n  var k, id;\n\n  for (k in belowLookup) {\n    val = belowLookup[k];\n\n    if (val2list[val]) {\n      val2list[val].push(k);\n    } else {\n      val2list[val] = [k];\n    }\n  }\n\n  for (val in val2list) {\n    var list = val2list[val];\n\n    if (list.length > 1) {\n      for (i = 0; i < list.length; i++) {\n        k = list[i];\n\n        if (k.indexOf('trace-') === 0) {\n          id = k.split('trace-')[1];\n\n          if (this.traceHash[id]) {\n            this.traceHash[id].below = null;\n          }\n        } else if (k.indexOf('layout-') === 0) {\n          id = k.split('layout-')[1];\n\n          if (this.layerList[id]) {\n            this.layerList[id].below = null;\n          }\n        }\n      }\n    }\n  }\n};\n\nvar traceType2orderIndex = {\n  choroplethmapbox: 0,\n  densitymapbox: 1,\n  scattermapbox: 2\n};\n\nproto.updateData = function (calcData) {\n  var traceHash = this.traceHash;\n  var traceObj, trace, i, j; // Need to sort here by trace type here,\n  // in case traces with different `type` have the same\n  // below value, but sorting we ensure that\n  // e.g. choroplethmapbox traces will be below scattermapbox traces\n\n  var calcDataSorted = calcData.slice().sort(function (a, b) {\n    return traceType2orderIndex[a[0].trace.type] - traceType2orderIndex[b[0].trace.type];\n  }); // update or create trace objects\n\n  for (i = 0; i < calcDataSorted.length; i++) {\n    var calcTrace = calcDataSorted[i];\n    trace = calcTrace[0].trace;\n    traceObj = traceHash[trace.uid];\n    var didUpdate = false;\n\n    if (traceObj) {\n      if (traceObj.type === trace.type) {\n        traceObj.update(calcTrace);\n        didUpdate = true;\n      } else {\n        traceObj.dispose();\n      }\n    }\n\n    if (!didUpdate && trace._module) {\n      traceHash[trace.uid] = trace._module.plot(this, calcTrace);\n    }\n  } // remove empty trace objects\n\n\n  var ids = Object.keys(traceHash);\n\n  idLoop: for (i = 0; i < ids.length; i++) {\n    var id = ids[i];\n\n    for (j = 0; j < calcData.length; j++) {\n      trace = calcData[j][0].trace;\n      if (id === trace.uid) continue idLoop;\n    }\n\n    traceObj = traceHash[id];\n    traceObj.dispose();\n    delete traceHash[id];\n  }\n};\n\nproto.updateLayout = function (fullLayout) {\n  var map = this.map;\n  var opts = fullLayout[this.id];\n  map.setCenter(convertCenter(opts.center));\n  map.setZoom(opts.zoom);\n  map.setBearing(opts.bearing);\n  map.setPitch(opts.pitch);\n  this.updateLayers(fullLayout);\n  this.updateFramework(fullLayout);\n  this.updateFx(fullLayout);\n  this.map.resize();\n\n  if (this.gd._context._scrollZoom.mapbox) {\n    map.scrollZoom.enable();\n  } else {\n    map.scrollZoom.disable();\n  }\n};\n\nproto.resolveOnRender = function (resolve) {\n  var map = this.map;\n  map.on('render', function onRender() {\n    if (map.loaded()) {\n      map.off('render', onRender); // resolve at end of render loop\n      //\n      // Need a 10ms delay (0ms should suffice to skip a thread in the\n      // render loop) to workaround mapbox-gl bug introduced in v1.3.0\n\n      setTimeout(resolve, 10);\n    }\n  });\n};\n\nproto.rejectOnError = function (reject) {\n  var map = this.map;\n\n  function handler() {\n    reject(new Error(constants.mapOnErrorMsg));\n  }\n\n  map.once('error', handler);\n  map.once('style.error', handler);\n  map.once('source.error', handler);\n  map.once('tile.error', handler);\n  map.once('layer.error', handler);\n};\n\nproto.createFramework = function (fullLayout) {\n  var self = this;\n  var div = self.div = document.createElement('div');\n  div.id = self.uid;\n  div.style.position = 'absolute';\n  self.container.appendChild(div); // create mock x/y axes for hover routine\n\n  self.xaxis = {\n    _id: 'x',\n    c2p: function (v) {\n      return self.project(v).x;\n    }\n  };\n  self.yaxis = {\n    _id: 'y',\n    c2p: function (v) {\n      return self.project(v).y;\n    }\n  };\n  self.updateFramework(fullLayout); // mock axis for hover formatting\n\n  self.mockAxis = {\n    type: 'linear',\n    showexponent: 'all',\n    exponentformat: 'B'\n  };\n  Axes.setConvert(self.mockAxis, fullLayout);\n};\n\nproto.initFx = function (calcData, fullLayout) {\n  var self = this;\n  var gd = self.gd;\n  var map = self.map;\n  var wheeling = false; // keep track of pan / zoom in user layout and emit relayout event\n\n  map.on('moveend', function (evt) {\n    if (!self.map) return;\n    var fullLayoutNow = gd._fullLayout; // 'moveend' gets triggered by map.setCenter, map.setZoom,\n    // map.setBearing and map.setPitch.\n    //\n    // Here, we make sure that state updates amd 'plotly_relayout'\n    // are triggered only when the 'moveend' originates from a\n    // mouse target (filtering out API calls) to not\n    // duplicate 'plotly_relayout' events.\n\n    if (evt.originalEvent || wheeling) {\n      var optsNow = fullLayoutNow[self.id];\n      Registry.call('_storeDirectGUIEdit', gd.layout, fullLayoutNow._preGUI, self.getViewEdits(optsNow));\n      var viewNow = self.getView();\n      optsNow._input.center = optsNow.center = viewNow.center;\n      optsNow._input.zoom = optsNow.zoom = viewNow.zoom;\n      optsNow._input.bearing = optsNow.bearing = viewNow.bearing;\n      optsNow._input.pitch = optsNow.pitch = viewNow.pitch;\n      gd.emit('plotly_relayout', self.getViewEdits(viewNow));\n    }\n\n    wheeling = false;\n\n    if (fullLayoutNow._rehover) {\n      fullLayoutNow._rehover();\n    }\n  });\n  map.on('wheel', function () {\n    wheeling = true;\n  });\n  map.on('mousemove', function (evt) {\n    var bb = self.div.getBoundingClientRect(); // some hackery to get Fx.hover to work\n\n    evt.clientX = evt.point.x + bb.left;\n    evt.clientY = evt.point.y + bb.top;\n\n    evt.target.getBoundingClientRect = function () {\n      return bb;\n    };\n\n    self.xaxis.p2c = function () {\n      return evt.lngLat.lng;\n    };\n\n    self.yaxis.p2c = function () {\n      return evt.lngLat.lat;\n    };\n\n    gd._fullLayout._rehover = function () {\n      if (gd._fullLayout._hoversubplot === self.id && gd._fullLayout[self.id]) {\n        Fx.hover(gd, evt, self.id);\n      }\n    };\n\n    Fx.hover(gd, evt, self.id);\n    gd._fullLayout._hoversubplot = self.id;\n  });\n\n  function unhover() {\n    Fx.loneUnhover(fullLayout._hoverlayer);\n  }\n\n  map.on('dragstart', unhover);\n  map.on('zoomstart', unhover);\n  map.on('mouseout', function () {\n    gd._fullLayout._hoversubplot = null;\n  });\n\n  function emitUpdate() {\n    var viewNow = self.getView();\n    gd.emit('plotly_relayouting', self.getViewEdits(viewNow));\n  }\n\n  map.on('drag', emitUpdate);\n  map.on('zoom', emitUpdate);\n  map.on('dblclick', function () {\n    var optsNow = gd._fullLayout[self.id];\n    Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, self.getViewEdits(optsNow));\n    var viewInitial = self.viewInitial;\n    map.setCenter(convertCenter(viewInitial.center));\n    map.setZoom(viewInitial.zoom);\n    map.setBearing(viewInitial.bearing);\n    map.setPitch(viewInitial.pitch);\n    var viewNow = self.getView();\n    optsNow._input.center = optsNow.center = viewNow.center;\n    optsNow._input.zoom = optsNow.zoom = viewNow.zoom;\n    optsNow._input.bearing = optsNow.bearing = viewNow.bearing;\n    optsNow._input.pitch = optsNow.pitch = viewNow.pitch;\n    gd.emit('plotly_doubleclick', null);\n    gd.emit('plotly_relayout', self.getViewEdits(viewNow));\n  }); // define event handlers on map creation, to keep one ref per map,\n  // so that map.on / map.off in updateFx works as expected\n\n  self.clearSelect = function () {\n    gd._fullLayout._zoomlayer.selectAll('.select-outline').remove();\n  };\n  /**\n   * Returns a click handler function that is supposed\n   * to handle clicks in pan mode.\n   */\n\n\n  self.onClickInPanFn = function (dragOptions) {\n    return function (evt) {\n      var clickMode = gd._fullLayout.clickmode;\n\n      if (clickMode.indexOf('select') > -1) {\n        selectOnClick(evt.originalEvent, gd, [self.xaxis], [self.yaxis], self.id, dragOptions);\n      }\n\n      if (clickMode.indexOf('event') > -1) {\n        // TODO: this does not support right-click. If we want to support it, we\n        // would likely need to change mapbox to use dragElement instead of straight\n        // mapbox event binding. Or perhaps better, make a simple wrapper with the\n        // right mousedown, mousemove, and mouseup handlers just for a left/right click\n        // pie would use this too.\n        Fx.click(gd, evt.originalEvent);\n      }\n    };\n  };\n};\n\nproto.updateFx = function (fullLayout) {\n  var self = this;\n  var map = self.map;\n  var gd = self.gd;\n  if (self.isStatic) return;\n\n  function invert(pxpy) {\n    var obj = self.map.unproject(pxpy);\n    return [obj.lng, obj.lat];\n  }\n\n  var dragMode = fullLayout.dragmode;\n  var fillRangeItems;\n\n  if (dragMode === 'select') {\n    fillRangeItems = function (eventData, poly) {\n      var ranges = eventData.range = {};\n      ranges[self.id] = [invert([poly.xmin, poly.ymin]), invert([poly.xmax, poly.ymax])];\n    };\n  } else {\n    fillRangeItems = function (eventData, poly, pts) {\n      var dataPts = eventData.lassoPoints = {};\n      dataPts[self.id] = pts.filtered.map(invert);\n    };\n  } // Note: dragOptions is needed to be declared for all dragmodes because\n  // it's the object that holds persistent selection state.\n  // Merge old dragOptions with new to keep possibly initialized\n  // persistent selection state.\n\n\n  var oldDragOptions = self.dragOptions;\n  self.dragOptions = Lib.extendDeep(oldDragOptions || {}, {\n    element: self.div,\n    gd: gd,\n    plotinfo: {\n      id: self.id,\n      xaxis: self.xaxis,\n      yaxis: self.yaxis,\n      fillRangeItems: fillRangeItems\n    },\n    xaxes: [self.xaxis],\n    yaxes: [self.yaxis],\n    subplot: self.id\n  }); // Unregister the old handler before potentially registering\n  // a new one. Otherwise multiple click handlers might\n  // be registered resulting in unwanted behavior.\n\n  map.off('click', self.onClickInPanHandler);\n\n  if (dragMode === 'select' || dragMode === 'lasso') {\n    map.dragPan.disable();\n    map.on('zoomstart', self.clearSelect);\n\n    self.dragOptions.prepFn = function (e, startX, startY) {\n      prepSelect(e, startX, startY, self.dragOptions, dragMode);\n    };\n\n    dragElement.init(self.dragOptions);\n  } else {\n    map.dragPan.enable();\n    map.off('zoomstart', self.clearSelect);\n    self.div.onmousedown = null; // TODO: this does not support right-click. If we want to support it, we\n    // would likely need to change mapbox to use dragElement instead of straight\n    // mapbox event binding. Or perhaps better, make a simple wrapper with the\n    // right mousedown, mousemove, and mouseup handlers just for a left/right click\n    // pie would use this too.\n\n    self.onClickInPanHandler = self.onClickInPanFn(self.dragOptions);\n    map.on('click', self.onClickInPanHandler);\n  }\n};\n\nproto.updateFramework = function (fullLayout) {\n  var domain = fullLayout[this.id].domain;\n  var size = fullLayout._size;\n  var style = this.div.style;\n  style.width = size.w * (domain.x[1] - domain.x[0]) + 'px';\n  style.height = size.h * (domain.y[1] - domain.y[0]) + 'px';\n  style.left = size.l + domain.x[0] * size.w + 'px';\n  style.top = size.t + (1 - domain.y[1]) * size.h + 'px';\n  this.xaxis._offset = size.l + domain.x[0] * size.w;\n  this.xaxis._length = size.w * (domain.x[1] - domain.x[0]);\n  this.yaxis._offset = size.t + (1 - domain.y[1]) * size.h;\n  this.yaxis._length = size.h * (domain.y[1] - domain.y[0]);\n};\n\nproto.updateLayers = function (fullLayout) {\n  var opts = fullLayout[this.id];\n  var layers = opts.layers;\n  var layerList = this.layerList;\n  var i; // if the layer arrays don't match,\n  // don't try to be smart,\n  // delete them all, and start all over.\n\n  if (layers.length !== layerList.length) {\n    for (i = 0; i < layerList.length; i++) {\n      layerList[i].dispose();\n    }\n\n    layerList = this.layerList = [];\n\n    for (i = 0; i < layers.length; i++) {\n      layerList.push(createMapboxLayer(this, i, layers[i]));\n    }\n  } else {\n    for (i = 0; i < layers.length; i++) {\n      layerList[i].update(layers[i]);\n    }\n  }\n};\n\nproto.destroy = function () {\n  if (this.map) {\n    this.map.remove();\n    this.map = null;\n    this.container.removeChild(this.div);\n  }\n};\n\nproto.toImage = function () {\n  this.map.stop();\n  return this.map.getCanvas().toDataURL();\n}; // convenience wrapper to create set multiple layer\n// 'layout' or 'paint options at once.\n\n\nproto.setOptions = function (id, methodName, opts) {\n  for (var k in opts) {\n    this.map[methodName](id, k, opts[k]);\n  }\n};\n\nproto.getMapLayers = function () {\n  return this.map.getStyle().layers;\n}; // convenience wrapper that first check in 'below' references\n// a layer that exist and then add the layer to the map,\n\n\nproto.addLayer = function (opts, below) {\n  var map = this.map;\n\n  if (typeof below === 'string') {\n    if (below === '') {\n      map.addLayer(opts, below);\n      return;\n    }\n\n    var mapLayers = this.getMapLayers();\n\n    for (var i = 0; i < mapLayers.length; i++) {\n      if (below === mapLayers[i].id) {\n        map.addLayer(opts, below);\n        return;\n      }\n    }\n\n    Lib.warn(['Trying to add layer with *below* value', below, 'referencing a layer that does not exist', 'or that does not yet exist.'].join(' '));\n  }\n\n  map.addLayer(opts);\n}; // convenience method to project a [lon, lat] array to pixel coords\n\n\nproto.project = function (v) {\n  return this.map.project(new mapboxgl.LngLat(v[0], v[1]));\n}; // get map's current view values in plotly.js notation\n\n\nproto.getView = function () {\n  var map = this.map;\n  var mapCenter = map.getCenter();\n  var center = {\n    lon: mapCenter.lng,\n    lat: mapCenter.lat\n  };\n  return {\n    center: center,\n    zoom: map.getZoom(),\n    bearing: map.getBearing(),\n    pitch: map.getPitch()\n  };\n};\n\nproto.getViewEdits = function (cont) {\n  var id = this.id;\n  var keys = ['center', 'zoom', 'bearing', 'pitch'];\n  var obj = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var k = keys[i];\n    obj[id + '.' + k] = cont[k];\n  }\n\n  return obj;\n};\n\nfunction getStyleObj(val) {\n  var styleObj = {};\n\n  if (Lib.isPlainObject(val)) {\n    styleObj.id = val.id;\n    styleObj.style = val;\n  } else if (typeof val === 'string') {\n    styleObj.id = val;\n\n    if (constants.styleValuesMapbox.indexOf(val) !== -1) {\n      styleObj.style = convertStyleVal(val);\n    } else if (constants.stylesNonMapbox[val]) {\n      styleObj.style = constants.stylesNonMapbox[val];\n    } else {\n      styleObj.style = val;\n    }\n  } else {\n    styleObj.id = constants.styleValueDflt;\n    styleObj.style = convertStyleVal(constants.styleValueDflt);\n  }\n\n  styleObj.transition = {\n    duration: 0,\n    delay: 0\n  };\n  return styleObj;\n} // if style is part of the 'official' mapbox values, add URL prefix and suffix\n\n\nfunction convertStyleVal(val) {\n  return constants.styleUrlPrefix + val + '-' + constants.styleUrlSuffix;\n}\n\nfunction convertCenter(center) {\n  return [center.lon, center.lat];\n}\n\nmodule.exports = Mapbox;","map":null,"metadata":{},"sourceType":"script"}