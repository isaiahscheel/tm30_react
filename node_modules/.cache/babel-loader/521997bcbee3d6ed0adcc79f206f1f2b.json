{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar Drawing = require('../../components/drawing');\n\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar convertTextOpts = require('../../plots/mapbox/convert_text_opts');\n\nvar NEWLINES = require('../../lib/svg_text_utils').NEWLINES;\n\nvar BR_TAG_ALL = require('../../lib/svg_text_utils').BR_TAG_ALL;\n\nmodule.exports = function convert(gd, calcTrace) {\n  var trace = calcTrace[0].trace;\n  var isVisible = trace.visible === true && trace._length !== 0;\n  var hasFill = trace.fill !== 'none';\n  var hasLines = subTypes.hasLines(trace);\n  var hasMarkers = subTypes.hasMarkers(trace);\n  var hasText = subTypes.hasText(trace);\n  var hasCircles = hasMarkers && trace.marker.symbol === 'circle';\n  var hasSymbols = hasMarkers && trace.marker.symbol !== 'circle';\n  var fill = initContainer();\n  var line = initContainer();\n  var circle = initContainer();\n  var symbol = initContainer();\n  var opts = {\n    fill: fill,\n    line: line,\n    circle: circle,\n    symbol: symbol\n  }; // early return if not visible or placeholder\n\n  if (!isVisible) return opts; // fill layer and line layer use the same coords\n\n  var lineCoords;\n\n  if (hasFill || hasLines) {\n    lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n  }\n\n  if (hasFill) {\n    fill.geojson = geoJsonUtils.makePolygon(lineCoords);\n    fill.layout.visibility = 'visible';\n    Lib.extendFlat(fill.paint, {\n      'fill-color': trace.fillcolor\n    });\n  }\n\n  if (hasLines) {\n    line.geojson = geoJsonUtils.makeLine(lineCoords);\n    line.layout.visibility = 'visible';\n    Lib.extendFlat(line.paint, {\n      'line-width': trace.line.width,\n      'line-color': trace.line.color,\n      'line-opacity': trace.opacity\n    }); // TODO convert line.dash into line-dasharray\n  }\n\n  if (hasCircles) {\n    var circleOpts = makeCircleOpts(calcTrace);\n    circle.geojson = circleOpts.geojson;\n    circle.layout.visibility = 'visible';\n    Lib.extendFlat(circle.paint, {\n      'circle-color': circleOpts.mcc,\n      'circle-radius': circleOpts.mrc,\n      'circle-opacity': circleOpts.mo\n    });\n  }\n\n  if (hasSymbols || hasText) {\n    symbol.geojson = makeSymbolGeoJSON(calcTrace, gd);\n    Lib.extendFlat(symbol.layout, {\n      visibility: 'visible',\n      'icon-image': '{symbol}-15',\n      'text-field': '{text}'\n    });\n\n    if (hasSymbols) {\n      Lib.extendFlat(symbol.layout, {\n        'icon-size': trace.marker.size / 10\n      });\n      Lib.extendFlat(symbol.paint, {\n        'icon-opacity': trace.opacity * trace.marker.opacity,\n        // TODO does not work ??\n        'icon-color': trace.marker.color\n      });\n    }\n\n    if (hasText) {\n      var iconSize = (trace.marker || {}).size;\n      var textOpts = convertTextOpts(trace.textposition, iconSize); // all data-driven below !!\n\n      Lib.extendFlat(symbol.layout, {\n        'text-size': trace.textfont.size,\n        'text-anchor': textOpts.anchor,\n        'text-offset': textOpts.offset // TODO font family\n        // 'text-font': symbol.textfont.family.split(', '),\n\n      });\n      Lib.extendFlat(symbol.paint, {\n        'text-color': trace.textfont.color,\n        'text-opacity': trace.opacity\n      });\n    }\n  }\n\n  return opts;\n};\n\nfunction initContainer() {\n  return {\n    geojson: geoJsonUtils.makeBlank(),\n    layout: {\n      visibility: 'none'\n    },\n    paint: {}\n  };\n}\n\nfunction makeCircleOpts(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var marker = trace.marker;\n  var selectedpoints = trace.selectedpoints;\n  var arrayColor = Lib.isArrayOrTypedArray(marker.color);\n  var arraySize = Lib.isArrayOrTypedArray(marker.size);\n  var arrayOpacity = Lib.isArrayOrTypedArray(marker.opacity);\n  var i;\n\n  function addTraceOpacity(o) {\n    return trace.opacity * o;\n  }\n\n  function size2radius(s) {\n    return s / 2;\n  }\n\n  var colorFn;\n\n  if (arrayColor) {\n    if (Colorscale.hasColorscale(trace, 'marker')) {\n      colorFn = Colorscale.makeColorScaleFuncFromTrace(marker);\n    } else {\n      colorFn = Lib.identity;\n    }\n  }\n\n  var sizeFn;\n\n  if (arraySize) {\n    sizeFn = makeBubbleSizeFn(trace);\n  }\n\n  var opacityFn;\n\n  if (arrayOpacity) {\n    opacityFn = function (mo) {\n      var mo2 = isNumeric(mo) ? +Lib.constrain(mo, 0, 1) : 0;\n      return addTraceOpacity(mo2);\n    };\n  }\n\n  var features = [];\n\n  for (i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    var lonlat = calcPt.lonlat;\n    if (isBADNUM(lonlat)) continue;\n    var props = {};\n    if (colorFn) props.mcc = calcPt.mcc = colorFn(calcPt.mc);\n    if (sizeFn) props.mrc = calcPt.mrc = sizeFn(calcPt.ms);\n    if (opacityFn) props.mo = opacityFn(calcPt.mo);\n    if (selectedpoints) props.selected = calcPt.selected || 0;\n    features.push({\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: lonlat\n      },\n      properties: props\n    });\n  }\n\n  var fns;\n\n  if (selectedpoints) {\n    fns = Drawing.makeSelectedPointStyleFns(trace);\n\n    for (i = 0; i < features.length; i++) {\n      var d = features[i].properties;\n\n      if (fns.selectedOpacityFn) {\n        d.mo = addTraceOpacity(fns.selectedOpacityFn(d));\n      }\n\n      if (fns.selectedColorFn) {\n        d.mcc = fns.selectedColorFn(d);\n      }\n\n      if (fns.selectedSizeFn) {\n        d.mrc = fns.selectedSizeFn(d);\n      }\n    }\n  }\n\n  return {\n    geojson: {\n      type: 'FeatureCollection',\n      features: features\n    },\n    mcc: arrayColor || fns && fns.selectedColorFn ? {\n      type: 'identity',\n      property: 'mcc'\n    } : marker.color,\n    mrc: arraySize || fns && fns.selectedSizeFn ? {\n      type: 'identity',\n      property: 'mrc'\n    } : size2radius(marker.size),\n    mo: arrayOpacity || fns && fns.selectedOpacityFn ? {\n      type: 'identity',\n      property: 'mo'\n    } : addTraceOpacity(marker.opacity)\n  };\n}\n\nfunction makeSymbolGeoJSON(calcTrace, gd) {\n  var trace = calcTrace[0].trace;\n  var marker = trace.marker || {};\n  var symbol = marker.symbol;\n  var fillSymbol = symbol !== 'circle' ? getFillFunc(symbol) : blankFillFunc;\n  var fillText = subTypes.hasText(trace) ? getFillFunc(trace.text) : blankFillFunc;\n  var features = [];\n\n  for (var i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    if (isBADNUM(calcPt.lonlat)) continue;\n    var txt = trace.texttemplate;\n\n    if (txt) {\n      var txti = Array.isArray(txt) ? txt[i] || '' : txt;\n      calcPt.text = calcPt.tx;\n      calcPt.lon = calcPt.lonlat[0];\n      calcPt.lat = calcPt.lonlat[1];\n      calcPt.customdata = calcPt.data;\n      calcPt.txt = Lib.texttemplateString(txti, {}, gd._fullLayout._d3locale, calcPt, trace._meta || {});\n    }\n\n    var text = txt ? calcPt.txt : fillText(calcPt.tx);\n    if (text) text = text.replace(NEWLINES, '').replace(BR_TAG_ALL, '\\n');\n    features.push({\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: calcPt.lonlat\n      },\n      properties: {\n        symbol: fillSymbol(calcPt.mx),\n        text: text\n      }\n    });\n  }\n\n  return {\n    type: 'FeatureCollection',\n    features: features\n  };\n}\n\nfunction getFillFunc(attr) {\n  if (Lib.isArrayOrTypedArray(attr)) {\n    return function (v) {\n      return v;\n    };\n  } else if (attr) {\n    return function () {\n      return attr;\n    };\n  } else {\n    return blankFillFunc;\n  }\n}\n\nfunction blankFillFunc() {\n  return '';\n} // only need to check lon (OR lat)\n\n\nfunction isBADNUM(lonlat) {\n  return lonlat[0] === BADNUM;\n}","map":null,"metadata":{},"sourceType":"script"}