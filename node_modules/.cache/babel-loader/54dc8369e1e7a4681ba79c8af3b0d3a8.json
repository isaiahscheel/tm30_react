{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar helpers = require('../../plots/polar/helpers');\n\nmodule.exports = function plot(gd, subplot, cdbar) {\n  var xa = subplot.xaxis;\n  var ya = subplot.yaxis;\n  var radialAxis = subplot.radialAxis;\n  var angularAxis = subplot.angularAxis;\n  var pathFn = makePathFn(subplot);\n  var barLayer = subplot.layers.frontplot.select('g.barlayer');\n  Lib.makeTraceGroups(barLayer, cdbar, 'trace bars').each(function () {\n    var plotGroup = d3.select(this);\n    var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n    var bars = pointGroup.selectAll('g.point').data(Lib.identity);\n    bars.enter().append('g').style('vector-effect', 'non-scaling-stroke').style('stroke-miterlimit', 2).classed('point', true);\n    bars.exit().remove();\n    bars.each(function (di) {\n      var bar = d3.select(this);\n      var rp0 = di.rp0 = radialAxis.c2p(di.s0);\n      var rp1 = di.rp1 = radialAxis.c2p(di.s1);\n      var thetag0 = di.thetag0 = angularAxis.c2g(di.p0);\n      var thetag1 = di.thetag1 = angularAxis.c2g(di.p1);\n      var dPath;\n\n      if (!isNumeric(rp0) || !isNumeric(rp1) || !isNumeric(thetag0) || !isNumeric(thetag1) || rp0 === rp1 || thetag0 === thetag1) {\n        // do not remove blank bars, to keep data-to-node\n        // mapping intact during radial drag, that we\n        // can skip calling _module.style during interactions\n        dPath = 'M0,0Z';\n      } else {\n        // this 'center' pt is used for selections and hover labels\n        var rg1 = radialAxis.c2g(di.s1);\n        var thetagMid = (thetag0 + thetag1) / 2;\n        di.ct = [xa.c2p(rg1 * Math.cos(thetagMid)), ya.c2p(rg1 * Math.sin(thetagMid))];\n        dPath = pathFn(rp0, rp1, thetag0, thetag1);\n      }\n\n      Lib.ensureSingle(bar, 'path').attr('d', dPath);\n    }); // clip plotGroup, when trace layer isn't clipped\n\n    Drawing.setClipUrl(plotGroup, subplot._hasClipOnAxisFalse ? subplot.clipIds.forTraces : null, gd);\n  });\n};\n\nfunction makePathFn(subplot) {\n  var cxx = subplot.cxx;\n  var cyy = subplot.cyy;\n\n  if (subplot.vangles) {\n    return function (r0, r1, _a0, _a1) {\n      var a0, a1;\n\n      if (Lib.angleDelta(_a0, _a1) > 0) {\n        a0 = _a0;\n        a1 = _a1;\n      } else {\n        a0 = _a1;\n        a1 = _a0;\n      }\n\n      var va0 = helpers.findEnclosingVertexAngles(a0, subplot.vangles)[0];\n      var va1 = helpers.findEnclosingVertexAngles(a1, subplot.vangles)[1];\n      var vaBar = [va0, (a0 + a1) / 2, va1];\n      return helpers.pathPolygonAnnulus(r0, r1, a0, a1, vaBar, cxx, cyy);\n    };\n  }\n\n  return function (r0, r1, a0, a1) {\n    return Lib.pathAnnulus(r0, r1, a0, a1, cxx, cyy);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}