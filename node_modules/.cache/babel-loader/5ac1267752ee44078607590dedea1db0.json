{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plotly = require('../../plot_api/plot_api');\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar tinycolor = require('tinycolor2');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nfunction performPlot(parcatsModels, graphDiv, layout, svg) {\n  var viewModels = parcatsModels.map(createParcatsViewModel.bind(0, graphDiv, layout)); // Get (potentially empty) parcatslayer selection with bound data to single element array\n\n  var layerSelection = svg.selectAll('g.parcatslayer').data([null]); // Initialize single parcatslayer group if it doesn't exist\n\n  layerSelection.enter().append('g').attr('class', 'parcatslayer').style('pointer-events', 'all'); // Bind data to children of layerSelection and get reference to traceSelection\n\n  var traceSelection = layerSelection.selectAll('g.trace.parcats').data(viewModels, key); // Initialize group for each trace/dimensions\n\n  var traceEnter = traceSelection.enter().append('g').attr('class', 'trace parcats'); // Update properties for each trace\n\n  traceSelection.attr('transform', function (d) {\n    return 'translate(' + d.x + ', ' + d.y + ')';\n  }); // Initialize paths group\n\n  traceEnter.append('g').attr('class', 'paths'); // Update paths transform\n\n  var pathsSelection = traceSelection.select('g.paths'); // Get paths selection\n\n  var pathSelection = pathsSelection.selectAll('path.path').data(function (d) {\n    return d.paths;\n  }, key); // Update existing path colors\n\n  pathSelection.attr('fill', function (d) {\n    return d.model.color;\n  }); // Create paths\n\n  var pathSelectionEnter = pathSelection.enter().append('path').attr('class', 'path').attr('stroke-opacity', 0).attr('fill', function (d) {\n    return d.model.color;\n  }).attr('fill-opacity', 0);\n  stylePathsNoHover(pathSelectionEnter); // Set path geometry\n\n  pathSelection.attr('d', function (d) {\n    return d.svgD;\n  }); // sort paths\n\n  if (!pathSelectionEnter.empty()) {\n    // Only sort paths if there has been a change.\n    // Otherwise paths are already sorted or a hover operation may be in progress\n    pathSelection.sort(compareRawColor);\n  } // Remove any old paths\n\n\n  pathSelection.exit().remove(); // Path hover\n\n  pathSelection.on('mouseover', mouseoverPath).on('mouseout', mouseoutPath).on('click', clickPath); // Initialize dimensions group\n\n  traceEnter.append('g').attr('class', 'dimensions'); // Update dimensions transform\n\n  var dimensionsSelection = traceSelection.select('g.dimensions'); // Get dimension selection\n\n  var dimensionSelection = dimensionsSelection.selectAll('g.dimension').data(function (d) {\n    return d.dimensions;\n  }, key); // Create dimension groups\n\n  dimensionSelection.enter().append('g').attr('class', 'dimension'); // Update dimension group transforms\n\n  dimensionSelection.attr('transform', function (d) {\n    return 'translate(' + d.x + ', 0)';\n  }); // Remove any old dimensions\n\n  dimensionSelection.exit().remove(); // Get category selection\n\n  var categorySelection = dimensionSelection.selectAll('g.category').data(function (d) {\n    return d.categories;\n  }, key); // Initialize category groups\n\n  var categoryGroupEnterSelection = categorySelection.enter().append('g').attr('class', 'category'); // Update category transforms\n\n  categorySelection.attr('transform', function (d) {\n    return 'translate(0, ' + d.y + ')';\n  }); // Initialize rectangle\n\n  categoryGroupEnterSelection.append('rect').attr('class', 'catrect').attr('pointer-events', 'none'); // Update rectangle\n\n  categorySelection.select('rect.catrect').attr('fill', 'none').attr('width', function (d) {\n    return d.width;\n  }).attr('height', function (d) {\n    return d.height;\n  });\n  styleCategoriesNoHover(categoryGroupEnterSelection); // Initialize color band rects\n\n  var bandSelection = categorySelection.selectAll('rect.bandrect').data(\n  /** @param {CategoryViewModel} catViewModel*/\n  function (catViewModel) {\n    return catViewModel.bands;\n  }, key); // Raise all update bands to the top so that fading enter/exit bands will be behind\n\n  bandSelection.each(function () {\n    Lib.raiseToTop(this);\n  }); // Update band color\n\n  bandSelection.attr('fill', function (d) {\n    return d.color;\n  });\n  var bandsSelectionEnter = bandSelection.enter().append('rect').attr('class', 'bandrect').attr('stroke-opacity', 0).attr('fill', function (d) {\n    return d.color;\n  }).attr('fill-opacity', 0);\n  bandSelection.attr('fill', function (d) {\n    return d.color;\n  }).attr('width', function (d) {\n    return d.width;\n  }).attr('height', function (d) {\n    return d.height;\n  }).attr('y', function (d) {\n    return d.y;\n  }).attr('cursor',\n  /** @param {CategoryBandViewModel} bandModel*/\n  function (bandModel) {\n    if (bandModel.parcatsViewModel.arrangement === 'fixed') {\n      return 'default';\n    } else if (bandModel.parcatsViewModel.arrangement === 'perpendicular') {\n      return 'ns-resize';\n    } else {\n      return 'move';\n    }\n  });\n  styleBandsNoHover(bandsSelectionEnter);\n  bandSelection.exit().remove(); // Initialize category label\n\n  categoryGroupEnterSelection.append('text').attr('class', 'catlabel').attr('pointer-events', 'none');\n  var paperColor = graphDiv._fullLayout.paper_bgcolor; // Update category label\n\n  categorySelection.select('text.catlabel').attr('text-anchor', function (d) {\n    if (catInRightDim(d)) {\n      // Place label to the right of category\n      return 'start';\n    } else {\n      // Place label to the left of category\n      return 'end';\n    }\n  }).attr('alignment-baseline', 'middle').style('text-shadow', paperColor + ' -1px  1px 2px, ' + paperColor + ' 1px  1px 2px, ' + paperColor + '  1px -1px 2px, ' + paperColor + ' -1px -1px 2px').style('fill', 'rgb(0, 0, 0)').attr('x', function (d) {\n    if (catInRightDim(d)) {\n      // Place label to the right of category\n      return d.width + 5;\n    } else {\n      // Place label to the left of category\n      return -5;\n    }\n  }).attr('y', function (d) {\n    return d.height / 2;\n  }).text(function (d) {\n    return d.model.categoryLabel;\n  }).each(\n  /** @param {CategoryViewModel} catModel*/\n  function (catModel) {\n    Drawing.font(d3.select(this), catModel.parcatsViewModel.categorylabelfont);\n    svgTextUtils.convertToTspans(d3.select(this), graphDiv);\n  }); // Initialize dimension label\n\n  categoryGroupEnterSelection.append('text').attr('class', 'dimlabel'); // Update dimension label\n\n  categorySelection.select('text.dimlabel').attr('text-anchor', 'middle').attr('alignment-baseline', 'baseline').attr('cursor',\n  /** @param {CategoryViewModel} catModel*/\n  function (catModel) {\n    if (catModel.parcatsViewModel.arrangement === 'fixed') {\n      return 'default';\n    } else {\n      return 'ew-resize';\n    }\n  }).attr('x', function (d) {\n    return d.width / 2;\n  }).attr('y', -5).text(function (d, i) {\n    if (i === 0) {\n      // Add dimension label above topmost category\n      return d.parcatsViewModel.model.dimensions[d.model.dimensionInd].dimensionLabel;\n    } else {\n      return null;\n    }\n  }).each(\n  /** @param {CategoryViewModel} catModel*/\n  function (catModel) {\n    Drawing.font(d3.select(this), catModel.parcatsViewModel.labelfont);\n  }); // Category hover\n  // categorySelection.select('rect.catrect')\n\n  categorySelection.selectAll('rect.bandrect').on('mouseover', mouseoverCategoryBand).on('mouseout', mouseoutCategory); // Remove unused categories\n\n  categorySelection.exit().remove(); // Setup drag\n\n  dimensionSelection.call(d3.behavior.drag().origin(function (d) {\n    return {\n      x: d.x,\n      y: 0\n    };\n  }).on('dragstart', dragDimensionStart).on('drag', dragDimension).on('dragend', dragDimensionEnd)); // Save off selections to view models\n\n  traceSelection.each(function (d) {\n    d.traceSelection = d3.select(this);\n    d.pathSelection = d3.select(this).selectAll('g.paths').selectAll('path.path');\n    d.dimensionSelection = d3.select(this).selectAll('g.dimensions').selectAll('g.dimension');\n  }); // Remove any orphan traces\n\n  traceSelection.exit().remove();\n}\n/**\n * Create / update parcat traces\n *\n * @param {Object} graphDiv\n * @param {Object} svg\n * @param {Array.<ParcatsModel>} parcatsModels\n * @param {Layout} layout\n */\n\n\nmodule.exports = function (graphDiv, svg, parcatsModels, layout) {\n  performPlot(parcatsModels, graphDiv, layout, svg);\n};\n/**\n * Function the returns the key property of an object for use with as D3 join function\n * @param d\n */\n\n\nfunction key(d) {\n  return d.key;\n}\n/** True if a category view model is in the right-most display dimension\n * @param {CategoryViewModel} d */\n\n\nfunction catInRightDim(d) {\n  var numDims = d.parcatsViewModel.dimensions.length;\n  var leftDimInd = d.parcatsViewModel.dimensions[numDims - 1].model.dimensionInd;\n  return d.model.dimensionInd === leftDimInd;\n}\n/**\n * @param {PathViewModel} a\n * @param {PathViewModel} b\n */\n\n\nfunction compareRawColor(a, b) {\n  if (a.model.rawColor > b.model.rawColor) {\n    return 1;\n  } else if (a.model.rawColor < b.model.rawColor) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n/**\n * Handle path mouseover\n * @param {PathViewModel} d\n */\n\n\nfunction mouseoverPath(d) {\n  if (!d.parcatsViewModel.dragDimension) {\n    // We're not currently dragging\n    if (d.parcatsViewModel.hoverinfoItems.indexOf('skip') === -1) {\n      // hoverinfo is not skip, so we at least style the paths and emit interaction events\n      // Raise path to top\n      Lib.raiseToTop(this);\n      stylePathsHover(d3.select(this)); // Emit hover event\n\n      var points = buildPointsArrayForPath(d);\n      var constraints = buildConstraintsForPath(d);\n      d.parcatsViewModel.graphDiv.emit('plotly_hover', {\n        points: points,\n        event: d3.event,\n        constraints: constraints\n      }); // Handle hover label\n\n      if (d.parcatsViewModel.hoverinfoItems.indexOf('none') === -1) {\n        // hoverinfo is a combination of 'count' and 'probability'\n        // Mouse\n        var hoverX = d3.mouse(this)[0]; // Label\n\n        var gd = d.parcatsViewModel.graphDiv;\n        var trace = d.parcatsViewModel.trace;\n        var fullLayout = gd._fullLayout;\n\n        var rootBBox = fullLayout._paperdiv.node().getBoundingClientRect();\n\n        var graphDivBBox = d.parcatsViewModel.graphDiv.getBoundingClientRect(); // Find path center in path coordinates\n\n        var pathCenterX, pathCenterY, dimInd;\n\n        for (dimInd = 0; dimInd < d.leftXs.length - 1; dimInd++) {\n          if (d.leftXs[dimInd] + d.dimWidths[dimInd] - 2 <= hoverX && hoverX <= d.leftXs[dimInd + 1] + 2) {\n            var leftDim = d.parcatsViewModel.dimensions[dimInd];\n            var rightDim = d.parcatsViewModel.dimensions[dimInd + 1];\n            pathCenterX = (leftDim.x + leftDim.width + rightDim.x) / 2;\n            pathCenterY = (d.topYs[dimInd] + d.topYs[dimInd + 1] + d.height) / 2;\n            break;\n          }\n        } // Find path center in root coordinates\n\n\n        var hoverCenterX = d.parcatsViewModel.x + pathCenterX;\n        var hoverCenterY = d.parcatsViewModel.y + pathCenterY;\n        var textColor = tinycolor.mostReadable(d.model.color, ['black', 'white']);\n        var count = d.model.count;\n        var prob = count / d.parcatsViewModel.model.count;\n        var labels = {\n          countLabel: count,\n          probabilityLabel: prob.toFixed(3)\n        }; // Build hover text\n\n        var hovertextParts = [];\n\n        if (d.parcatsViewModel.hoverinfoItems.indexOf('count') !== -1) {\n          hovertextParts.push(['Count:', labels.countLabel].join(' '));\n        }\n\n        if (d.parcatsViewModel.hoverinfoItems.indexOf('probability') !== -1) {\n          hovertextParts.push(['P:', labels.probabilityLabel].join(' '));\n        }\n\n        var hovertext = hovertextParts.join('<br>');\n        var mouseX = d3.mouse(gd)[0];\n        Fx.loneHover({\n          trace: trace,\n          x: hoverCenterX - rootBBox.left + graphDivBBox.left,\n          y: hoverCenterY - rootBBox.top + graphDivBBox.top,\n          text: hovertext,\n          color: d.model.color,\n          borderColor: 'black',\n          fontFamily: 'Monaco, \"Courier New\", monospace',\n          fontSize: 10,\n          fontColor: textColor,\n          idealAlign: mouseX < hoverCenterX ? 'right' : 'left',\n          hovertemplate: (trace.line || {}).hovertemplate,\n          hovertemplateLabels: labels,\n          eventData: [{\n            data: trace._input,\n            fullData: trace,\n            count: count,\n            probability: prob\n          }]\n        }, {\n          container: fullLayout._hoverlayer.node(),\n          outerContainer: fullLayout._paper.node(),\n          gd: gd\n        });\n      }\n    }\n  }\n}\n/**\n * Handle path mouseout\n * @param {PathViewModel} d\n */\n\n\nfunction mouseoutPath(d) {\n  if (!d.parcatsViewModel.dragDimension) {\n    // We're not currently dragging\n    stylePathsNoHover(d3.select(this)); // Remove and hover label\n\n    Fx.loneUnhover(d.parcatsViewModel.graphDiv._fullLayout._hoverlayer.node()); // Restore path order\n\n    d.parcatsViewModel.pathSelection.sort(compareRawColor); // Emit unhover event\n\n    if (d.parcatsViewModel.hoverinfoItems.indexOf('skip') === -1) {\n      var points = buildPointsArrayForPath(d);\n      var constraints = buildConstraintsForPath(d);\n      d.parcatsViewModel.graphDiv.emit('plotly_unhover', {\n        points: points,\n        event: d3.event,\n        constraints: constraints\n      });\n    }\n  }\n}\n/**\n * Build array of point objects for a path\n *\n * For use in click/hover events\n * @param {PathViewModel} d\n */\n\n\nfunction buildPointsArrayForPath(d) {\n  var points = [];\n  var curveNumber = getTraceIndex(d.parcatsViewModel);\n\n  for (var i = 0; i < d.model.valueInds.length; i++) {\n    var pointNumber = d.model.valueInds[i];\n    points.push({\n      curveNumber: curveNumber,\n      pointNumber: pointNumber\n    });\n  }\n\n  return points;\n}\n/**\n * Build constraints object for a path\n *\n * For use in click/hover events\n * @param {PathViewModel} d\n */\n\n\nfunction buildConstraintsForPath(d) {\n  var constraints = {};\n  var dimensions = d.parcatsViewModel.model.dimensions; // dimensions\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimension = dimensions[i];\n    var category = dimension.categories[d.model.categoryInds[i]];\n    constraints[dimension.containerInd] = category.categoryValue;\n  } // color\n\n\n  if (d.model.rawColor !== undefined) {\n    constraints.color = d.model.rawColor;\n  }\n\n  return constraints;\n}\n/**\n * Handle path click\n * @param {PathViewModel} d\n */\n\n\nfunction clickPath(d) {\n  if (d.parcatsViewModel.hoverinfoItems.indexOf('skip') === -1) {\n    // hoverinfo it's skip, so interaction events aren't disabled\n    var points = buildPointsArrayForPath(d);\n    var constraints = buildConstraintsForPath(d);\n    d.parcatsViewModel.graphDiv.emit('plotly_click', {\n      points: points,\n      event: d3.event,\n      constraints: constraints\n    });\n  }\n}\n\nfunction stylePathsNoHover(pathSelection) {\n  pathSelection.attr('fill', function (d) {\n    return d.model.color;\n  }).attr('fill-opacity', 0.6).attr('stroke', 'lightgray').attr('stroke-width', 0.2).attr('stroke-opacity', 1.0);\n}\n\nfunction stylePathsHover(pathSelection) {\n  pathSelection.attr('fill-opacity', 0.8).attr('stroke', function (d) {\n    return tinycolor.mostReadable(d.model.color, ['black', 'white']);\n  }).attr('stroke-width', 0.3);\n}\n\nfunction styleCategoryHover(categorySelection) {\n  categorySelection.select('rect.catrect').attr('stroke', 'black').attr('stroke-width', 2.5);\n}\n\nfunction styleCategoriesNoHover(categorySelection) {\n  categorySelection.select('rect.catrect').attr('stroke', 'black').attr('stroke-width', 1).attr('stroke-opacity', 1);\n}\n\nfunction styleBandsHover(bandsSelection) {\n  bandsSelection.attr('stroke', 'black').attr('stroke-width', 1.5);\n}\n\nfunction styleBandsNoHover(bandsSelection) {\n  bandsSelection.attr('stroke', 'black').attr('stroke-width', 0.2).attr('stroke-opacity', 1.0).attr('fill-opacity', 1.0);\n}\n/**\n * Return selection of all paths that pass through the specified category\n * @param {CategoryBandViewModel} catBandViewModel\n */\n\n\nfunction selectPathsThroughCategoryBandColor(catBandViewModel) {\n  var allPaths = catBandViewModel.parcatsViewModel.pathSelection;\n  var dimInd = catBandViewModel.categoryViewModel.model.dimensionInd;\n  var catInd = catBandViewModel.categoryViewModel.model.categoryInd;\n  return allPaths.filter(\n  /** @param {PathViewModel} pathViewModel */\n  function (pathViewModel) {\n    return pathViewModel.model.categoryInds[dimInd] === catInd && pathViewModel.model.color === catBandViewModel.color;\n  });\n}\n/**\n * Perform hover styling for all paths that pass though the specified band element's category\n *\n * @param {HTMLElement} bandElement\n *  HTML element for band\n *\n */\n\n\nfunction styleForCategoryHovermode(bandElement) {\n  // Get all bands in the current category\n  var bandSel = d3.select(bandElement.parentNode).selectAll('rect.bandrect'); // Raise and style paths\n\n  bandSel.each(function (bvm) {\n    var paths = selectPathsThroughCategoryBandColor(bvm);\n    stylePathsHover(paths);\n    paths.each(function () {\n      // Raise path to top\n      Lib.raiseToTop(this);\n    });\n  }); // Style category\n\n  styleCategoryHover(d3.select(bandElement.parentNode));\n}\n/**\n * Perform hover styling for all paths that pass though the category of the specified band element and share the\n * same color\n *\n * @param {HTMLElement} bandElement\n *  HTML element for band\n *\n */\n\n\nfunction styleForColorHovermode(bandElement) {\n  var bandViewModel = d3.select(bandElement).datum();\n  var catPaths = selectPathsThroughCategoryBandColor(bandViewModel);\n  stylePathsHover(catPaths);\n  catPaths.each(function () {\n    // Raise path to top\n    Lib.raiseToTop(this);\n  }); // Style category for drag\n\n  d3.select(bandElement.parentNode).selectAll('rect.bandrect').filter(function (b) {\n    return b.color === bandViewModel.color;\n  }).each(function () {\n    Lib.raiseToTop(this);\n    styleBandsHover(d3.select(this));\n  });\n}\n/**\n * @param {HTMLElement} bandElement\n *  HTML element for band\n * @param eventName\n *  Event name (plotly_hover or plotly_click)\n * @param event\n *  Mouse Event\n */\n\n\nfunction emitPointsEventCategoryHovermode(bandElement, eventName, event) {\n  // Get all bands in the current category\n  var bandViewModel = d3.select(bandElement).datum();\n  var categoryModel = bandViewModel.categoryViewModel.model;\n  var gd = bandViewModel.parcatsViewModel.graphDiv;\n  var bandSel = d3.select(bandElement.parentNode).selectAll('rect.bandrect');\n  var points = [];\n  bandSel.each(function (bvm) {\n    var paths = selectPathsThroughCategoryBandColor(bvm);\n    paths.each(function (pathViewModel) {\n      // Extend points array\n      Array.prototype.push.apply(points, buildPointsArrayForPath(pathViewModel));\n    });\n  });\n  var constraints = {};\n  constraints[categoryModel.dimensionInd] = categoryModel.categoryValue;\n  gd.emit(eventName, {\n    points: points,\n    event: event,\n    constraints: constraints\n  });\n}\n/**\n * @param {HTMLElement} bandElement\n *  HTML element for band\n * @param eventName\n *  Event name (plotly_hover or plotly_click)\n * @param event\n *  Mouse Event\n */\n\n\nfunction emitPointsEventColorHovermode(bandElement, eventName, event) {\n  var bandViewModel = d3.select(bandElement).datum();\n  var categoryModel = bandViewModel.categoryViewModel.model;\n  var gd = bandViewModel.parcatsViewModel.graphDiv;\n  var paths = selectPathsThroughCategoryBandColor(bandViewModel);\n  var points = [];\n  paths.each(function (pathViewModel) {\n    // Extend points array\n    Array.prototype.push.apply(points, buildPointsArrayForPath(pathViewModel));\n  });\n  var constraints = {};\n  constraints[categoryModel.dimensionInd] = categoryModel.categoryValue; // color\n\n  if (bandViewModel.rawColor !== undefined) {\n    constraints.color = bandViewModel.rawColor;\n  }\n\n  gd.emit(eventName, {\n    points: points,\n    event: event,\n    constraints: constraints\n  });\n}\n/**\n * Create hover label for a band element's category (for use when hoveron === 'category')\n *\n * @param {ClientRect} rootBBox\n *  Client bounding box for root of figure\n * @param {HTMLElement} bandElement\n *  HTML element for band\n *\n */\n\n\nfunction createHoverLabelForCategoryHovermode(rootBBox, bandElement) {\n  // Selections\n  var rectSelection = d3.select(bandElement.parentNode).select('rect.catrect');\n  var rectBoundingBox = rectSelection.node().getBoundingClientRect(); // Models\n\n  /** @type {CategoryViewModel} */\n\n  var catViewModel = rectSelection.datum();\n  var parcatsViewModel = catViewModel.parcatsViewModel;\n  var dimensionModel = parcatsViewModel.model.dimensions[catViewModel.model.dimensionInd];\n  var trace = parcatsViewModel.trace; // Positions\n\n  var hoverCenterY = rectBoundingBox.top + rectBoundingBox.height / 2;\n  var hoverCenterX, hoverLabelIdealAlign;\n\n  if (parcatsViewModel.dimensions.length > 1 && dimensionModel.displayInd === parcatsViewModel.dimensions.length - 1) {\n    // right most dimension\n    hoverCenterX = rectBoundingBox.left;\n    hoverLabelIdealAlign = 'left';\n  } else {\n    hoverCenterX = rectBoundingBox.left + rectBoundingBox.width;\n    hoverLabelIdealAlign = 'right';\n  }\n\n  var count = catViewModel.model.count;\n  var catLabel = catViewModel.model.categoryLabel;\n  var prob = count / catViewModel.parcatsViewModel.model.count;\n  var labels = {\n    countLabel: count,\n    categoryLabel: catLabel,\n    probabilityLabel: prob.toFixed(3)\n  }; // Hover label text\n\n  var hoverinfoParts = [];\n\n  if (catViewModel.parcatsViewModel.hoverinfoItems.indexOf('count') !== -1) {\n    hoverinfoParts.push(['Count:', labels.countLabel].join(' '));\n  }\n\n  if (catViewModel.parcatsViewModel.hoverinfoItems.indexOf('probability') !== -1) {\n    hoverinfoParts.push(['P(' + labels.categoryLabel + '):', labels.probabilityLabel].join(' '));\n  }\n\n  var hovertext = hoverinfoParts.join('<br>');\n  return {\n    trace: trace,\n    x: hoverCenterX - rootBBox.left,\n    y: hoverCenterY - rootBBox.top,\n    text: hovertext,\n    color: 'lightgray',\n    borderColor: 'black',\n    fontFamily: 'Monaco, \"Courier New\", monospace',\n    fontSize: 12,\n    fontColor: 'black',\n    idealAlign: hoverLabelIdealAlign,\n    hovertemplate: trace.hovertemplate,\n    hovertemplateLabels: labels,\n    eventData: [{\n      data: trace._input,\n      fullData: trace,\n      count: count,\n      category: catLabel,\n      probability: prob\n    }]\n  };\n}\n/**\n * Create hover label for a band element's category (for use when hoveron === 'category')\n *\n * @param {ClientRect} rootBBox\n *  Client bounding box for root of figure\n * @param {HTMLElement} bandElement\n *  HTML element for band\n *\n */\n\n\nfunction createHoverLabelForDimensionHovermode(rootBBox, bandElement) {\n  var allHoverlabels = [];\n  d3.select(bandElement.parentNode.parentNode).selectAll('g.category').select('rect.catrect').each(function () {\n    var bandNode = this;\n    allHoverlabels.push(createHoverLabelForCategoryHovermode(rootBBox, bandNode));\n  });\n  return allHoverlabels;\n}\n/**\n * Create hover labels for a band element's category (for use when hoveron === 'dimension')\n *\n * @param {ClientRect} rootBBox\n *  Client bounding box for root of figure\n * @param {HTMLElement} bandElement\n *  HTML element for band\n *\n */\n\n\nfunction createHoverLabelForColorHovermode(rootBBox, bandElement) {\n  var bandBoundingBox = bandElement.getBoundingClientRect(); // Models\n\n  /** @type {CategoryBandViewModel} */\n\n  var bandViewModel = d3.select(bandElement).datum();\n  var catViewModel = bandViewModel.categoryViewModel;\n  var parcatsViewModel = catViewModel.parcatsViewModel;\n  var dimensionModel = parcatsViewModel.model.dimensions[catViewModel.model.dimensionInd];\n  var trace = parcatsViewModel.trace; // positions\n\n  var hoverCenterY = bandBoundingBox.y + bandBoundingBox.height / 2;\n  var hoverCenterX, hoverLabelIdealAlign;\n\n  if (parcatsViewModel.dimensions.length > 1 && dimensionModel.displayInd === parcatsViewModel.dimensions.length - 1) {\n    // right most dimension\n    hoverCenterX = bandBoundingBox.left;\n    hoverLabelIdealAlign = 'left';\n  } else {\n    hoverCenterX = bandBoundingBox.left + bandBoundingBox.width;\n    hoverLabelIdealAlign = 'right';\n  } // Labels\n\n\n  var catLabel = catViewModel.model.categoryLabel; // Counts\n\n  var totalCount = bandViewModel.parcatsViewModel.model.count;\n  var bandColorCount = 0;\n  bandViewModel.categoryViewModel.bands.forEach(function (b) {\n    if (b.color === bandViewModel.color) {\n      bandColorCount += b.count;\n    }\n  });\n  var catCount = catViewModel.model.count;\n  var colorCount = 0;\n  parcatsViewModel.pathSelection.each(\n  /** @param {PathViewModel} pathViewModel */\n  function (pathViewModel) {\n    if (pathViewModel.model.color === bandViewModel.color) {\n      colorCount += pathViewModel.model.count;\n    }\n  });\n  var pColorAndCat = bandColorCount / totalCount;\n  var pCatGivenColor = bandColorCount / colorCount;\n  var pColorGivenCat = bandColorCount / catCount;\n  var labels = {\n    countLabel: totalCount,\n    categoryLabel: catLabel,\n    probabilityLabel: pColorAndCat.toFixed(3)\n  }; // Hover label text\n\n  var hoverinfoParts = [];\n\n  if (catViewModel.parcatsViewModel.hoverinfoItems.indexOf('count') !== -1) {\n    hoverinfoParts.push(['Count:', labels.countLabel].join(' '));\n  }\n\n  if (catViewModel.parcatsViewModel.hoverinfoItems.indexOf('probability') !== -1) {\n    hoverinfoParts.push('P(color âˆ© ' + catLabel + '): ' + labels.probabilityLabel);\n    hoverinfoParts.push('P(' + catLabel + ' | color): ' + pCatGivenColor.toFixed(3));\n    hoverinfoParts.push('P(color | ' + catLabel + '): ' + pColorGivenCat.toFixed(3));\n  }\n\n  var hovertext = hoverinfoParts.join('<br>'); // Compute text color\n\n  var textColor = tinycolor.mostReadable(bandViewModel.color, ['black', 'white']);\n  return {\n    trace: trace,\n    x: hoverCenterX - rootBBox.left,\n    y: hoverCenterY - rootBBox.top,\n    // name: 'NAME',\n    text: hovertext,\n    color: bandViewModel.color,\n    borderColor: 'black',\n    fontFamily: 'Monaco, \"Courier New\", monospace',\n    fontColor: textColor,\n    fontSize: 10,\n    idealAlign: hoverLabelIdealAlign,\n    hovertemplate: trace.hovertemplate,\n    hovertemplateLabels: labels,\n    eventData: [{\n      data: trace._input,\n      fullData: trace,\n      category: catLabel,\n      count: totalCount,\n      probability: pColorAndCat,\n      categorycount: catCount,\n      colorcount: colorCount,\n      bandcolorcount: bandColorCount\n    }]\n  };\n}\n/**\n * Handle dimension mouseover\n * @param {CategoryBandViewModel} bandViewModel\n */\n\n\nfunction mouseoverCategoryBand(bandViewModel) {\n  if (!bandViewModel.parcatsViewModel.dragDimension) {\n    // We're not currently dragging\n    if (bandViewModel.parcatsViewModel.hoverinfoItems.indexOf('skip') === -1) {\n      // hoverinfo is not skip, so we at least style the bands and emit interaction events\n      // Mouse\n      var mouseY = d3.mouse(this)[1];\n\n      if (mouseY < -1) {\n        // Hover is above above the category rectangle (probably the dimension title text)\n        return;\n      }\n\n      var gd = bandViewModel.parcatsViewModel.graphDiv;\n      var fullLayout = gd._fullLayout;\n\n      var rootBBox = fullLayout._paperdiv.node().getBoundingClientRect();\n\n      var hoveron = bandViewModel.parcatsViewModel.hoveron;\n      /** @type {HTMLElement} */\n\n      var bandElement = this; // Handle style and events\n\n      if (hoveron === 'color') {\n        styleForColorHovermode(bandElement);\n        emitPointsEventColorHovermode(bandElement, 'plotly_hover', d3.event);\n      } else {\n        styleForCategoryHovermode(bandElement);\n        emitPointsEventCategoryHovermode(bandElement, 'plotly_hover', d3.event);\n      } // Handle hover label\n\n\n      if (bandViewModel.parcatsViewModel.hoverinfoItems.indexOf('none') === -1) {\n        var hoverItems;\n\n        if (hoveron === 'category') {\n          hoverItems = createHoverLabelForCategoryHovermode(rootBBox, bandElement);\n        } else if (hoveron === 'color') {\n          hoverItems = createHoverLabelForColorHovermode(rootBBox, bandElement);\n        } else if (hoveron === 'dimension') {\n          hoverItems = createHoverLabelForDimensionHovermode(rootBBox, bandElement);\n        }\n\n        if (hoverItems) {\n          Fx.loneHover(hoverItems, {\n            container: fullLayout._hoverlayer.node(),\n            outerContainer: fullLayout._paper.node(),\n            gd: gd\n          });\n        }\n      }\n    }\n  }\n}\n/**\n * Handle dimension mouseover\n * @param {CategoryBandViewModel} bandViewModel\n */\n\n\nfunction mouseoutCategory(bandViewModel) {\n  var parcatsViewModel = bandViewModel.parcatsViewModel;\n\n  if (!parcatsViewModel.dragDimension) {\n    // We're not dragging anything\n    // Reset unhovered styles\n    stylePathsNoHover(parcatsViewModel.pathSelection);\n    styleCategoriesNoHover(parcatsViewModel.dimensionSelection.selectAll('g.category'));\n    styleBandsNoHover(parcatsViewModel.dimensionSelection.selectAll('g.category').selectAll('rect.bandrect')); // Remove hover label\n\n    Fx.loneUnhover(parcatsViewModel.graphDiv._fullLayout._hoverlayer.node()); // Restore path order\n\n    parcatsViewModel.pathSelection.sort(compareRawColor); // Emit unhover event\n\n    if (parcatsViewModel.hoverinfoItems.indexOf('skip') === -1) {\n      var hoveron = bandViewModel.parcatsViewModel.hoveron;\n      var bandElement = this; // Handle style and events\n\n      if (hoveron === 'color') {\n        emitPointsEventColorHovermode(bandElement, 'plotly_unhover', d3.event);\n      } else {\n        emitPointsEventCategoryHovermode(bandElement, 'plotly_unhover', d3.event);\n      }\n    }\n  }\n}\n/**\n * Handle dimension drag start\n * @param {DimensionViewModel} d\n */\n\n\nfunction dragDimensionStart(d) {\n  // Check if dragging is supported\n  if (d.parcatsViewModel.arrangement === 'fixed') {\n    return;\n  } // Save off initial drag indexes for dimension\n\n\n  d.dragDimensionDisplayInd = d.model.displayInd;\n  d.initialDragDimensionDisplayInds = d.parcatsViewModel.model.dimensions.map(function (d) {\n    return d.displayInd;\n  });\n  d.dragHasMoved = false; // Check for category hit\n\n  d.dragCategoryDisplayInd = null;\n  d3.select(this).selectAll('g.category').select('rect.catrect').each(\n  /** @param {CategoryViewModel} catViewModel */\n  function (catViewModel) {\n    var catMouseX = d3.mouse(this)[0];\n    var catMouseY = d3.mouse(this)[1];\n\n    if (-2 <= catMouseX && catMouseX <= catViewModel.width + 2 && -2 <= catMouseY && catMouseY <= catViewModel.height + 2) {\n      // Save off initial drag indexes for categories\n      d.dragCategoryDisplayInd = catViewModel.model.displayInd;\n      d.initialDragCategoryDisplayInds = d.model.categories.map(function (c) {\n        return c.displayInd;\n      }); // Initialize categories dragY to be the current y position\n\n      catViewModel.model.dragY = catViewModel.y; // Raise category\n\n      Lib.raiseToTop(this.parentNode); // Get band element\n\n      d3.select(this.parentNode).selectAll('rect.bandrect')\n      /** @param {CategoryBandViewModel} bandViewModel */\n      .each(function (bandViewModel) {\n        if (bandViewModel.y < catMouseY && catMouseY <= bandViewModel.y + bandViewModel.height) {\n          d.potentialClickBand = this;\n        }\n      });\n    }\n  }); // Update toplevel drag dimension\n\n  d.parcatsViewModel.dragDimension = d; // Remove hover label if any\n\n  Fx.loneUnhover(d.parcatsViewModel.graphDiv._fullLayout._hoverlayer.node());\n}\n/**\n * Handle dimension drag\n * @param {DimensionViewModel} d\n */\n\n\nfunction dragDimension(d) {\n  // Check if dragging is supported\n  if (d.parcatsViewModel.arrangement === 'fixed') {\n    return;\n  }\n\n  d.dragHasMoved = true;\n\n  if (d.dragDimensionDisplayInd === null) {\n    return;\n  }\n\n  var dragDimInd = d.dragDimensionDisplayInd;\n  var prevDimInd = dragDimInd - 1;\n  var nextDimInd = dragDimInd + 1;\n  var dragDimension = d.parcatsViewModel.dimensions[dragDimInd]; // Update category\n\n  if (d.dragCategoryDisplayInd !== null) {\n    var dragCategory = dragDimension.categories[d.dragCategoryDisplayInd]; // Update dragY by dy\n\n    dragCategory.model.dragY += d3.event.dy;\n    var categoryY = dragCategory.model.dragY; // Check for category drag swaps\n\n    var catDisplayInd = dragCategory.model.displayInd;\n    var dimCategoryViews = dragDimension.categories;\n    var catAbove = dimCategoryViews[catDisplayInd - 1];\n    var catBelow = dimCategoryViews[catDisplayInd + 1]; // Check for overlap above\n\n    if (catAbove !== undefined) {\n      if (categoryY < catAbove.y + catAbove.height / 2.0) {\n        // Swap display inds\n        dragCategory.model.displayInd = catAbove.model.displayInd;\n        catAbove.model.displayInd = catDisplayInd;\n      }\n    }\n\n    if (catBelow !== undefined) {\n      if (categoryY + dragCategory.height > catBelow.y + catBelow.height / 2.0) {\n        // Swap display inds\n        dragCategory.model.displayInd = catBelow.model.displayInd;\n        catBelow.model.displayInd = catDisplayInd;\n      }\n    } // Update category drag display index\n\n\n    d.dragCategoryDisplayInd = dragCategory.model.displayInd;\n  } // Update dimension position\n\n\n  if (d.dragCategoryDisplayInd === null || d.parcatsViewModel.arrangement === 'freeform') {\n    dragDimension.model.dragX = d3.event.x; // Check for dimension swaps\n\n    var prevDimension = d.parcatsViewModel.dimensions[prevDimInd];\n    var nextDimension = d.parcatsViewModel.dimensions[nextDimInd];\n\n    if (prevDimension !== undefined) {\n      if (dragDimension.model.dragX < prevDimension.x + prevDimension.width) {\n        // Swap display inds\n        dragDimension.model.displayInd = prevDimension.model.displayInd;\n        prevDimension.model.displayInd = dragDimInd;\n      }\n    }\n\n    if (nextDimension !== undefined) {\n      if (dragDimension.model.dragX + dragDimension.width > nextDimension.x) {\n        // Swap display inds\n        dragDimension.model.displayInd = nextDimension.model.displayInd;\n        nextDimension.model.displayInd = d.dragDimensionDisplayInd;\n      }\n    } // Update drag display index\n\n\n    d.dragDimensionDisplayInd = dragDimension.model.displayInd;\n  } // Update view models\n\n\n  updateDimensionViewModels(d.parcatsViewModel);\n  updatePathViewModels(d.parcatsViewModel); // Update svg geometry\n\n  updateSvgCategories(d.parcatsViewModel);\n  updateSvgPaths(d.parcatsViewModel);\n}\n/**\n * Handle dimension drag end\n * @param {DimensionViewModel} d\n */\n\n\nfunction dragDimensionEnd(d) {\n  // Check if dragging is supported\n  if (d.parcatsViewModel.arrangement === 'fixed') {\n    return;\n  }\n\n  if (d.dragDimensionDisplayInd === null) {\n    return;\n  }\n\n  d3.select(this).selectAll('text').attr('font-weight', 'normal'); // Compute restyle command\n  // -----------------------\n\n  var restyleData = {};\n  var traceInd = getTraceIndex(d.parcatsViewModel); // ### Handle dimension reordering ###\n\n  var finalDragDimensionDisplayInds = d.parcatsViewModel.model.dimensions.map(function (d) {\n    return d.displayInd;\n  });\n  var anyDimsReordered = d.initialDragDimensionDisplayInds.some(function (initDimDisplay, dimInd) {\n    return initDimDisplay !== finalDragDimensionDisplayInds[dimInd];\n  });\n\n  if (anyDimsReordered) {\n    finalDragDimensionDisplayInds.forEach(function (finalDimDisplay, dimInd) {\n      var containerInd = d.parcatsViewModel.model.dimensions[dimInd].containerInd;\n      restyleData['dimensions[' + containerInd + '].displayindex'] = finalDimDisplay;\n    });\n  } // ### Handle category reordering ###\n\n\n  var anyCatsReordered = false;\n\n  if (d.dragCategoryDisplayInd !== null) {\n    var finalDragCategoryDisplayInds = d.model.categories.map(function (c) {\n      return c.displayInd;\n    });\n    anyCatsReordered = d.initialDragCategoryDisplayInds.some(function (initCatDisplay, catInd) {\n      return initCatDisplay !== finalDragCategoryDisplayInds[catInd];\n    });\n\n    if (anyCatsReordered) {\n      // Sort a shallow copy of the category models by display index\n      var sortedCategoryModels = d.model.categories.slice().sort(function (a, b) {\n        return a.displayInd - b.displayInd;\n      }); // Get new categoryarray and ticktext values\n\n      var newCategoryArray = sortedCategoryModels.map(function (v) {\n        return v.categoryValue;\n      });\n      var newCategoryLabels = sortedCategoryModels.map(function (v) {\n        return v.categoryLabel;\n      });\n      restyleData['dimensions[' + d.model.containerInd + '].categoryarray'] = [newCategoryArray];\n      restyleData['dimensions[' + d.model.containerInd + '].ticktext'] = [newCategoryLabels];\n      restyleData['dimensions[' + d.model.containerInd + '].categoryorder'] = 'array';\n    }\n  } // Handle potential click event\n  // ----------------------------\n\n\n  if (d.parcatsViewModel.hoverinfoItems.indexOf('skip') === -1) {\n    if (!d.dragHasMoved && d.potentialClickBand) {\n      if (d.parcatsViewModel.hoveron === 'color') {\n        emitPointsEventColorHovermode(d.potentialClickBand, 'plotly_click', d3.event.sourceEvent);\n      } else {\n        emitPointsEventCategoryHovermode(d.potentialClickBand, 'plotly_click', d3.event.sourceEvent);\n      }\n    }\n  } // Nullify drag states\n  // -------------------\n\n\n  d.model.dragX = null;\n\n  if (d.dragCategoryDisplayInd !== null) {\n    var dragCategory = d.parcatsViewModel.dimensions[d.dragDimensionDisplayInd].categories[d.dragCategoryDisplayInd];\n    dragCategory.model.dragY = null;\n    d.dragCategoryDisplayInd = null;\n  }\n\n  d.dragDimensionDisplayInd = null;\n  d.parcatsViewModel.dragDimension = null;\n  d.dragHasMoved = null;\n  d.potentialClickBand = null; // Update view models\n  // ------------------\n\n  updateDimensionViewModels(d.parcatsViewModel);\n  updatePathViewModels(d.parcatsViewModel); // Perform transition\n  // ------------------\n\n  var transition = d3.transition().duration(300).ease('cubic-in-out');\n  transition.each(function () {\n    updateSvgCategories(d.parcatsViewModel, true);\n    updateSvgPaths(d.parcatsViewModel, true);\n  }).each('end', function () {\n    if (anyDimsReordered || anyCatsReordered) {\n      // Perform restyle if the order of categories or dimensions changed\n      Plotly.restyle(d.parcatsViewModel.graphDiv, restyleData, [traceInd]);\n    }\n  });\n}\n/**\n *\n * @param {ParcatsViewModel} parcatsViewModel\n */\n\n\nfunction getTraceIndex(parcatsViewModel) {\n  var traceInd;\n  var allTraces = parcatsViewModel.graphDiv._fullData;\n\n  for (var i = 0; i < allTraces.length; i++) {\n    if (parcatsViewModel.key === allTraces[i].uid) {\n      traceInd = i;\n      break;\n    }\n  }\n\n  return traceInd;\n}\n/** Update the svg paths for view model\n * @param {ParcatsViewModel} parcatsViewModel\n * @param {boolean} hasTransition Whether to update element with transition\n */\n\n\nfunction updateSvgPaths(parcatsViewModel, hasTransition) {\n  if (hasTransition === undefined) {\n    hasTransition = false;\n  }\n\n  function transition(selection) {\n    return hasTransition ? selection.transition() : selection;\n  } // Update binding\n\n\n  parcatsViewModel.pathSelection.data(function (d) {\n    return d.paths;\n  }, key); // Update paths\n\n  transition(parcatsViewModel.pathSelection).attr('d', function (d) {\n    return d.svgD;\n  });\n}\n/** Update the svg paths for view model\n * @param {ParcatsViewModel} parcatsViewModel\n * @param {boolean} hasTransition Whether to update element with transition\n */\n\n\nfunction updateSvgCategories(parcatsViewModel, hasTransition) {\n  if (hasTransition === undefined) {\n    hasTransition = false;\n  }\n\n  function transition(selection) {\n    return hasTransition ? selection.transition() : selection;\n  } // Update binding\n\n\n  parcatsViewModel.dimensionSelection.data(function (d) {\n    return d.dimensions;\n  }, key);\n  var categorySelection = parcatsViewModel.dimensionSelection.selectAll('g.category').data(function (d) {\n    return d.categories;\n  }, key); // Update dimension position\n\n  transition(parcatsViewModel.dimensionSelection).attr('transform', function (d) {\n    return 'translate(' + d.x + ', 0)';\n  }); // Update category position\n\n  transition(categorySelection).attr('transform', function (d) {\n    return 'translate(0, ' + d.y + ')';\n  });\n  var dimLabelSelection = categorySelection.select('.dimlabel'); // ### Update dimension label\n  // Only the top-most display category should have the dimension label\n\n  dimLabelSelection.text(function (d, i) {\n    if (i === 0) {\n      // Add dimension label above topmost category\n      return d.parcatsViewModel.model.dimensions[d.model.dimensionInd].dimensionLabel;\n    } else {\n      return null;\n    }\n  }); // Update category label\n  // Categories in the right-most display dimension have their labels on\n  // the right, all others on the left\n\n  var catLabelSelection = categorySelection.select('.catlabel');\n  catLabelSelection.attr('text-anchor', function (d) {\n    if (catInRightDim(d)) {\n      // Place label to the right of category\n      return 'start';\n    } else {\n      // Place label to the left of category\n      return 'end';\n    }\n  }).attr('x', function (d) {\n    if (catInRightDim(d)) {\n      // Place label to the right of category\n      return d.width + 5;\n    } else {\n      // Place label to the left of category\n      return -5;\n    }\n  }).each(function (d) {\n    // Update attriubutes of <tspan> elements\n    var newX;\n    var newAnchor;\n\n    if (catInRightDim(d)) {\n      // Place label to the right of category\n      newX = d.width + 5;\n      newAnchor = 'start';\n    } else {\n      // Place label to the left of category\n      newX = -5;\n      newAnchor = 'end';\n    }\n\n    d3.select(this).selectAll('tspan').attr('x', newX).attr('text-anchor', newAnchor);\n  }); // Update bands\n  // Initialize color band rects\n\n  var bandSelection = categorySelection.selectAll('rect.bandrect').data(\n  /** @param {CategoryViewModel} catViewModel*/\n  function (catViewModel) {\n    return catViewModel.bands;\n  }, key);\n  var bandsSelectionEnter = bandSelection.enter().append('rect').attr('class', 'bandrect').attr('cursor', 'move').attr('stroke-opacity', 0).attr('fill', function (d) {\n    return d.color;\n  }).attr('fill-opacity', 0);\n  bandSelection.attr('fill', function (d) {\n    return d.color;\n  }).attr('width', function (d) {\n    return d.width;\n  }).attr('height', function (d) {\n    return d.height;\n  }).attr('y', function (d) {\n    return d.y;\n  });\n  styleBandsNoHover(bandsSelectionEnter); // Raise bands to the top\n\n  bandSelection.each(function () {\n    Lib.raiseToTop(this);\n  }); // Remove unused bands\n\n  bandSelection.exit().remove();\n}\n/**\n * Create a ParcatsViewModel traces\n * @param {Object} graphDiv\n *  Top-level graph div element\n * @param {Layout} layout\n *  SVG layout object\n * @param {Array.<ParcatsModel>} wrappedParcatsModel\n *  Wrapped ParcatsModel for this trace\n * @return {ParcatsViewModel}\n */\n\n\nfunction createParcatsViewModel(graphDiv, layout, wrappedParcatsModel) {\n  // Unwrap model\n  var parcatsModel = wrappedParcatsModel[0]; // Compute margin\n\n  var margin = layout.margin || {\n    l: 80,\n    r: 80,\n    t: 100,\n    b: 80\n  }; // Compute pixel position/extents\n\n  var trace = parcatsModel.trace;\n  var domain = trace.domain;\n  var figureWidth = layout.width;\n  var figureHeight = layout.height;\n  var traceWidth = Math.floor(figureWidth * (domain.x[1] - domain.x[0]));\n  var traceHeight = Math.floor(figureHeight * (domain.y[1] - domain.y[0]));\n  var traceX = domain.x[0] * figureWidth + margin.l;\n  var traceY = layout.height - domain.y[1] * layout.height + margin.t; // Handle path shape\n  // -----------------\n\n  var pathShape = trace.line.shape; // Handle hover info\n  // -----------------\n\n  var hoverinfoItems;\n\n  if (trace.hoverinfo === 'all') {\n    hoverinfoItems = ['count', 'probability'];\n  } else {\n    hoverinfoItems = (trace.hoverinfo || '').split('+');\n  } // Construct parcatsViewModel\n  // --------------------------\n\n\n  var parcatsViewModel = {\n    trace: trace,\n    key: trace.uid,\n    model: parcatsModel,\n    x: traceX,\n    y: traceY,\n    width: traceWidth,\n    height: traceHeight,\n    hoveron: trace.hoveron,\n    hoverinfoItems: hoverinfoItems,\n    arrangement: trace.arrangement,\n    bundlecolors: trace.bundlecolors,\n    sortpaths: trace.sortpaths,\n    labelfont: trace.labelfont,\n    categorylabelfont: trace.tickfont,\n    pathShape: pathShape,\n    dragDimension: null,\n    margin: margin,\n    paths: [],\n    dimensions: [],\n    graphDiv: graphDiv,\n    traceSelection: null,\n    pathSelection: null,\n    dimensionSelection: null\n  }; // Update dimension view models if we have at least 1 dimension\n\n  if (parcatsModel.dimensions) {\n    updateDimensionViewModels(parcatsViewModel); // Update path view models if we have at least 2 dimensions\n\n    updatePathViewModels(parcatsViewModel);\n  } // Inside a categories view model\n\n\n  return parcatsViewModel;\n}\n/**\n * Build the SVG string to represents a parallel categories path\n * @param {Array.<Number>} leftXPositions\n *  Array of the x positions of the left edge of each dimension (in display order)\n * @param {Array.<Number>} pathYs\n *  Array of the y positions of the top of the path at each dimension (in display order)\n * @param {Array.<Number>} dimWidths\n *  Array of the widths of each dimension in display order\n * @param {Number} pathHeight\n *  The height of the path in pixels\n * @param {Number} curvature\n *  The curvature factor for the path. 0 results in a straight line and values greater than zero result in curved paths\n * @return {string}\n */\n\n\nfunction buildSvgPath(leftXPositions, pathYs, dimWidths, pathHeight, curvature) {\n  // Compute the x midpoint of each path segment\n  var xRefPoints1 = [];\n  var xRefPoints2 = [];\n  var refInterpolator;\n  var d;\n\n  for (d = 0; d < dimWidths.length - 1; d++) {\n    refInterpolator = d3.interpolateNumber(dimWidths[d] + leftXPositions[d], leftXPositions[d + 1]);\n    xRefPoints1.push(refInterpolator(curvature));\n    xRefPoints2.push(refInterpolator(1 - curvature));\n  } // Move to top of path on left edge of left-most category\n\n\n  var svgD = 'M ' + leftXPositions[0] + ',' + pathYs[0]; // Horizontal line to right edge\n\n  svgD += 'l' + dimWidths[0] + ',0 '; // Horizontal line to right edge\n\n  for (d = 1; d < dimWidths.length; d++) {\n    // Curve to left edge of category\n    svgD += 'C' + xRefPoints1[d - 1] + ',' + pathYs[d - 1] + ' ' + xRefPoints2[d - 1] + ',' + pathYs[d] + ' ' + leftXPositions[d] + ',' + pathYs[d]; // svgD += 'L' + leftXPositions[d] + ',' + pathYs[d];\n    // Horizontal line to right edge\n\n    svgD += 'l' + dimWidths[d] + ',0 ';\n  } // Line down\n\n\n  svgD += 'l' + '0,' + pathHeight + ' '; // Line to left edge of right-most category\n\n  svgD += 'l -' + dimWidths[dimWidths.length - 1] + ',0 ';\n\n  for (d = dimWidths.length - 2; d >= 0; d--) {\n    // Curve to right edge of category\n    svgD += 'C' + xRefPoints2[d] + ',' + (pathYs[d + 1] + pathHeight) + ' ' + xRefPoints1[d] + ',' + (pathYs[d] + pathHeight) + ' ' + (leftXPositions[d] + dimWidths[d]) + ',' + (pathYs[d] + pathHeight); // svgD += 'L' + (leftXPositions[d] + dimWidths[d]) + ',' + (pathYs[d] + pathHeight);\n    // Horizontal line to right edge\n\n    svgD += 'l-' + dimWidths[d] + ',0 ';\n  } // Close path\n\n\n  svgD += 'Z';\n  return svgD;\n}\n/**\n * Update the path view models based on the dimension view models in a ParcatsViewModel\n *\n * @param {ParcatsViewModel} parcatsViewModel\n *  View model for trace\n */\n\n\nfunction updatePathViewModels(parcatsViewModel) {\n  // Initialize an array of the y position of the top of the next path to be added to each category.\n  //\n  // nextYPositions[d][c] is the y position of the next path through category with index c of dimension with index d\n  var dimensionViewModels = parcatsViewModel.dimensions;\n  var parcatsModel = parcatsViewModel.model;\n  var nextYPositions = dimensionViewModels.map(function (d) {\n    return d.categories.map(function (c) {\n      return c.y;\n    });\n  }); // Array from category index to category display index for each true dimension index\n\n  var catToDisplayIndPerDim = parcatsViewModel.model.dimensions.map(function (d) {\n    return d.categories.map(function (c) {\n      return c.displayInd;\n    });\n  }); // Array from true dimension index to dimension display index\n\n  var dimToDisplayInd = parcatsViewModel.model.dimensions.map(function (d) {\n    return d.displayInd;\n  });\n  var displayToDimInd = parcatsViewModel.dimensions.map(function (d) {\n    return d.model.dimensionInd;\n  }); // Array of the x position of the left edge of the rectangles for each dimension\n\n  var leftXPositions = dimensionViewModels.map(function (d) {\n    return d.x;\n  }); // Compute dimension widths\n\n  var dimWidths = dimensionViewModels.map(function (d) {\n    return d.width;\n  }); // Build sorted Array of PathModel objects\n\n  var pathModels = [];\n\n  for (var p in parcatsModel.paths) {\n    if (parcatsModel.paths.hasOwnProperty(p)) {\n      pathModels.push(parcatsModel.paths[p]);\n    }\n  } // Compute category display inds to use for sorting paths\n\n\n  function pathDisplayCategoryInds(pathModel) {\n    var dimensionInds = pathModel.categoryInds.map(function (catInd, dimInd) {\n      return catToDisplayIndPerDim[dimInd][catInd];\n    });\n    var displayInds = displayToDimInd.map(function (dimInd) {\n      return dimensionInds[dimInd];\n    });\n    return displayInds;\n  } // Sort in ascending order by display index array\n\n\n  pathModels.sort(function (v1, v2) {\n    // Build display inds for each path\n    var sortArray1 = pathDisplayCategoryInds(v1);\n    var sortArray2 = pathDisplayCategoryInds(v2); // Handle path sort order\n\n    if (parcatsViewModel.sortpaths === 'backward') {\n      sortArray1.reverse();\n      sortArray2.reverse();\n    } // Append the first value index of the path to break ties\n\n\n    sortArray1.push(v1.valueInds[0]);\n    sortArray2.push(v2.valueInds[0]); // Handle color bundling\n\n    if (parcatsViewModel.bundlecolors) {\n      // Prepend sort array with the raw color value\n      sortArray1.unshift(v1.rawColor);\n      sortArray2.unshift(v2.rawColor);\n    } // colors equal, sort by display categories\n\n\n    if (sortArray1 < sortArray2) {\n      return -1;\n    }\n\n    if (sortArray1 > sortArray2) {\n      return 1;\n    }\n\n    return 0;\n  }); // Create path models\n\n  var pathViewModels = new Array(pathModels.length);\n  var totalCount = dimensionViewModels[0].model.count;\n  var totalHeight = dimensionViewModels[0].categories.map(function (c) {\n    return c.height;\n  }).reduce(function (v1, v2) {\n    return v1 + v2;\n  });\n\n  for (var pathNumber = 0; pathNumber < pathModels.length; pathNumber++) {\n    var pathModel = pathModels[pathNumber];\n    var pathHeight;\n\n    if (totalCount > 0) {\n      pathHeight = totalHeight * (pathModel.count / totalCount);\n    } else {\n      pathHeight = 0;\n    } // Build path y coords\n\n\n    var pathYs = new Array(nextYPositions.length);\n\n    for (var d = 0; d < pathModel.categoryInds.length; d++) {\n      var catInd = pathModel.categoryInds[d];\n      var catDisplayInd = catToDisplayIndPerDim[d][catInd];\n      var dimDisplayInd = dimToDisplayInd[d]; // Update next y position\n\n      pathYs[dimDisplayInd] = nextYPositions[dimDisplayInd][catDisplayInd];\n      nextYPositions[dimDisplayInd][catDisplayInd] += pathHeight; // Update category color information\n\n      var catViewModle = parcatsViewModel.dimensions[dimDisplayInd].categories[catDisplayInd];\n      var numBands = catViewModle.bands.length;\n      var lastCatBand = catViewModle.bands[numBands - 1];\n\n      if (lastCatBand === undefined || pathModel.rawColor !== lastCatBand.rawColor) {\n        // Create a new band\n        var bandY = lastCatBand === undefined ? 0 : lastCatBand.y + lastCatBand.height;\n        catViewModle.bands.push({\n          key: bandY,\n          color: pathModel.color,\n          rawColor: pathModel.rawColor,\n          height: pathHeight,\n          width: catViewModle.width,\n          count: pathModel.count,\n          y: bandY,\n          categoryViewModel: catViewModle,\n          parcatsViewModel: parcatsViewModel\n        });\n      } else {\n        // Extend current band\n        var currentBand = catViewModle.bands[numBands - 1];\n        currentBand.height += pathHeight;\n        currentBand.count += pathModel.count;\n      }\n    } // build svg path\n\n\n    var svgD;\n\n    if (parcatsViewModel.pathShape === 'hspline') {\n      svgD = buildSvgPath(leftXPositions, pathYs, dimWidths, pathHeight, 0.5);\n    } else {\n      svgD = buildSvgPath(leftXPositions, pathYs, dimWidths, pathHeight, 0);\n    }\n\n    pathViewModels[pathNumber] = {\n      key: pathModel.valueInds[0],\n      model: pathModel,\n      height: pathHeight,\n      leftXs: leftXPositions,\n      topYs: pathYs,\n      dimWidths: dimWidths,\n      svgD: svgD,\n      parcatsViewModel: parcatsViewModel\n    };\n  }\n\n  parcatsViewModel.paths = pathViewModels; // * @property key\n  // *  Unique key for this model\n  // * @property {PathModel} model\n  // *  Source path model\n  // * @property {Number} height\n  // *  Height of this path (pixels)\n  // * @property {String} svgD\n  // *  SVG path \"d\" attribute string\n}\n/**\n * Update the dimension view models based on the dimension models in a ParcatsViewModel\n *\n * @param {ParcatsViewModel} parcatsViewModel\n *  View model for trace\n */\n\n\nfunction updateDimensionViewModels(parcatsViewModel) {\n  // Compute dimension ordering\n  var dimensionsIndInfo = parcatsViewModel.model.dimensions.map(function (d) {\n    return {\n      displayInd: d.displayInd,\n      dimensionInd: d.dimensionInd\n    };\n  });\n  dimensionsIndInfo.sort(function (a, b) {\n    return a.displayInd - b.displayInd;\n  });\n  var dimensions = [];\n\n  for (var displayInd in dimensionsIndInfo) {\n    var dimensionInd = dimensionsIndInfo[displayInd].dimensionInd;\n    var dimModel = parcatsViewModel.model.dimensions[dimensionInd];\n    dimensions.push(createDimensionViewModel(parcatsViewModel, dimModel));\n  }\n\n  parcatsViewModel.dimensions = dimensions;\n}\n/**\n * Create a parcats DimensionViewModel\n *\n * @param {ParcatsViewModel} parcatsViewModel\n *  View model for trace\n * @param {DimensionModel} dimensionModel\n * @return {DimensionViewModel}\n */\n\n\nfunction createDimensionViewModel(parcatsViewModel, dimensionModel) {\n  // Compute dimension x position\n  var categoryLabelPad = 40;\n  var dimWidth = 16;\n  var numDimensions = parcatsViewModel.model.dimensions.length;\n  var displayInd = dimensionModel.displayInd; // Compute x coordinate values\n\n  var dimDx;\n  var dimX0;\n  var dimX;\n\n  if (numDimensions > 1) {\n    dimDx = (parcatsViewModel.width - 2 * categoryLabelPad - dimWidth) / (numDimensions - 1);\n  } else {\n    dimDx = 0;\n  }\n\n  dimX0 = categoryLabelPad;\n  dimX = dimX0 + dimDx * displayInd; // Compute categories\n\n  var categories = [];\n  var maxCats = parcatsViewModel.model.maxCats;\n  var numCats = dimensionModel.categories.length;\n  var catSpacing = 8;\n  var totalCount = dimensionModel.count;\n  var totalHeight = parcatsViewModel.height - catSpacing * (maxCats - 1);\n  var nextCatHeight;\n  var nextCatModel;\n  var nextCat;\n  var catInd;\n  var catDisplayInd; // Compute starting Y offset\n\n  var nextCatY = (maxCats - numCats) * catSpacing / 2.0; // Compute category ordering\n\n  var categoryIndInfo = dimensionModel.categories.map(function (c) {\n    return {\n      displayInd: c.displayInd,\n      categoryInd: c.categoryInd\n    };\n  });\n  categoryIndInfo.sort(function (a, b) {\n    return a.displayInd - b.displayInd;\n  });\n\n  for (catDisplayInd = 0; catDisplayInd < numCats; catDisplayInd++) {\n    catInd = categoryIndInfo[catDisplayInd].categoryInd;\n    nextCatModel = dimensionModel.categories[catInd];\n\n    if (totalCount > 0) {\n      nextCatHeight = nextCatModel.count / totalCount * totalHeight;\n    } else {\n      nextCatHeight = 0;\n    }\n\n    nextCat = {\n      key: nextCatModel.valueInds[0],\n      model: nextCatModel,\n      width: dimWidth,\n      height: nextCatHeight,\n      y: nextCatModel.dragY !== null ? nextCatModel.dragY : nextCatY,\n      bands: [],\n      parcatsViewModel: parcatsViewModel\n    };\n    nextCatY = nextCatY + nextCatHeight + catSpacing;\n    categories.push(nextCat);\n  }\n\n  return {\n    key: dimensionModel.dimensionInd,\n    x: dimensionModel.dragX !== null ? dimensionModel.dragX : dimX,\n    y: 0,\n    width: dimWidth,\n    model: dimensionModel,\n    categories: categories,\n    parcatsViewModel: parcatsViewModel,\n    dragCategoryDisplayInd: null,\n    dragDimensionDisplayInd: null,\n    initialDragDimensionDisplayInds: null,\n    initialDragCategoryDisplayInds: null,\n    dragHasMoved: null,\n    potentialClickBand: null\n  };\n} // JSDoc typedefs\n// ==============\n\n/**\n * @typedef {Object} Layout\n *  Object containing svg layout information\n *\n * @property {Number} width (pixels)\n *  Usable width for Figure (after margins are removed)\n * @property {Number} height (pixels)\n *  Usable height for Figure (after margins are removed)\n * @property {Margin} margin\n *  Margin around the Figure (pixels)\n */\n\n/**\n * @typedef {Object} Margin\n *  Object containing padding information in pixels\n *\n * @property {Number} t\n *  Top margin\n * @property {Number} r\n *  Right margin\n * @property {Number} b\n *  Bottom margin\n * @property {Number} l\n *  Left margin\n */\n\n/**\n * @typedef {Object} Font\n *  Object containing font information\n *\n * @property {Number} size: Font size\n * @property {String} color: Font color\n * @property {String} family: Font family\n */\n\n/**\n * @typedef {Object} ParcatsViewModel\n *  Object containing calculated parcats view information\n *\n *  These are quantities that require Layout information to calculate\n * @property key\n *  Unique key for this model\n * @property {ParcatsModel} model\n *  Source parcats model\n * @property {Array.<DimensionViewModel>} dimensions\n *  Array of dimension view models\n * @property {Number} width\n *  Width for this trace (pixels)\n * @property {Number} height\n *  Height for this trace (pixels)\n * @property {Number} x\n *  X position of this trace with respect to the Figure (pixels)\n * @property {Number} y\n *  Y position of this trace with respect to the Figure (pixels)\n * @property {String} hoveron\n *  Hover interaction mode. One of: 'category', 'color', or 'dimension'\n * @property {Array.<String>} hoverinfoItems\n *  Info to display on hover. Array with a combination of 'counts' and/or 'probabilities', or 'none', or 'skip'\n * @property {String} arrangement\n *  Category arrangement. One of: 'perpendicular', 'freeform', or 'fixed'\n * @property {Boolean} bundlecolors\n *  Whether paths should be sorted so that like colors are bundled together as they pass through categories\n * @property {String} sortpaths\n *  If 'forward' then sort paths based on dimensions from left to right. If 'backward' sort based on dimensions\n *  from right to left\n * @property {Font} labelfont\n *  Font for the dimension labels\n * @property {Font} categorylabelfont\n *  Font for the category labels\n * @property {String} pathShape\n *  The shape of the paths. Either 'linear' or 'hspline'.\n * @property {DimensionViewModel|null} dragDimension\n *  Dimension currently being dragged. Null if no drag in progress\n * @property {Margin} margin\n *  Margin around the Figure\n * @property {Object} graphDiv\n *  Top-level graph div element\n * @property {Object} traceSelection\n *  D3 selection of this view models trace group element\n * @property {Object} pathSelection\n *  D3 selection of this view models path elements\n * @property {Object} dimensionSelection\n *  D3 selection of this view models dimension group element\n */\n\n/**\n * @typedef {Object} DimensionViewModel\n *  Object containing calculated parcats dimension view information\n *\n *  These are quantities that require Layout information to calculate\n * @property key\n *  Unique key for this model\n * @property {DimensionModel} model\n *  Source dimension model\n * @property {Number} x\n *  X position of the center of this dimension with respect to the Figure (pixels)\n * @property {Number} y\n *  Y position of the top of this dimension with respect to the Figure (pixels)\n * @property {Number} width\n *  Width of categories in this dimension (pixels)\n * @property {ParcatsViewModel} parcatsViewModel\n *  The parent trace's view model\n * @property {Array.<CategoryViewModel>} categories\n *  Dimensions category view models\n * @property {Number|null} dragCategoryDisplayInd\n *  Display index of category currently being dragged. null if no category is being dragged\n * @property {Number|null} dragDimensionDisplayInd\n *  Display index of the dimension being dragged. null if no dimension is being dragged\n * @property {Array.<Number>|null} initialDragDimensionDisplayInds\n *  Dimensions display indexes at the beginning of the current drag. null if no dimension is being dragged\n * @property {Array.<Number>|null} initialDragCategoryDisplayInds\n *  Category display indexes for the at the beginning of the current drag. null if no category is being dragged\n * @property {HTMLElement} potentialClickBand\n *  Band under mouse when current drag began. If no drag movement takes place then a click will be emitted for this\n *  band. Null if not drag in progress.\n * @property {Boolean} dragHasMoved\n *  True if there is an active drag and the drag has moved. If drag doesn't move before being ended then\n *  this may be interpreted as a click. Null if no drag in progress\n */\n\n/**\n * @typedef {Object} CategoryViewModel\n *  Object containing calculated parcats category view information\n *\n *  These are quantities that require Layout information to calculate\n * @property key\n *  Unique key for this model\n * @property {CategoryModel} model\n *  Source category model\n * @property {Number} width\n *  Width for this category (pixels)\n * @property {Number} height\n *  Height for this category (pixels)\n * @property {Number} y\n *  Y position of this cateogry with respect to the Figure (pixels)\n * @property {Array.<CategoryBandViewModel>} bands\n *  Array of color bands inside the category\n * @property {ParcatsViewModel} parcatsViewModel\n *  The parent trace's view model\n */\n\n/**\n * @typedef {Object} CategoryBandViewModel\n *  Object containing calculated category band information. A category band is a region inside a category covering\n *  paths of a single color\n *\n * @property key\n *  Unique key for this model\n * @property color\n *  Band color\n * @property rawColor\n *  Raw color value for band\n * @property {Number} width\n *  Band width\n * @property {Number} height\n *  Band height\n * @property {Number} y\n *  Y position of top of the band with respect to the category\n * @property {Number} count\n *  The number of samples represented by the band\n * @property {CategoryViewModel} categoryViewModel\n *  The parent categorie's view model\n * @property {ParcatsViewModel} parcatsViewModel\n *  The parent trace's view model\n */\n\n/**\n * @typedef {Object} PathViewModel\n *  Object containing calculated parcats path view information\n *\n *  These are quantities that require Layout information to calculate\n * @property key\n *  Unique key for this model\n * @property {PathModel} model\n *  Source path model\n * @property {Number} height\n *  Height of this path (pixels)\n * @property {Array.<Number>} leftXs\n *  The x position of the left edge of each display dimension\n * @property {Array.<Number>} topYs\n *  The y position of the top of the path for each display dimension\n * @property {Array.<Number>} dimWidths\n *  The width of each display dimension\n * @property {String} svgD\n *  SVG path \"d\" attribute string\n * @property {ParcatsViewModel} parcatsViewModel\n *  The parent trace's view model\n */","map":null,"metadata":{},"sourceType":"script"}