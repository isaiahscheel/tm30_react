{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar Registry = require('../../registry');\n\nvar handleXYDefaults = require('../scatter/xy_defaults');\n\nvar handleStyleDefaults = require('./style_defaults');\n\nvar getAxisGroup = require('../../plots/cartesian/axis_ids').getAxisGroup;\n\nvar attributes = require('./attributes');\n\nvar coerceFont = Lib.coerceFont;\n\nfunction supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n  }\n\n  var len = handleXYDefaults(traceIn, traceOut, layout, coerce);\n\n  if (!len) {\n    traceOut.visible = false;\n    return;\n  }\n\n  coerce('orientation', traceOut.x && !traceOut.y ? 'h' : 'v');\n  coerce('base');\n  coerce('offset');\n  coerce('width');\n  coerce('text');\n  coerce('hovertext');\n  coerce('hovertemplate');\n  var textposition = coerce('textposition');\n  handleText(traceIn, traceOut, layout, coerce, textposition, {\n    moduleHasSelected: true,\n    moduleHasUnselected: true,\n    moduleHasConstrain: true,\n    moduleHasCliponaxis: true,\n    moduleHasTextangle: true,\n    moduleHasInsideanchor: true\n  });\n  handleStyleDefaults(traceIn, traceOut, coerce, defaultColor, layout);\n  var lineColor = (traceOut.marker.line || {}).color; // override defaultColor for error bars with defaultLine\n\n  var errorBarsSupplyDefaults = Registry.getComponentMethod('errorbars', 'supplyDefaults');\n  errorBarsSupplyDefaults(traceIn, traceOut, lineColor || Color.defaultLine, {\n    axis: 'y'\n  });\n  errorBarsSupplyDefaults(traceIn, traceOut, lineColor || Color.defaultLine, {\n    axis: 'x',\n    inherit: 'y'\n  });\n  Lib.coerceSelectionMarkerOpacity(traceOut, coerce);\n}\n\nfunction handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce) {\n  var orientation = traceOut.orientation; // N.B. grouping is done across all trace types that support it\n\n  var posAxId = traceOut[{\n    v: 'x',\n    h: 'y'\n  }[orientation] + 'axis'];\n  var groupId = getAxisGroup(fullLayout, posAxId) + orientation;\n  var alignmentOpts = fullLayout._alignmentOpts || {};\n  var alignmentgroup = coerce('alignmentgroup');\n  var alignmentGroups = alignmentOpts[groupId];\n  if (!alignmentGroups) alignmentGroups = alignmentOpts[groupId] = {};\n  var alignmentGroupOpts = alignmentGroups[alignmentgroup];\n\n  if (alignmentGroupOpts) {\n    alignmentGroupOpts.traces.push(traceOut);\n  } else {\n    alignmentGroupOpts = alignmentGroups[alignmentgroup] = {\n      traces: [traceOut],\n      alignmentIndex: Object.keys(alignmentGroups).length,\n      offsetGroups: {}\n    };\n  }\n\n  var offsetgroup = coerce('offsetgroup');\n  var offsetGroups = alignmentGroupOpts.offsetGroups;\n  var offsetGroupOpts = offsetGroups[offsetgroup];\n\n  if (offsetgroup) {\n    if (!offsetGroupOpts) {\n      offsetGroupOpts = offsetGroups[offsetgroup] = {\n        offsetIndex: Object.keys(offsetGroups).length\n      };\n    }\n\n    traceOut._offsetIndex = offsetGroupOpts.offsetIndex;\n  }\n}\n\nfunction crossTraceDefaults(fullData, fullLayout) {\n  var traceIn, traceOut;\n\n  function coerce(attr) {\n    return Lib.coerce(traceOut._input, traceOut, attributes, attr);\n  }\n\n  if (fullLayout.barmode === 'group') {\n    for (var i = 0; i < fullData.length; i++) {\n      traceOut = fullData[i];\n\n      if (traceOut.type === 'bar') {\n        traceIn = traceOut._input;\n        handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce);\n      }\n    }\n  }\n}\n\nfunction handleText(traceIn, traceOut, layout, coerce, textposition, opts) {\n  opts = opts || {};\n  var moduleHasSelected = !(opts.moduleHasSelected === false);\n  var moduleHasUnselected = !(opts.moduleHasUnselected === false);\n  var moduleHasConstrain = !(opts.moduleHasConstrain === false);\n  var moduleHasCliponaxis = !(opts.moduleHasCliponaxis === false);\n  var moduleHasTextangle = !(opts.moduleHasTextangle === false);\n  var moduleHasInsideanchor = !(opts.moduleHasInsideanchor === false);\n  var hasBoth = Array.isArray(textposition) || textposition === 'auto';\n  var hasInside = hasBoth || textposition === 'inside';\n  var hasOutside = hasBoth || textposition === 'outside';\n\n  if (hasInside || hasOutside) {\n    var dfltFont = coerceFont(coerce, 'textfont', layout.font); // Note that coercing `insidetextfont` is always needed –\n    // even if `textposition` is `outside` for each trace – since\n    // an outside label can become an inside one, for example because\n    // of a bar being stacked on top of it.\n\n    var insideTextFontDefault = Lib.extendFlat({}, dfltFont);\n    var isTraceTextfontColorSet = traceIn.textfont && traceIn.textfont.color;\n    var isColorInheritedFromLayoutFont = !isTraceTextfontColorSet;\n\n    if (isColorInheritedFromLayoutFont) {\n      delete insideTextFontDefault.color;\n    }\n\n    coerceFont(coerce, 'insidetextfont', insideTextFontDefault);\n    if (hasOutside) coerceFont(coerce, 'outsidetextfont', dfltFont);\n    if (moduleHasSelected) coerce('selected.textfont.color');\n    if (moduleHasUnselected) coerce('unselected.textfont.color');\n    if (moduleHasConstrain) coerce('constraintext');\n    if (moduleHasCliponaxis) coerce('cliponaxis');\n    if (moduleHasTextangle) coerce('textangle');\n    coerce('texttemplate');\n  }\n\n  if (hasInside) {\n    if (moduleHasInsideanchor) coerce('insidetextanchor');\n  }\n}\n\nmodule.exports = {\n  supplyDefaults: supplyDefaults,\n  crossTraceDefaults: crossTraceDefaults,\n  handleGroupingDefaults: handleGroupingDefaults,\n  handleText: handleText\n};","map":null,"metadata":{},"sourceType":"script"}