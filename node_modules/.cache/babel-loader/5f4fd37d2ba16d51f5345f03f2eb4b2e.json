{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar polygonTester = require('../../lib/polygon').tester;\n\nvar findIndexOfMin = Lib.findIndexOfMin;\nvar isAngleInsideSector = Lib.isAngleInsideSector;\nvar angleDelta = Lib.angleDelta;\nvar angleDist = Lib.angleDist;\n/**\n * is pt (r,a) inside polygon made up vertices at angles 'vangles'\n * inside a given polar sector\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {boolean}\n */\n\nfunction isPtInsidePolygon(r, a, rBnds, aBnds, vangles) {\n  if (!isAngleInsideSector(a, aBnds)) return false;\n  var r0, r1;\n\n  if (rBnds[0] < rBnds[1]) {\n    r0 = rBnds[0];\n    r1 = rBnds[1];\n  } else {\n    r0 = rBnds[1];\n    r1 = rBnds[0];\n  }\n\n  var polygonIn = polygonTester(makePolygon(r0, aBnds[0], aBnds[1], vangles));\n  var polygonOut = polygonTester(makePolygon(r1, aBnds[0], aBnds[1], vangles));\n  var xy = [r * Math.cos(a), r * Math.sin(a)];\n  return polygonOut.contains(xy) && !polygonIn.contains(xy);\n} // find intersection of 'v0' <-> 'v1' edge with a ray at angle 'a'\n// (i.e. a line that starts from the origin at angle 'a')\n// given an (xp,yp) pair on the 'v0' <-> 'v1' line\n// (N.B. 'v0' and 'v1' are angles in radians)\n\n\nfunction findIntersectionXY(v0, v1, a, xpyp) {\n  var xstar, ystar;\n  var xp = xpyp[0];\n  var yp = xpyp[1];\n  var dsin = clampTiny(Math.sin(v1) - Math.sin(v0));\n  var dcos = clampTiny(Math.cos(v1) - Math.cos(v0));\n  var tanA = Math.tan(a);\n  var cotanA = clampTiny(1 / tanA);\n  var m = dsin / dcos;\n  var b = yp - m * xp;\n\n  if (cotanA) {\n    if (dsin && dcos) {\n      // given\n      //  g(x) := v0 -> v1 line = m*x + b\n      //  h(x) := ray at angle 'a' = m*x = tanA*x\n      // solve g(xstar) = h(xstar)\n      xstar = b / (tanA - m);\n      ystar = tanA * xstar;\n    } else if (dcos) {\n      // horizontal v0 -> v1\n      xstar = yp * cotanA;\n      ystar = yp;\n    } else {\n      // vertical v0 -> v1\n      xstar = xp;\n      ystar = xp * tanA;\n    }\n  } else {\n    // vertical ray\n    if (dsin && dcos) {\n      xstar = 0;\n      ystar = b;\n    } else if (dcos) {\n      xstar = 0;\n      ystar = yp;\n    } else {\n      // does this case exists?\n      xstar = ystar = NaN;\n    }\n  }\n\n  return [xstar, ystar];\n} // solves l^2 = (f(x)^2 - yp)^2 + (x - xp)^2\n// rearranged into 0 = a*x^2 + b * x + c\n//\n// where f(x) = m*x + t + yp\n// and   (x0, x1) = (-b +/- del) / (2*a)\n\n\nfunction findXYatLength(l, m, xp, yp) {\n  var t = -m * xp;\n  var a = m * m + 1;\n  var b = 2 * (m * t - xp);\n  var c = t * t + xp * xp - l * l;\n  var del = Math.sqrt(b * b - 4 * a * c);\n  var x0 = (-b + del) / (2 * a);\n  var x1 = (-b - del) / (2 * a);\n  return [[x0, m * x0 + t + yp], [x1, m * x1 + t + yp]];\n}\n\nfunction makeRegularPolygon(r, vangles) {\n  var len = vangles.length;\n  var vertices = new Array(len + 1);\n  var i;\n\n  for (i = 0; i < len; i++) {\n    var va = vangles[i];\n    vertices[i] = [r * Math.cos(va), r * Math.sin(va)];\n  }\n\n  vertices[i] = vertices[0].slice();\n  return vertices;\n}\n\nfunction makeClippedPolygon(r, a0, a1, vangles) {\n  var len = vangles.length;\n  var vertices = [];\n  var i, j;\n\n  function a2xy(a) {\n    return [r * Math.cos(a), r * Math.sin(a)];\n  }\n\n  function findXY(va0, va1, s) {\n    return findIntersectionXY(va0, va1, s, a2xy(va0));\n  }\n\n  function cycleIndex(ind) {\n    return Lib.mod(ind, len);\n  }\n\n  function isInside(v) {\n    return isAngleInsideSector(v, [a0, a1]);\n  } // find index in sector closest to a0\n  // use it to find intersection of v[i0] <-> v[i0-1] edge with sector radius\n\n\n  var i0 = findIndexOfMin(vangles, function (v) {\n    return isInside(v) ? angleDist(v, a0) : Infinity;\n  });\n  var xy0 = findXY(vangles[i0], vangles[cycleIndex(i0 - 1)], a0);\n  vertices.push(xy0); // fill in in-sector vertices\n\n  for (i = i0, j = 0; j < len; i++, j++) {\n    var va = vangles[cycleIndex(i)];\n    if (!isInside(va)) break;\n    vertices.push(a2xy(va));\n  } // find index in sector closest to a1,\n  // use it to find intersection of v[iN] <-> v[iN+1] edge with sector radius\n\n\n  var iN = findIndexOfMin(vangles, function (v) {\n    return isInside(v) ? angleDist(v, a1) : Infinity;\n  });\n  var xyN = findXY(vangles[iN], vangles[cycleIndex(iN + 1)], a1);\n  vertices.push(xyN);\n  vertices.push([0, 0]);\n  vertices.push(vertices[0].slice());\n  return vertices;\n}\n\nfunction makePolygon(r, a0, a1, vangles) {\n  return Lib.isFullCircle([a0, a1]) ? makeRegularPolygon(r, vangles) : makeClippedPolygon(r, a0, a1, vangles);\n}\n\nfunction findPolygonOffset(r, a0, a1, vangles) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var vertices = makePolygon(r, a0, a1, vangles);\n\n  for (var i = 0; i < vertices.length; i++) {\n    var v = vertices[i];\n    minX = Math.min(minX, v[0]);\n    minY = Math.min(minY, -v[1]);\n  }\n\n  return [minX, minY];\n}\n/**\n * find vertex angles (in 'vangles') the enclose angle 'a'\n *\n * @param {number} a : angle in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {2-item array}\n */\n\n\nfunction findEnclosingVertexAngles(a, vangles) {\n  var minFn = function (v) {\n    var adelta = angleDelta(v, a);\n    return adelta > 0 ? adelta : Infinity;\n  };\n\n  var i0 = findIndexOfMin(vangles, minFn);\n  var i1 = Lib.mod(i0 + 1, vangles.length);\n  return [vangles[i0], vangles[i1]];\n} // to more easily catch 'almost zero' numbers in if-else blocks\n\n\nfunction clampTiny(v) {\n  return Math.abs(v) > 1e-10 ? v : 0;\n}\n\nfunction transformForSVG(pts0, cx, cy) {\n  cx = cx || 0;\n  cy = cy || 0;\n  var len = pts0.length;\n  var pts1 = new Array(len);\n\n  for (var i = 0; i < len; i++) {\n    var pt = pts0[i];\n    pts1[i] = [cx + pt[0], cy - pt[1]];\n  }\n\n  return pts1;\n}\n/**\n * path polygon\n *\n * @param {number} r : polygon 'radius'\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\n\n\nfunction pathPolygon(r, a0, a1, vangles, cx, cy) {\n  var poly = makePolygon(r, a0, a1, vangles);\n  return 'M' + transformForSVG(poly, cx, cy).join('L');\n}\n/**\n * path a polygon 'annulus'\n * i.e. a polygon with a concentric hole\n *\n * N.B. this routine uses the evenodd SVG rule\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\n\n\nfunction pathPolygonAnnulus(r0, r1, a0, a1, vangles, cx, cy) {\n  var rStart, rEnd;\n\n  if (r0 < r1) {\n    rStart = r0;\n    rEnd = r1;\n  } else {\n    rStart = r1;\n    rEnd = r0;\n  }\n\n  var inner = transformForSVG(makePolygon(rStart, a0, a1, vangles), cx, cy);\n  var outer = transformForSVG(makePolygon(rEnd, a0, a1, vangles), cx, cy);\n  return 'M' + outer.reverse().join('L') + 'M' + inner.join('L');\n}\n\nmodule.exports = {\n  isPtInsidePolygon: isPtInsidePolygon,\n  findPolygonOffset: findPolygonOffset,\n  findEnclosingVertexAngles: findEnclosingVertexAngles,\n  findIntersectionXY: findIntersectionXY,\n  findXYatLength: findXYatLength,\n  clampTiny: clampTiny,\n  pathPolygon: pathPolygon,\n  pathPolygonAnnulus: pathPolygonAnnulus\n};","map":null,"metadata":{},"sourceType":"script"}