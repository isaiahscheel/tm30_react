{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar makeColorScaleFn = require('../../components/colorscale').makeColorScaleFuncFromTrace;\n\nvar makePullColorFn = require('../pie/calc').makePullColorFn;\n\nvar generateExtendedColors = require('../pie/calc').generateExtendedColors;\n\nvar colorscaleCalc = require('../../components/colorscale').calc;\n\nvar sunburstExtendedColorWays = {};\nvar treemapExtendedColorWays = {};\n\nexports.calc = function (gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var ids = trace.ids;\n  var hasIds = Lib.isArrayOrTypedArray(ids);\n  var labels = trace.labels;\n  var parents = trace.parents;\n  var values = trace.values;\n  var hasValues = Lib.isArrayOrTypedArray(values);\n  var cd = [];\n  var parent2children = {};\n  var refs = {};\n\n  var addToLookup = function (parent, v) {\n    if (parent2children[parent]) parent2children[parent].push(v);else parent2children[parent] = [v];\n    refs[v] = 1;\n  }; // treat number `0` as valid\n\n\n  var isValidKey = function (k) {\n    return k || typeof k === 'number';\n  };\n\n  var isValidVal = function (i) {\n    return !hasValues || isNumeric(values[i]) && values[i] >= 0;\n  };\n\n  var len;\n  var isValid;\n  var getId;\n\n  if (hasIds) {\n    len = Math.min(ids.length, parents.length);\n\n    isValid = function (i) {\n      return isValidKey(ids[i]) && isValidVal(i);\n    };\n\n    getId = function (i) {\n      return String(ids[i]);\n    };\n  } else {\n    len = Math.min(labels.length, parents.length);\n\n    isValid = function (i) {\n      return isValidKey(labels[i]) && isValidVal(i);\n    }; // TODO We could allow some label / parent duplication\n    //\n    // From AJ:\n    //  It would work OK for one level\n    //  (multiple rows with the same name and different parents -\n    //  or even the same parent) but if that name is then used as a parent\n    //  which one is it?\n\n\n    getId = function (i) {\n      return String(labels[i]);\n    };\n  }\n\n  if (hasValues) len = Math.min(len, values.length);\n\n  for (var i = 0; i < len; i++) {\n    if (isValid(i)) {\n      var id = getId(i);\n      var pid = isValidKey(parents[i]) ? String(parents[i]) : '';\n      var cdi = {\n        i: i,\n        id: id,\n        pid: pid,\n        label: isValidKey(labels[i]) ? String(labels[i]) : ''\n      };\n      if (hasValues) cdi.v = +values[i];\n      cd.push(cdi);\n      addToLookup(pid, id);\n    }\n  }\n\n  if (!parent2children['']) {\n    var impliedRoots = [];\n    var k;\n\n    for (k in parent2children) {\n      if (!refs[k]) {\n        impliedRoots.push(k);\n      }\n    } // if an `id` has no ref in the `parents` array,\n    // take it as being the root node\n\n\n    if (impliedRoots.length === 1) {\n      k = impliedRoots[0];\n      cd.unshift({\n        hasImpliedRoot: true,\n        id: k,\n        pid: '',\n        label: k\n      });\n    } else {\n      return Lib.warn('Multiple implied roots, cannot build ' + trace.type + ' hierarchy.');\n    }\n  } else if (parent2children[''].length > 1) {\n    var dummyId = Lib.randstr(); // if multiple rows linked to the root node,\n    // add dummy \"root of roots\" node to make d3 build the hierarchy successfully\n\n    for (var j = 0; j < cd.length; j++) {\n      if (cd[j].pid === '') {\n        cd[j].pid = dummyId;\n      }\n    }\n\n    cd.unshift({\n      hasMultipleRoots: true,\n      id: dummyId,\n      pid: '',\n      label: ''\n    });\n  } // TODO might be better to replace stratify() with our own algorithm\n\n\n  var root;\n\n  try {\n    root = d3Hierarchy.stratify().id(function (d) {\n      return d.id;\n    }).parentId(function (d) {\n      return d.pid;\n    })(cd);\n  } catch (e) {\n    return Lib.warn('Failed to build ' + trace.type + ' hierarchy. Error: ' + e.message);\n  }\n\n  var hierarchy = d3Hierarchy.hierarchy(root);\n  var failed = false;\n\n  if (hasValues) {\n    switch (trace.branchvalues) {\n      case 'remainder':\n        hierarchy.sum(function (d) {\n          return d.data.v;\n        });\n        break;\n\n      case 'total':\n        hierarchy.each(function (d) {\n          var cdi = d.data.data;\n          var v = cdi.v;\n\n          if (d.children) {\n            var partialSum = d.children.reduce(function (a, c) {\n              return a + c.data.data.v;\n            }, 0); // N.B. we must fill in `value` for generated sectors\n            // with the partialSum to compute the correct partition\n\n            if (cdi.hasImpliedRoot || cdi.hasMultipleRoots) {\n              v = partialSum;\n            }\n\n            if (v < partialSum) {\n              failed = true;\n              return Lib.warn(['Total value for node', d.data.data.id, 'is smaller than the sum of its children.', '\\nparent value =', v, '\\nchildren sum =', partialSum].join(' '));\n            }\n          }\n\n          d.value = v;\n        });\n        break;\n    }\n  } else {\n    countDescendants(hierarchy, trace, {\n      branches: trace.count.indexOf('branches') !== -1,\n      leaves: trace.count.indexOf('leaves') !== -1\n    });\n  }\n\n  if (failed) return; // TODO add way to sort by height also?\n\n  hierarchy.sort(function (a, b) {\n    return b.value - a.value;\n  });\n  var pullColor;\n  var scaleColor;\n  var colors = trace.marker.colors || [];\n  var hasColors = !!colors.length;\n\n  if (trace._hasColorscale) {\n    if (!hasColors) {\n      colors = hasValues ? trace.values : trace._values;\n    }\n\n    colorscaleCalc(gd, trace, {\n      vals: colors,\n      containerStr: 'marker',\n      cLetter: 'c'\n    });\n    scaleColor = makeColorScaleFn(trace.marker);\n  } else {\n    pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n  } // TODO keep track of 'root-children' (i.e. branch) for hover info etc.\n\n\n  hierarchy.each(function (d) {\n    var cdi = d.data.data; // N.B. this mutates items in `cd`\n\n    cdi.color = trace._hasColorscale ? scaleColor(colors[cdi.i]) : pullColor(colors[cdi.i], cdi.id);\n  });\n  cd[0].hierarchy = hierarchy;\n  return cd;\n};\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\n\n\nexports._runCrossTraceCalc = function (desiredType, gd) {\n  var fullLayout = gd._fullLayout;\n  var calcdata = gd.calcdata;\n  var colorWay = fullLayout[desiredType + 'colorway'];\n  var colorMap = fullLayout['_' + desiredType + 'colormap'];\n\n  if (fullLayout['extend' + desiredType + 'colors']) {\n    colorWay = generateExtendedColors(colorWay, desiredType === 'treemap' ? treemapExtendedColorWays : sunburstExtendedColorWays);\n  }\n\n  var dfltColorCount = 0;\n\n  function pickColor(d) {\n    var cdi = d.data.data;\n    var id = cdi.id;\n\n    if (cdi.color === false) {\n      if (colorMap[id]) {\n        // have we seen this label and assigned a color to it in a previous trace?\n        cdi.color = colorMap[id];\n      } else if (d.parent) {\n        if (d.parent.parent) {\n          // from third-level on, inherit from parent\n          cdi.color = d.parent.data.data.color;\n        } else {\n          // pick new color for second level\n          colorMap[id] = cdi.color = colorWay[dfltColorCount % colorWay.length];\n          dfltColorCount++;\n        }\n      } else {\n        // root gets no coloring by default\n        cdi.color = 'rgba(0,0,0,0)';\n      }\n    }\n  }\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n\n    if (cd0.trace.type === desiredType && cd0.hierarchy) {\n      cd0.hierarchy.each(pickColor);\n    }\n  }\n};\n\nexports.crossTraceCalc = function (gd) {\n  return exports._runCrossTraceCalc('sunburst', gd);\n};\n\nfunction countDescendants(node, trace, opts) {\n  var nChild = 0;\n  var children = node.children;\n\n  if (children) {\n    var len = children.length;\n\n    for (var i = 0; i < len; i++) {\n      nChild += countDescendants(children[i], trace, opts);\n    }\n\n    if (opts.branches) nChild++; // count this branch\n  } else {\n    if (opts.leaves) nChild++; // count this leaf\n  } // save to the node\n\n\n  node.value = node.data.data.value = nChild; // save to the trace\n\n  if (!trace._values) trace._values = [];\n  trace._values[node.data.data.i] = nChild;\n  return nChild;\n}","map":null,"metadata":{},"sourceType":"script"}