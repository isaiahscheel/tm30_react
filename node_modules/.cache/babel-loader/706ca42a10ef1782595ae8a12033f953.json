{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar mouseOffset = require('mouse-event-offset');\n\nvar hasHover = require('has-hover');\n\nvar supportsPassive = require('has-passive-events');\n\nvar removeElement = require('../../lib').removeElement;\n\nvar constants = require('../../plots/cartesian/constants');\n\nvar dragElement = module.exports = {};\ndragElement.align = require('./align');\ndragElement.getCursor = require('./cursor');\n\nvar unhover = require('./unhover');\n\ndragElement.unhover = unhover.wrapped;\ndragElement.unhoverRaw = unhover.raw;\n/**\n * Abstracts click & drag interactions\n *\n * During the interaction, a \"coverSlip\" element - a transparent\n * div covering the whole page - is created, which has two key effects:\n * - Lets you drag beyond the boundaries of the plot itself without\n *   dropping (but if you drag all the way out of the browser window the\n *   interaction will end)\n * - Freezes the cursor: whatever mouse cursor the drag element had when the\n *   interaction started gets copied to the coverSlip for use until mouseup\n *\n * If the user executes a drag bigger than MINDRAG, callbacks will fire as:\n *      prepFn, moveFn (1 or more times), doneFn\n * If the user does not drag enough, prepFn and clickFn will fire.\n *\n * Note: If you cancel contextmenu, clickFn will fire even with a right click\n * (unlike native events) so you'll get a `plotly_click` event. Cancel context eg:\n *    gd.addEventListener('contextmenu', function(e) { e.preventDefault(); });\n * TODO: we should probably turn this into a `config` parameter, so we can fix it\n * such that if you *don't* cancel contextmenu, we can prevent partial drags, which\n * put you in a weird state.\n *\n * If the user clicks multiple times quickly, clickFn will fire each time\n * but numClicks will increase to help you recognize doubleclicks.\n *\n * @param {object} options with keys:\n *      element (required) the DOM element to drag\n *      prepFn (optional) function(event, startX, startY)\n *          executed on mousedown\n *          startX and startY are the clientX and clientY pixel position\n *          of the mousedown event\n *      moveFn (optional) function(dx, dy)\n *          executed on move, ONLY after we've exceeded MINDRAG\n *          (we keep executing moveFn if you move back to where you started)\n *          dx and dy are the net pixel offset of the drag,\n *          dragged is true/false, has the mouse moved enough to\n *          constitute a drag\n *      doneFn (optional) function(e)\n *          executed on mouseup, ONLY if we exceeded MINDRAG (so you can be\n *          sure that moveFn has been called at least once)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mouseup event\n *      clickFn (optional) function(numClicks, e)\n *          executed on mouseup if we have NOT exceeded MINDRAG (ie moveFn\n *          has not been called at all)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mousedown event\n *      clampFn (optional, function(dx, dy) return [dx2, dy2])\n *          Provide custom clamping function for small displacements.\n *          By default, clamping is done using `minDrag` to x and y displacements\n *          independently.\n */\n\ndragElement.init = function init(options) {\n  var gd = options.gd;\n  var numClicks = 1;\n  var doubleClickDelay = gd._context.doubleClickDelay;\n  var element = options.element;\n  var startX, startY, newMouseDownTime, cursor, dragCover, initialEvent, initialTarget, rightClick;\n  if (!gd._mouseDownTime) gd._mouseDownTime = 0;\n  element.style.pointerEvents = 'all';\n  element.onmousedown = onStart;\n\n  if (!supportsPassive) {\n    element.ontouchstart = onStart;\n  } else {\n    if (element._ontouchstart) {\n      element.removeEventListener('touchstart', element._ontouchstart);\n    }\n\n    element._ontouchstart = onStart;\n    element.addEventListener('touchstart', onStart, {\n      passive: false\n    });\n  }\n\n  function _clampFn(dx, dy, minDrag) {\n    if (Math.abs(dx) < minDrag) dx = 0;\n    if (Math.abs(dy) < minDrag) dy = 0;\n    return [dx, dy];\n  }\n\n  var clampFn = options.clampFn || _clampFn;\n\n  function onStart(e) {\n    // make dragging and dragged into properties of gd\n    // so that others can look at and modify them\n    gd._dragged = false;\n    gd._dragging = true;\n    var offset = pointerOffset(e);\n    startX = offset[0];\n    startY = offset[1];\n    initialTarget = e.target;\n    initialEvent = e;\n    rightClick = e.buttons === 2 || e.ctrlKey; // fix Fx.hover for touch events\n\n    if (typeof e.clientX === 'undefined' && typeof e.clientY === 'undefined') {\n      e.clientX = startX;\n      e.clientY = startY;\n    }\n\n    newMouseDownTime = new Date().getTime();\n\n    if (newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {\n      // in a click train\n      numClicks += 1;\n    } else {\n      // new click train\n      numClicks = 1;\n      gd._mouseDownTime = newMouseDownTime;\n    }\n\n    if (options.prepFn) options.prepFn(e, startX, startY);\n\n    if (hasHover && !rightClick) {\n      dragCover = coverSlip();\n      dragCover.style.cursor = window.getComputedStyle(element).cursor;\n    } else if (!hasHover) {\n      // document acts as a dragcover for mobile, bc we can't create dragcover dynamically\n      dragCover = document;\n      cursor = window.getComputedStyle(document.documentElement).cursor;\n      document.documentElement.style.cursor = window.getComputedStyle(element).cursor;\n    }\n\n    document.addEventListener('mouseup', onDone);\n    document.addEventListener('touchend', onDone);\n\n    if (options.dragmode !== false) {\n      e.preventDefault();\n      document.addEventListener('mousemove', onMove);\n      document.addEventListener('touchmove', onMove, {\n        passive: false\n      });\n    }\n\n    return;\n  }\n\n  function onMove(e) {\n    e.preventDefault();\n    var offset = pointerOffset(e);\n    var minDrag = options.minDrag || constants.MINDRAG;\n    var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);\n    var dx = dxdy[0];\n    var dy = dxdy[1];\n\n    if (dx || dy) {\n      gd._dragged = true;\n      dragElement.unhover(gd);\n    }\n\n    if (gd._dragged && options.moveFn && !rightClick) {\n      gd._dragdata = {\n        element: element,\n        dx: dx,\n        dy: dy\n      };\n      options.moveFn(dx, dy);\n    }\n\n    return;\n  }\n\n  function onDone(e) {\n    delete gd._dragdata;\n\n    if (options.dragmode !== false) {\n      e.preventDefault();\n      document.removeEventListener('mousemove', onMove);\n      document.removeEventListener('touchmove', onMove);\n    }\n\n    document.removeEventListener('mouseup', onDone);\n    document.removeEventListener('touchend', onDone);\n\n    if (hasHover) {\n      removeElement(dragCover);\n    } else if (cursor) {\n      dragCover.documentElement.style.cursor = cursor;\n      cursor = null;\n    }\n\n    if (!gd._dragging) {\n      gd._dragged = false;\n      return;\n    }\n\n    gd._dragging = false; // don't count as a dblClick unless the mouseUp is also within\n    // the dblclick delay\n\n    if (new Date().getTime() - gd._mouseDownTime > doubleClickDelay) {\n      numClicks = Math.max(numClicks - 1, 1);\n    }\n\n    if (gd._dragged) {\n      if (options.doneFn) options.doneFn();\n    } else {\n      if (options.clickFn) options.clickFn(numClicks, initialEvent); // If we haven't dragged, this should be a click. But because of the\n      // coverSlip changing the element, the natural system might not generate one,\n      // so we need to make our own. But right clicks don't normally generate\n      // click events, only contextmenu events, which happen on mousedown.\n\n      if (!rightClick) {\n        var e2;\n\n        try {\n          e2 = new MouseEvent('click', e);\n        } catch (err) {\n          var offset = pointerOffset(e);\n          e2 = document.createEvent('MouseEvents');\n          e2.initMouseEvent('click', e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, offset[0], offset[1], e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n        }\n\n        initialTarget.dispatchEvent(e2);\n      }\n    }\n\n    gd._dragging = false;\n    gd._dragged = false;\n    return;\n  }\n};\n\nfunction coverSlip() {\n  var cover = document.createElement('div');\n  cover.className = 'dragcover';\n  var cStyle = cover.style;\n  cStyle.position = 'fixed';\n  cStyle.left = 0;\n  cStyle.right = 0;\n  cStyle.top = 0;\n  cStyle.bottom = 0;\n  cStyle.zIndex = 999999999;\n  cStyle.background = 'none';\n  document.body.appendChild(cover);\n  return cover;\n}\n\ndragElement.coverSlip = coverSlip;\n\nfunction pointerOffset(e) {\n  return mouseOffset(e.changedTouches ? e.changedTouches[0] : e, document.body);\n}","map":null,"metadata":{},"sourceType":"script"}