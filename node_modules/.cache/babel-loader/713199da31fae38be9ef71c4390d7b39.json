{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar scatterHover = require('../scatter/hover');\n\nvar fillText = require('../../lib').fillText;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n  var scatterPointData = scatterHover(pointData, xval, yval, hovermode);\n  if (!scatterPointData || scatterPointData[0].index === false) return;\n  var newPointData = scatterPointData[0]; // if hovering on a fill, we don't show any point data so the label is\n  // unchanged from what scatter gives us - except that it needs to\n  // be constrained to the trianglular plot area, not just the rectangular\n  // area defined by the synthetic x and y axes\n  // TODO: in some cases the vertical middle of the shape is not within\n  // the triangular viewport at all, so the label can become disconnected\n  // from the shape entirely. But calculating what portion of the shape\n  // is actually visible, as constrained by the diagonal axis lines, is not\n  // so easy and anyway we lost the information we would have needed to do\n  // this inside scatterHover.\n\n  if (newPointData.index === undefined) {\n    var yFracUp = 1 - newPointData.y0 / pointData.ya._length;\n    var xLen = pointData.xa._length;\n    var xMin = xLen * yFracUp / 2;\n    var xMax = xLen - xMin;\n    newPointData.x0 = Math.max(Math.min(newPointData.x0, xMax), xMin);\n    newPointData.x1 = Math.max(Math.min(newPointData.x1, xMax), xMin);\n    return scatterPointData;\n  }\n\n  var cdi = newPointData.cd[newPointData.index];\n  newPointData.a = cdi.a;\n  newPointData.b = cdi.b;\n  newPointData.xLabelVal = undefined;\n  newPointData.yLabelVal = undefined; // TODO: nice formatting, and label by axis title, for a, b, and c?\n\n  var trace = newPointData.trace;\n  var carpet = trace._carpet;\n  var ij = carpet.ab2ij([cdi.a, cdi.b]);\n  var i0 = Math.floor(ij[0]);\n  var ti = ij[0] - i0;\n  var j0 = Math.floor(ij[1]);\n  var tj = ij[1] - j0;\n  var xy = carpet.evalxy([], i0, j0, ti, tj);\n  newPointData.yLabel = xy[1].toFixed(3);\n  delete newPointData.text;\n  var text = [];\n\n  function textPart(ax, val) {\n    var prefix;\n\n    if (ax.labelprefix && ax.labelprefix.length > 0) {\n      prefix = ax.labelprefix.replace(/ = $/, '');\n    } else {\n      prefix = ax._hovertitle;\n    }\n\n    text.push(prefix + ': ' + val.toFixed(3) + ax.labelsuffix);\n  }\n\n  if (!trace.hovertemplate) {\n    var hoverinfo = cdi.hi || trace.hoverinfo;\n    var parts = hoverinfo.split('+');\n    if (parts.indexOf('all') !== -1) parts = ['a', 'b', 'text'];\n    if (parts.indexOf('a') !== -1) textPart(carpet.aaxis, cdi.a);\n    if (parts.indexOf('b') !== -1) textPart(carpet.baxis, cdi.b);\n    text.push('y: ' + newPointData.yLabel);\n\n    if (parts.indexOf('text') !== -1) {\n      fillText(cdi, trace, text);\n    }\n\n    newPointData.extraText = text.join('<br>');\n  }\n\n  return scatterPointData;\n};","map":null,"metadata":{},"sourceType":"script"}