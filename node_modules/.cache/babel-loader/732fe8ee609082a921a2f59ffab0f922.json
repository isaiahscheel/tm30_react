{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\n\nvar colorscaleCalc = require('../../components/colorscale/calc');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\n\nvar setGroupPositions = require('../bar/cross_trace_calc').setGroupPositions;\n\nvar calcSelection = require('../scatter/calc_selection');\n\nvar traceIs = require('../../registry').traceIs;\n\nvar extendFlat = require('../../lib').extendFlat;\n\nfunction calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var subplotId = trace.subplot;\n  var radialAxis = fullLayout[subplotId].radialaxis;\n  var angularAxis = fullLayout[subplotId].angularaxis;\n  var rArray = radialAxis.makeCalcdata(trace, 'r');\n  var thetaArray = angularAxis.makeCalcdata(trace, 'theta');\n  var len = trace._length;\n  var cd = new Array(len); // 'size' axis variables\n\n  var sArray = rArray; // 'pos' axis variables\n\n  var pArray = thetaArray;\n\n  for (var i = 0; i < len; i++) {\n    cd[i] = {\n      p: pArray[i],\n      s: sArray[i]\n    };\n  } // convert width and offset in 'c' coordinate,\n  // set 'c' value(s) in trace._width and trace._offset,\n  // to make Bar.crossTraceCalc \"just work\"\n\n\n  function d2c(attr) {\n    var val = trace[attr];\n\n    if (val !== undefined) {\n      trace['_' + attr] = Array.isArray(val) ? angularAxis.makeCalcdata(trace, attr) : angularAxis.d2c(val, trace.thetaunit);\n    }\n  }\n\n  if (angularAxis.type === 'linear') {\n    d2c('width');\n    d2c('offset');\n  }\n\n  if (hasColorscale(trace, 'marker')) {\n    colorscaleCalc(gd, trace, {\n      vals: trace.marker.color,\n      containerStr: 'marker',\n      cLetter: 'c'\n    });\n  }\n\n  if (hasColorscale(trace, 'marker.line')) {\n    colorscaleCalc(gd, trace, {\n      vals: trace.marker.line.color,\n      containerStr: 'marker.line',\n      cLetter: 'c'\n    });\n  }\n\n  arraysToCalcdata(cd, trace);\n  calcSelection(cd, trace);\n  return cd;\n}\n\nfunction crossTraceCalc(gd, polarLayout, subplotId) {\n  var calcdata = gd.calcdata;\n  var barPolarCd = [];\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cdi = calcdata[i];\n    var trace = cdi[0].trace;\n\n    if (trace.visible === true && traceIs(trace, 'bar') && trace.subplot === subplotId) {\n      barPolarCd.push(cdi);\n    }\n  } // to make _extremes is filled in correctly so that\n  // polar._subplot.radialAxis can get auotrange'd\n  // TODO clean up!\n  // I think we want to call getAutorange on polar.radialaxis\n  // NOT on polar._subplot.radialAxis\n\n\n  var rAxis = extendFlat({}, polarLayout.radialaxis, {\n    _id: 'x'\n  });\n  var aAxis = polarLayout.angularaxis;\n  setGroupPositions(gd, aAxis, rAxis, barPolarCd, {\n    mode: polarLayout.barmode,\n    norm: polarLayout.barnorm,\n    gap: polarLayout.bargap,\n    groupgap: polarLayout.bargroupgap\n  });\n}\n\nmodule.exports = {\n  calc: calc,\n  crossTraceCalc: crossTraceCalc\n};","map":null,"metadata":{},"sourceType":"script"}