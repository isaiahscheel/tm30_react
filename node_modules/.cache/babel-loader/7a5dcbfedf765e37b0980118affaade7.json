{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../lib');\n\nvar Registry = require('../registry');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar filterOps = require('../constants/filter_ops');\n\nvar COMPARISON_OPS = filterOps.COMPARISON_OPS;\nvar INTERVAL_OPS = filterOps.INTERVAL_OPS;\nvar SET_OPS = filterOps.SET_OPS;\nexports.moduleType = 'transform';\nexports.name = 'filter';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    role: 'info',\n    editType: 'calc',\n    description: ['Determines whether this filter transform is enabled or disabled.'].join(' ')\n  },\n  target: {\n    valType: 'string',\n    strict: true,\n    noBlank: true,\n    arrayOk: true,\n    dflt: 'x',\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the filter target by which the filter is applied.', 'If a string, `target` is assumed to be a reference to a data array', 'in the parent trace object.', 'To filter about nested variables, use *.* to access them.', 'For example, set `target` to *marker.color* to filter', 'about the marker color array.', 'If an array, `target` is then the data array by which the filter is applied.'].join(' ')\n  },\n  operation: {\n    valType: 'enumerated',\n    values: [].concat(COMPARISON_OPS).concat(INTERVAL_OPS).concat(SET_OPS),\n    dflt: '=',\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the filter operation.', '*=* keeps items equal to `value`', '*!=* keeps items not equal to `value`', '*<* keeps items less than `value`', '*<=* keeps items less than or equal to `value`', '*>* keeps items greater than `value`', '*>=* keeps items greater than or equal to `value`', '*[]* keeps items inside `value[0]` to `value[1]` including both bounds', '*()* keeps items inside `value[0]` to `value[1]` excluding both bounds', '*[)* keeps items inside `value[0]` to `value[1]` including `value[0]` but excluding `value[1]', '*(]* keeps items inside `value[0]` to `value[1]` excluding `value[0]` but including `value[1]', '*][* keeps items outside `value[0]` to `value[1]` and equal to both bounds', '*)(* keeps items outside `value[0]` to `value[1]`', '*](* keeps items outside `value[0]` to `value[1]` and equal to `value[0]`', '*)[* keeps items outside `value[0]` to `value[1]` and equal to `value[1]`', '*{}* keeps items present in a set of values', '*}{* keeps items not present in a set of values'].join(' ')\n  },\n  value: {\n    valType: 'any',\n    dflt: 0,\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the value or values by which to filter.', 'Values are expected to be in the same type as the data linked', 'to `target`.', 'When `operation` is set to one of', 'the comparison values (' + COMPARISON_OPS + ')', '`value` is expected to be a number or a string.', 'When `operation` is set to one of the interval values', '(' + INTERVAL_OPS + ')', '`value` is expected to be 2-item array where the first item', 'is the lower bound and the second item is the upper bound.', 'When `operation`, is set to one of the set values', '(' + SET_OPS + ')', '`value` is expected to be an array with as many items as', 'the desired set elements.'].join(' ')\n  },\n  preservegaps: {\n    valType: 'boolean',\n    dflt: false,\n    role: 'info',\n    editType: 'calc',\n    description: ['Determines whether or not gaps in data arrays produced by the filter operation', 'are preserved.', 'Setting this to *true* might be useful when plotting a line chart', 'with `connectgaps` set to *false*.'].join(' ')\n  },\n  editType: 'calc'\n};\n\nexports.supplyDefaults = function (transformIn) {\n  var transformOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n\n  var enabled = coerce('enabled');\n\n  if (enabled) {\n    var target = coerce('target');\n\n    if (Lib.isArrayOrTypedArray(target) && target.length === 0) {\n      transformOut.enabled = false;\n      return transformOut;\n    }\n\n    coerce('preservegaps');\n    coerce('operation');\n    coerce('value');\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n    handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n    handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n  }\n\n  return transformOut;\n};\n\nexports.calcTransform = function (gd, trace, opts) {\n  if (!opts.enabled) return;\n  var targetArray = Lib.getTargetArray(trace, opts);\n  if (!targetArray) return;\n  var target = opts.target;\n  var len = targetArray.length;\n  if (trace._length) len = Math.min(len, trace._length);\n  var targetCalendar = opts.targetcalendar;\n  var arrayAttrs = trace._arrayAttrs;\n  var preservegaps = opts.preservegaps; // even if you provide targetcalendar, if target is a string and there\n  // is a calendar attribute matching target it will get used instead.\n\n  if (typeof target === 'string') {\n    var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n    if (attrTargetCalendar) targetCalendar = attrTargetCalendar;\n  }\n\n  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n  var filterFunc = getFilterFunc(opts, d2c, targetCalendar);\n  var originalArrays = {};\n  var indexToPoints = {};\n  var index = 0;\n\n  function forAllAttrs(fn, index) {\n    for (var j = 0; j < arrayAttrs.length; j++) {\n      var np = Lib.nestedProperty(trace, arrayAttrs[j]);\n      fn(np, index);\n    }\n  }\n\n  var initFn;\n  var fillFn;\n\n  if (preservegaps) {\n    initFn = function (np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set(new Array(len));\n    };\n\n    fillFn = function (np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get()[index] = val;\n    };\n  } else {\n    initFn = function (np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set([]);\n    };\n\n    fillFn = function (np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get().push(val);\n    };\n  } // copy all original array attribute values, and clear arrays in trace\n\n\n  forAllAttrs(initFn);\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts); // loop through filter array, fill trace arrays if passed\n\n  for (var i = 0; i < len; i++) {\n    var passed = filterFunc(targetArray[i]);\n\n    if (passed) {\n      forAllAttrs(fillFn, i);\n      indexToPoints[index++] = originalPointsAccessor(i);\n    } else if (preservegaps) index++;\n  }\n\n  opts._indexToPoints = indexToPoints;\n  trace._length = index;\n};\n\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n  var operation = opts.operation;\n  var value = opts.value;\n  var hasArrayValue = Array.isArray(value);\n\n  function isOperationIn(array) {\n    return array.indexOf(operation) !== -1;\n  }\n\n  var d2cValue = function (v) {\n    return d2c(v, 0, opts.valuecalendar);\n  };\n\n  var d2cTarget = function (v) {\n    return d2c(v, 0, targetCalendar);\n  };\n\n  var coercedValue;\n\n  if (isOperationIn(COMPARISON_OPS)) {\n    coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n  } else if (isOperationIn(INTERVAL_OPS)) {\n    coercedValue = hasArrayValue ? [d2cValue(value[0]), d2cValue(value[1])] : [d2cValue(value), d2cValue(value)];\n  } else if (isOperationIn(SET_OPS)) {\n    coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n  }\n\n  switch (operation) {\n    case '=':\n      return function (v) {\n        return d2cTarget(v) === coercedValue;\n      };\n\n    case '!=':\n      return function (v) {\n        return d2cTarget(v) !== coercedValue;\n      };\n\n    case '<':\n      return function (v) {\n        return d2cTarget(v) < coercedValue;\n      };\n\n    case '<=':\n      return function (v) {\n        return d2cTarget(v) <= coercedValue;\n      };\n\n    case '>':\n      return function (v) {\n        return d2cTarget(v) > coercedValue;\n      };\n\n    case '>=':\n      return function (v) {\n        return d2cTarget(v) >= coercedValue;\n      };\n\n    case '[]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv <= coercedValue[1];\n      };\n\n    case '()':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv < coercedValue[1];\n      };\n\n    case '[)':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv < coercedValue[1];\n      };\n\n    case '(]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv <= coercedValue[1];\n      };\n\n    case '][':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv >= coercedValue[1];\n      };\n\n    case ')(':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv > coercedValue[1];\n      };\n\n    case '](':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv > coercedValue[1];\n      };\n\n    case ')[':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv >= coercedValue[1];\n      };\n\n    case '{}':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) !== -1;\n      };\n\n    case '}{':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) === -1;\n      };\n  }\n}","map":null,"metadata":{},"sourceType":"script"}