{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar overrideAll = require('../../plot_api/edit_types').overrideAll;\n\nvar getModuleCalcData = require('../../plots/get_data').getModuleCalcData;\n\nvar plot = require('./plot');\n\nvar fxAttrs = require('../../components/fx/layout_attributes');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar dragElement = require('../../components/dragelement');\n\nvar prepSelect = require('../../plots/cartesian/select').prepSelect;\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar SANKEY = 'sankey';\nexports.name = SANKEY;\nexports.baseLayoutAttrOverrides = overrideAll({\n  hoverlabel: fxAttrs.hoverlabel\n}, 'plot', 'nested');\n\nexports.plot = function (gd) {\n  var calcData = getModuleCalcData(gd.calcdata, SANKEY)[0];\n  plot(gd, calcData);\n  exports.updateFx(gd);\n};\n\nexports.clean = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var hadPlot = oldFullLayout._has && oldFullLayout._has(SANKEY);\n\n  var hasPlot = newFullLayout._has && newFullLayout._has(SANKEY);\n\n  if (hadPlot && !hasPlot) {\n    oldFullLayout._paperdiv.selectAll('.sankey').remove();\n\n    oldFullLayout._paperdiv.selectAll('.bgsankey').remove();\n  }\n};\n\nexports.updateFx = function (gd) {\n  for (var i = 0; i < gd._fullData.length; i++) {\n    subplotUpdateFx(gd, i);\n  }\n};\n\nfunction subplotUpdateFx(gd, index) {\n  var trace = gd._fullData[index];\n  var fullLayout = gd._fullLayout;\n  var dragMode = fullLayout.dragmode;\n  var cursor = fullLayout.dragmode === 'pan' ? 'move' : 'crosshair';\n  var bgRect = trace._bgRect;\n  if (dragMode === 'pan' || dragMode === 'zoom') return;\n  setCursor(bgRect, cursor);\n  var xaxis = {\n    _id: 'x',\n    c2p: Lib.identity,\n    _offset: trace._sankey.translateX,\n    _length: trace._sankey.width\n  };\n  var yaxis = {\n    _id: 'y',\n    c2p: Lib.identity,\n    _offset: trace._sankey.translateY,\n    _length: trace._sankey.height\n  }; // Note: dragOptions is needed to be declared for all dragmodes because\n  // it's the object that holds persistent selection state.\n\n  var dragOptions = {\n    gd: gd,\n    element: bgRect.node(),\n    plotinfo: {\n      id: index,\n      xaxis: xaxis,\n      yaxis: yaxis,\n      fillRangeItems: Lib.noop\n    },\n    subplot: index,\n    // create mock x/y axes for hover routine\n    xaxes: [xaxis],\n    yaxes: [yaxis],\n    doneFnCompleted: function (selection) {\n      var traceNow = gd._fullData[index];\n      var newGroups;\n      var oldGroups = traceNow.node.groups.slice();\n      var newGroup = [];\n\n      function findNode(pt) {\n        var nodes = traceNow._sankey.graph.nodes;\n\n        for (var i = 0; i < nodes.length; i++) {\n          if (nodes[i].pointNumber === pt) return nodes[i];\n        }\n      }\n\n      for (var j = 0; j < selection.length; j++) {\n        var node = findNode(selection[j].pointNumber);\n        if (!node) continue; // If the node represents a group\n\n        if (node.group) {\n          // Add all its children to the current selection\n          for (var k = 0; k < node.childrenNodes.length; k++) {\n            newGroup.push(node.childrenNodes[k].pointNumber);\n          } // Flag group for removal from existing list of groups\n\n\n          oldGroups[node.pointNumber - traceNow.node._count] = false;\n        } else {\n          newGroup.push(node.pointNumber);\n        }\n      }\n\n      newGroups = oldGroups.filter(Boolean).concat([newGroup]);\n      Registry.call('_guiRestyle', gd, {\n        'node.groups': [newGroups]\n      }, index);\n    }\n  };\n\n  dragOptions.prepFn = function (e, startX, startY) {\n    prepSelect(e, startX, startY, dragOptions, dragMode);\n  };\n\n  dragElement.init(dragOptions);\n}","map":null,"metadata":{},"sourceType":"script"}