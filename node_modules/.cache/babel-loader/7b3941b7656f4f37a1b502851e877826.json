{"ast":null,"code":"'use strict';\n\nvar DEFAULT_VERTEX_NORMALS_EPSILON = 1e-6; // may be too large if triangles are very small\n\nvar DEFAULT_FACE_NORMALS_EPSILON = 1e-6;\n\nvar createShader = require('gl-shader');\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createTexture = require('gl-texture2d');\n\nvar normals = require('normals');\n\nvar multiply = require('gl-mat4/multiply');\n\nvar invert = require('gl-mat4/invert');\n\nvar ndarray = require('ndarray');\n\nvar colormap = require('colormap');\n\nvar getContour = require('simplicial-complex-contour');\n\nvar pool = require('typedarray-pool');\n\nvar shaders = require('./lib/shaders');\n\nvar closestPoint = require('./lib/closest-point');\n\nvar meshShader = shaders.meshShader;\nvar wireShader = shaders.wireShader;\nvar pointShader = shaders.pointShader;\nvar pickShader = shaders.pickShader;\nvar pointPickShader = shaders.pointPickShader;\nvar contourShader = shaders.contourShader;\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nfunction SimplicialMesh(gl, texture, triShader, lineShader, pointShader, pickShader, pointPickShader, contourShader, trianglePositions, triangleIds, triangleColors, triangleUVs, triangleNormals, triangleVAO, edgePositions, edgeIds, edgeColors, edgeUVs, edgeVAO, pointPositions, pointIds, pointColors, pointUVs, pointSizes, pointVAO, contourPositions, contourVAO) {\n  this.gl = gl;\n  this.pixelRatio = 1;\n  this.cells = [];\n  this.positions = [];\n  this.intensity = [];\n  this.texture = texture;\n  this.dirty = true;\n  this.triShader = triShader;\n  this.lineShader = lineShader;\n  this.pointShader = pointShader;\n  this.pickShader = pickShader;\n  this.pointPickShader = pointPickShader;\n  this.contourShader = contourShader;\n  this.trianglePositions = trianglePositions;\n  this.triangleColors = triangleColors;\n  this.triangleNormals = triangleNormals;\n  this.triangleUVs = triangleUVs;\n  this.triangleIds = triangleIds;\n  this.triangleVAO = triangleVAO;\n  this.triangleCount = 0;\n  this.lineWidth = 1;\n  this.edgePositions = edgePositions;\n  this.edgeColors = edgeColors;\n  this.edgeUVs = edgeUVs;\n  this.edgeIds = edgeIds;\n  this.edgeVAO = edgeVAO;\n  this.edgeCount = 0;\n  this.pointPositions = pointPositions;\n  this.pointColors = pointColors;\n  this.pointUVs = pointUVs;\n  this.pointSizes = pointSizes;\n  this.pointIds = pointIds;\n  this.pointVAO = pointVAO;\n  this.pointCount = 0;\n  this.contourLineWidth = 1;\n  this.contourPositions = contourPositions;\n  this.contourVAO = contourVAO;\n  this.contourCount = 0;\n  this.contourColor = [0, 0, 0];\n  this.contourEnable = true;\n  this.pickId = 1;\n  this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.lightPosition = [1e5, 1e5, 0];\n  this.ambientLight = 0.8;\n  this.diffuseLight = 0.8;\n  this.specularLight = 2.0;\n  this.roughness = 0.5;\n  this.fresnel = 1.5;\n  this.opacity = 1.0;\n  this.hasAlpha = false;\n  this.opacityscale = false;\n  this._model = IDENTITY;\n  this._view = IDENTITY;\n  this._projection = IDENTITY;\n  this._resolution = [1, 1];\n}\n\nvar proto = SimplicialMesh.prototype;\n\nproto.isOpaque = function () {\n  return !this.hasAlpha;\n};\n\nproto.isTransparent = function () {\n  return this.hasAlpha;\n};\n\nproto.pickSlots = 1;\n\nproto.setPickBase = function (id) {\n  this.pickId = id;\n};\n\nfunction getOpacityFromScale(ratio, opacityscale) {\n  if (!opacityscale) return 1;\n  if (!opacityscale.length) return 1;\n\n  for (var i = 0; i < opacityscale.length; ++i) {\n    if (opacityscale.length < 2) return 1;\n    if (opacityscale[i][0] === ratio) return opacityscale[i][1];\n\n    if (opacityscale[i][0] > ratio && i > 0) {\n      var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);\n      return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];\n    }\n  }\n\n  return 1;\n}\n\nfunction genColormap(param, opacityscale) {\n  var colors = colormap({\n    colormap: param,\n    nshades: 256,\n    format: 'rgba'\n  });\n  var result = new Uint8Array(256 * 4);\n\n  for (var i = 0; i < 256; ++i) {\n    var c = colors[i];\n\n    for (var j = 0; j < 3; ++j) {\n      result[4 * i + j] = c[j];\n    }\n\n    if (!opacityscale) {\n      result[4 * i + 3] = 255 * c[3];\n    } else {\n      result[4 * i + 3] = 255 * getOpacityFromScale(i / 255.0, opacityscale);\n    }\n  }\n\n  return ndarray(result, [256, 256, 4], [4, 0, 1]);\n}\n\nfunction unpackIntensity(cells, numVerts, cellIntensity) {\n  var result = new Array(numVerts);\n\n  for (var i = 0; i < numVerts; ++i) {\n    result[i] = 0;\n  }\n\n  var numCells = cells.length;\n\n  for (var i = 0; i < numCells; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      result[c[j]] = cellIntensity[i];\n    }\n  }\n\n  return result;\n}\n\nfunction takeZComponent(array) {\n  var n = array.length;\n  var result = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    result[i] = array[i][2];\n  }\n\n  return result;\n}\n\nproto.highlight = function (selection) {\n  if (!selection || !this.contourEnable) {\n    this.contourCount = 0;\n    return;\n  }\n\n  var level = getContour(this.cells, this.intensity, selection.intensity);\n  var cells = level.cells;\n  var vertexIds = level.vertexIds;\n  var vertexWeights = level.vertexWeights;\n  var numCells = cells.length;\n  var result = pool.mallocFloat32(2 * 3 * numCells);\n  var ptr = 0;\n\n  for (var i = 0; i < numCells; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < 2; ++j) {\n      var v = c[0];\n\n      if (c.length === 2) {\n        v = c[j];\n      }\n\n      var a = vertexIds[v][0];\n      var b = vertexIds[v][1];\n      var w = vertexWeights[v];\n      var wi = 1.0 - w;\n      var pa = this.positions[a];\n      var pb = this.positions[b];\n\n      for (var k = 0; k < 3; ++k) {\n        result[ptr++] = w * pa[k] + wi * pb[k];\n      }\n    }\n  }\n\n  this.contourCount = ptr / 3 | 0;\n  this.contourPositions.update(result.subarray(0, ptr));\n  pool.free(result);\n};\n\nproto.update = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  this.dirty = true;\n\n  if ('contourEnable' in params) {\n    this.contourEnable = params.contourEnable;\n  }\n\n  if ('contourColor' in params) {\n    this.contourColor = params.contourColor;\n  }\n\n  if ('lineWidth' in params) {\n    this.lineWidth = params.lineWidth;\n  }\n\n  if ('lightPosition' in params) {\n    this.lightPosition = params.lightPosition;\n  }\n\n  this.hasAlpha = false; // default to no transparent draw\n\n  if ('opacity' in params) {\n    this.opacity = params.opacity;\n\n    if (this.opacity < 1) {\n      this.hasAlpha = true;\n    }\n  }\n\n  if ('opacityscale' in params) {\n    this.opacityscale = params.opacityscale;\n    this.hasAlpha = true;\n  }\n\n  if ('ambient' in params) {\n    this.ambientLight = params.ambient;\n  }\n\n  if ('diffuse' in params) {\n    this.diffuseLight = params.diffuse;\n  }\n\n  if ('specular' in params) {\n    this.specularLight = params.specular;\n  }\n\n  if ('roughness' in params) {\n    this.roughness = params.roughness;\n  }\n\n  if ('fresnel' in params) {\n    this.fresnel = params.fresnel;\n  }\n\n  if (params.texture) {\n    this.texture.dispose();\n    this.texture = createTexture(gl, params.texture);\n  } else if (params.colormap) {\n    this.texture.shape = [256, 256];\n    this.texture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n    this.texture.magFilter = gl.LINEAR;\n    this.texture.setPixels(genColormap(params.colormap, this.opacityscale));\n    this.texture.generateMipmap();\n  }\n\n  var cells = params.cells;\n  var positions = params.positions;\n\n  if (!positions || !cells) {\n    return;\n  }\n\n  var tPos = [];\n  var tCol = [];\n  var tNor = [];\n  var tUVs = [];\n  var tIds = [];\n  var ePos = [];\n  var eCol = [];\n  var eUVs = [];\n  var eIds = [];\n  var pPos = [];\n  var pCol = [];\n  var pUVs = [];\n  var pSiz = [];\n  var pIds = []; //Save geometry data for picking calculations\n\n  this.cells = cells;\n  this.positions = positions; //Compute normals\n\n  var vertexNormals = params.vertexNormals;\n  var cellNormals = params.cellNormals;\n  var vertexNormalsEpsilon = params.vertexNormalsEpsilon === void 0 ? DEFAULT_VERTEX_NORMALS_EPSILON : params.vertexNormalsEpsilon;\n  var faceNormalsEpsilon = params.faceNormalsEpsilon === void 0 ? DEFAULT_FACE_NORMALS_EPSILON : params.faceNormalsEpsilon;\n\n  if (params.useFacetNormals && !cellNormals) {\n    cellNormals = normals.faceNormals(cells, positions, faceNormalsEpsilon);\n  }\n\n  if (!cellNormals && !vertexNormals) {\n    vertexNormals = normals.vertexNormals(cells, positions, vertexNormalsEpsilon);\n  } //Compute colors\n\n\n  var vertexColors = params.vertexColors;\n  var cellColors = params.cellColors;\n  var meshColor = params.meshColor || [1, 1, 1, 1]; //UVs\n\n  var vertexUVs = params.vertexUVs;\n  var vertexIntensity = params.vertexIntensity;\n  var cellUVs = params.cellUVs;\n  var cellIntensity = params.cellIntensity;\n  var intensityLo = Infinity;\n  var intensityHi = -Infinity;\n\n  if (!vertexUVs && !cellUVs) {\n    if (vertexIntensity) {\n      if (params.vertexIntensityBounds) {\n        intensityLo = +params.vertexIntensityBounds[0];\n        intensityHi = +params.vertexIntensityBounds[1];\n      } else {\n        for (var i = 0; i < vertexIntensity.length; ++i) {\n          var f = vertexIntensity[i];\n          intensityLo = Math.min(intensityLo, f);\n          intensityHi = Math.max(intensityHi, f);\n        }\n      }\n    } else if (cellIntensity) {\n      for (var i = 0; i < cellIntensity.length; ++i) {\n        var f = cellIntensity[i];\n        intensityLo = Math.min(intensityLo, f);\n        intensityHi = Math.max(intensityHi, f);\n      }\n    } else {\n      for (var i = 0; i < positions.length; ++i) {\n        var f = positions[i][2];\n        intensityLo = Math.min(intensityLo, f);\n        intensityHi = Math.max(intensityHi, f);\n      }\n    }\n  }\n\n  if (vertexIntensity) {\n    this.intensity = vertexIntensity;\n  } else if (cellIntensity) {\n    this.intensity = unpackIntensity(cells, positions.length, cellIntensity);\n  } else {\n    this.intensity = takeZComponent(positions);\n  } //Point size\n\n\n  var pointSizes = params.pointSizes;\n  var meshPointSize = params.pointSize || 1.0; //Update bounds\n\n  this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n\n  for (var i = 0; i < positions.length; ++i) {\n    var p = positions[i];\n\n    for (var j = 0; j < 3; ++j) {\n      if (isNaN(p[j]) || !isFinite(p[j])) {\n        continue;\n      }\n\n      this.bounds[0][j] = Math.min(this.bounds[0][j], p[j]);\n      this.bounds[1][j] = Math.max(this.bounds[1][j], p[j]);\n    }\n  } //Pack cells into buffers\n\n\n  var triangleCount = 0;\n  var edgeCount = 0;\n  var pointCount = 0;\n\n  fill_loop: for (var i = 0; i < cells.length; ++i) {\n    var cell = cells[i];\n\n    switch (cell.length) {\n      case 1:\n        var v = cell[0];\n        var p = positions[v]; //Check NaNs\n\n        for (var j = 0; j < 3; ++j) {\n          if (isNaN(p[j]) || !isFinite(p[j])) {\n            continue fill_loop;\n          }\n        }\n\n        pPos.push(p[0], p[1], p[2]);\n        var c;\n\n        if (vertexColors) {\n          c = vertexColors[v];\n        } else if (cellColors) {\n          c = cellColors[i];\n        } else {\n          c = meshColor;\n        }\n\n        if (this.opacityscale && vertexIntensity) {\n          tCol.push(c[0], c[1], c[2], this.opacity * getOpacityFromScale((vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), this.opacityscale));\n        } else if (c.length === 3) {\n          pCol.push(c[0], c[1], c[2], this.opacity);\n        } else {\n          pCol.push(c[0], c[1], c[2], c[3] * this.opacity);\n          if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n        }\n\n        var uv;\n\n        if (vertexUVs) {\n          uv = vertexUVs[v];\n        } else if (vertexIntensity) {\n          uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n        } else if (cellUVs) {\n          uv = cellUVs[i];\n        } else if (cellIntensity) {\n          uv = [(cellIntensity[i] - intensityLo) / (intensityHi - intensityLo), 0];\n        } else {\n          uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n        }\n\n        pUVs.push(uv[0], uv[1]);\n\n        if (pointSizes) {\n          pSiz.push(pointSizes[v]);\n        } else {\n          pSiz.push(meshPointSize);\n        }\n\n        pIds.push(i);\n        pointCount += 1;\n        break;\n\n      case 2:\n        //Check NaNs\n        for (var j = 0; j < 2; ++j) {\n          var v = cell[j];\n          var p = positions[v];\n\n          for (var k = 0; k < 3; ++k) {\n            if (isNaN(p[k]) || !isFinite(p[k])) {\n              continue fill_loop;\n            }\n          }\n        }\n\n        for (var j = 0; j < 2; ++j) {\n          var v = cell[j];\n          var p = positions[v];\n          ePos.push(p[0], p[1], p[2]);\n          var c;\n\n          if (vertexColors) {\n            c = vertexColors[v];\n          } else if (cellColors) {\n            c = cellColors[i];\n          } else {\n            c = meshColor;\n          }\n\n          if (this.opacityscale && vertexIntensity) {\n            tCol.push(c[0], c[1], c[2], this.opacity * getOpacityFromScale((vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), this.opacityscale));\n          } else if (c.length === 3) {\n            eCol.push(c[0], c[1], c[2], this.opacity);\n          } else {\n            eCol.push(c[0], c[1], c[2], c[3] * this.opacity);\n            if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n          }\n\n          var uv;\n\n          if (vertexUVs) {\n            uv = vertexUVs[v];\n          } else if (vertexIntensity) {\n            uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n          } else if (cellUVs) {\n            uv = cellUVs[i];\n          } else if (cellIntensity) {\n            uv = [(cellIntensity[i] - intensityLo) / (intensityHi - intensityLo), 0];\n          } else {\n            uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n          }\n\n          eUVs.push(uv[0], uv[1]);\n          eIds.push(i);\n        }\n\n        edgeCount += 1;\n        break;\n\n      case 3:\n        //Check NaNs\n        for (var j = 0; j < 3; ++j) {\n          var v = cell[j];\n          var p = positions[v];\n\n          for (var k = 0; k < 3; ++k) {\n            if (isNaN(p[k]) || !isFinite(p[k])) {\n              continue fill_loop;\n            }\n          }\n        }\n\n        for (var j = 0; j < 3; ++j) {\n          var v = cell[2 - j];\n          var p = positions[v];\n          tPos.push(p[0], p[1], p[2]);\n          var c;\n\n          if (vertexColors) {\n            c = vertexColors[v];\n          } else if (cellColors) {\n            c = cellColors[i];\n          } else {\n            c = meshColor;\n          }\n\n          if (this.opacityscale && vertexIntensity) {\n            tCol.push(c[0], c[1], c[2], this.opacity * getOpacityFromScale((vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), this.opacityscale));\n          } else if (c.length === 3) {\n            tCol.push(c[0], c[1], c[2], this.opacity);\n          } else {\n            tCol.push(c[0], c[1], c[2], c[3] * this.opacity);\n            if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n          }\n\n          var uv;\n\n          if (vertexUVs) {\n            uv = vertexUVs[v];\n          } else if (vertexIntensity) {\n            uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n          } else if (cellUVs) {\n            uv = cellUVs[i];\n          } else if (cellIntensity) {\n            uv = [(cellIntensity[i] - intensityLo) / (intensityHi - intensityLo), 0];\n          } else {\n            uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n          }\n\n          tUVs.push(uv[0], uv[1]);\n          var q;\n\n          if (vertexNormals) {\n            q = vertexNormals[v];\n          } else {\n            q = cellNormals[i];\n          }\n\n          tNor.push(q[0], q[1], q[2]);\n          tIds.push(i);\n        }\n\n        triangleCount += 1;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  this.pointCount = pointCount;\n  this.edgeCount = edgeCount;\n  this.triangleCount = triangleCount;\n  this.pointPositions.update(pPos);\n  this.pointColors.update(pCol);\n  this.pointUVs.update(pUVs);\n  this.pointSizes.update(pSiz);\n  this.pointIds.update(new Uint32Array(pIds));\n  this.edgePositions.update(ePos);\n  this.edgeColors.update(eCol);\n  this.edgeUVs.update(eUVs);\n  this.edgeIds.update(new Uint32Array(eIds));\n  this.trianglePositions.update(tPos);\n  this.triangleColors.update(tCol);\n  this.triangleUVs.update(tUVs);\n  this.triangleNormals.update(tNor);\n  this.triangleIds.update(new Uint32Array(tIds));\n};\n\nproto.drawTransparent = proto.draw = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  var model = params.model || IDENTITY;\n  var view = params.view || IDENTITY;\n  var projection = params.projection || IDENTITY;\n  var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n  for (var i = 0; i < 3; ++i) {\n    clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n    clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n  }\n\n  var uniforms = {\n    model: model,\n    view: view,\n    projection: projection,\n    inverseModel: IDENTITY.slice(),\n    clipBounds: clipBounds,\n    kambient: this.ambientLight,\n    kdiffuse: this.diffuseLight,\n    kspecular: this.specularLight,\n    roughness: this.roughness,\n    fresnel: this.fresnel,\n    eyePosition: [0, 0, 0],\n    lightPosition: [0, 0, 0],\n    contourColor: this.contourColor,\n    texture: 0\n  };\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n  gl.disable(gl.CULL_FACE);\n  this.texture.bind(0);\n  var invCameraMatrix = new Array(16);\n  multiply(invCameraMatrix, uniforms.view, uniforms.model);\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n  invert(invCameraMatrix, invCameraMatrix);\n\n  for (var i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n  }\n\n  var w = invCameraMatrix[15];\n\n  for (var i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i];\n\n    for (var j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n    }\n\n    uniforms.lightPosition[i] = s / w;\n  }\n\n  if (this.triangleCount > 0) {\n    var shader = this.triShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    this.triangleVAO.bind();\n    gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n    this.triangleVAO.unbind();\n  }\n\n  if (this.edgeCount > 0 && this.lineWidth > 0) {\n    var shader = this.lineShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    this.edgeVAO.bind();\n    gl.lineWidth(this.lineWidth * this.pixelRatio);\n    gl.drawArrays(gl.LINES, 0, this.edgeCount * 2);\n    this.edgeVAO.unbind();\n  }\n\n  if (this.pointCount > 0) {\n    var shader = this.pointShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    this.pointVAO.bind();\n    gl.drawArrays(gl.POINTS, 0, this.pointCount);\n    this.pointVAO.unbind();\n  }\n\n  if (this.contourEnable && this.contourCount > 0 && this.contourLineWidth > 0) {\n    var shader = this.contourShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    this.contourVAO.bind();\n    gl.drawArrays(gl.LINES, 0, this.contourCount);\n    this.contourVAO.unbind();\n  }\n};\n\nproto.drawPick = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  var model = params.model || IDENTITY;\n  var view = params.view || IDENTITY;\n  var projection = params.projection || IDENTITY;\n  var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n  for (var i = 0; i < 3; ++i) {\n    clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n    clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n  } //Save camera parameters\n\n\n  this._model = [].slice.call(model);\n  this._view = [].slice.call(view);\n  this._projection = [].slice.call(projection);\n  this._resolution = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  var uniforms = {\n    model: model,\n    view: view,\n    projection: projection,\n    clipBounds: clipBounds,\n    pickId: this.pickId / 255.0\n  };\n  var shader = this.pickShader;\n  shader.bind();\n  shader.uniforms = uniforms;\n\n  if (this.triangleCount > 0) {\n    this.triangleVAO.bind();\n    gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n    this.triangleVAO.unbind();\n  }\n\n  if (this.edgeCount > 0) {\n    this.edgeVAO.bind();\n    gl.lineWidth(this.lineWidth * this.pixelRatio);\n    gl.drawArrays(gl.LINES, 0, this.edgeCount * 2);\n    this.edgeVAO.unbind();\n  }\n\n  if (this.pointCount > 0) {\n    var shader = this.pointPickShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    this.pointVAO.bind();\n    gl.drawArrays(gl.POINTS, 0, this.pointCount);\n    this.pointVAO.unbind();\n  }\n};\n\nproto.pick = function (pickData) {\n  if (!pickData) {\n    return null;\n  }\n\n  if (pickData.id !== this.pickId) {\n    return null;\n  }\n\n  var cellId = pickData.value[0] + 256 * pickData.value[1] + 65536 * pickData.value[2];\n  var cell = this.cells[cellId];\n  var positions = this.positions;\n  var simplex = new Array(cell.length);\n\n  for (var i = 0; i < cell.length; ++i) {\n    simplex[i] = positions[cell[i]];\n  }\n\n  var data = closestPoint(simplex, [pickData.coord[0], this._resolution[1] - pickData.coord[1]], this._model, this._view, this._projection, this._resolution);\n\n  if (!data) {\n    return null;\n  }\n\n  var weights = data[2];\n  var interpIntensity = 0.0;\n\n  for (var i = 0; i < cell.length; ++i) {\n    interpIntensity += weights[i] * this.intensity[cell[i]];\n  }\n\n  return {\n    position: data[1],\n    index: cell[data[0]],\n    cell: cell,\n    cellId: cellId,\n    intensity: interpIntensity,\n    dataCoordinate: this.positions[cell[data[0]]]\n  };\n};\n\nproto.dispose = function () {\n  this.texture.dispose();\n  this.triShader.dispose();\n  this.lineShader.dispose();\n  this.pointShader.dispose();\n  this.pickShader.dispose();\n  this.pointPickShader.dispose();\n  this.triangleVAO.dispose();\n  this.trianglePositions.dispose();\n  this.triangleColors.dispose();\n  this.triangleUVs.dispose();\n  this.triangleNormals.dispose();\n  this.triangleIds.dispose();\n  this.edgeVAO.dispose();\n  this.edgePositions.dispose();\n  this.edgeColors.dispose();\n  this.edgeUVs.dispose();\n  this.edgeIds.dispose();\n  this.pointVAO.dispose();\n  this.pointPositions.dispose();\n  this.pointColors.dispose();\n  this.pointUVs.dispose();\n  this.pointSizes.dispose();\n  this.pointIds.dispose();\n  this.contourVAO.dispose();\n  this.contourPositions.dispose();\n  this.contourShader.dispose();\n};\n\nfunction createMeshShader(gl) {\n  var shader = createShader(gl, meshShader.vertex, meshShader.fragment);\n  shader.attributes.position.location = 0;\n  shader.attributes.color.location = 2;\n  shader.attributes.uv.location = 3;\n  shader.attributes.normal.location = 4;\n  return shader;\n}\n\nfunction createWireShader(gl) {\n  var shader = createShader(gl, wireShader.vertex, wireShader.fragment);\n  shader.attributes.position.location = 0;\n  shader.attributes.color.location = 2;\n  shader.attributes.uv.location = 3;\n  return shader;\n}\n\nfunction createPointShader(gl) {\n  var shader = createShader(gl, pointShader.vertex, pointShader.fragment);\n  shader.attributes.position.location = 0;\n  shader.attributes.color.location = 2;\n  shader.attributes.uv.location = 3;\n  shader.attributes.pointSize.location = 4;\n  return shader;\n}\n\nfunction createPickShader(gl) {\n  var shader = createShader(gl, pickShader.vertex, pickShader.fragment);\n  shader.attributes.position.location = 0;\n  shader.attributes.id.location = 1;\n  return shader;\n}\n\nfunction createPointPickShader(gl) {\n  var shader = createShader(gl, pointPickShader.vertex, pointPickShader.fragment);\n  shader.attributes.position.location = 0;\n  shader.attributes.id.location = 1;\n  shader.attributes.pointSize.location = 4;\n  return shader;\n}\n\nfunction createContourShader(gl) {\n  var shader = createShader(gl, contourShader.vertex, contourShader.fragment);\n  shader.attributes.position.location = 0;\n  return shader;\n}\n\nfunction createSimplicialMesh(gl, params) {\n  if (arguments.length === 1) {\n    params = gl;\n    gl = params.gl;\n  } //enable derivatives for face normals\n\n\n  var ext = gl.getExtension('OES_standard_derivatives') || gl.getExtension('MOZ_OES_standard_derivatives') || gl.getExtension('WEBKIT_OES_standard_derivatives');\n  if (!ext) throw new Error('derivatives not supported');\n  var triShader = createMeshShader(gl);\n  var lineShader = createWireShader(gl);\n  var pointShader = createPointShader(gl);\n  var pickShader = createPickShader(gl);\n  var pointPickShader = createPointPickShader(gl);\n  var contourShader = createContourShader(gl);\n  var meshTexture = createTexture(gl, ndarray(new Uint8Array([255, 255, 255, 255]), [1, 1, 4]));\n  meshTexture.generateMipmap();\n  meshTexture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n  meshTexture.magFilter = gl.LINEAR;\n  var trianglePositions = createBuffer(gl);\n  var triangleColors = createBuffer(gl);\n  var triangleUVs = createBuffer(gl);\n  var triangleNormals = createBuffer(gl);\n  var triangleIds = createBuffer(gl);\n  var triangleVAO = createVAO(gl, [{\n    buffer: trianglePositions,\n    type: gl.FLOAT,\n    size: 3\n  }, {\n    buffer: triangleIds,\n    type: gl.UNSIGNED_BYTE,\n    size: 4,\n    normalized: true\n  }, {\n    buffer: triangleColors,\n    type: gl.FLOAT,\n    size: 4\n  }, {\n    buffer: triangleUVs,\n    type: gl.FLOAT,\n    size: 2\n  }, {\n    buffer: triangleNormals,\n    type: gl.FLOAT,\n    size: 3\n  }]);\n  var edgePositions = createBuffer(gl);\n  var edgeColors = createBuffer(gl);\n  var edgeUVs = createBuffer(gl);\n  var edgeIds = createBuffer(gl);\n  var edgeVAO = createVAO(gl, [{\n    buffer: edgePositions,\n    type: gl.FLOAT,\n    size: 3\n  }, {\n    buffer: edgeIds,\n    type: gl.UNSIGNED_BYTE,\n    size: 4,\n    normalized: true\n  }, {\n    buffer: edgeColors,\n    type: gl.FLOAT,\n    size: 4\n  }, {\n    buffer: edgeUVs,\n    type: gl.FLOAT,\n    size: 2\n  }]);\n  var pointPositions = createBuffer(gl);\n  var pointColors = createBuffer(gl);\n  var pointUVs = createBuffer(gl);\n  var pointSizes = createBuffer(gl);\n  var pointIds = createBuffer(gl);\n  var pointVAO = createVAO(gl, [{\n    buffer: pointPositions,\n    type: gl.FLOAT,\n    size: 3\n  }, {\n    buffer: pointIds,\n    type: gl.UNSIGNED_BYTE,\n    size: 4,\n    normalized: true\n  }, {\n    buffer: pointColors,\n    type: gl.FLOAT,\n    size: 4\n  }, {\n    buffer: pointUVs,\n    type: gl.FLOAT,\n    size: 2\n  }, {\n    buffer: pointSizes,\n    type: gl.FLOAT,\n    size: 1\n  }]);\n  var contourPositions = createBuffer(gl);\n  var contourVAO = createVAO(gl, [{\n    buffer: contourPositions,\n    type: gl.FLOAT,\n    size: 3\n  }]);\n  var mesh = new SimplicialMesh(gl, meshTexture, triShader, lineShader, pointShader, pickShader, pointPickShader, contourShader, trianglePositions, triangleIds, triangleColors, triangleUVs, triangleNormals, triangleVAO, edgePositions, edgeIds, edgeColors, edgeUVs, edgeVAO, pointPositions, pointIds, pointColors, pointUVs, pointSizes, pointVAO, contourPositions, contourVAO);\n  mesh.update(params);\n  return mesh;\n}\n\nmodule.exports = createSimplicialMesh;","map":null,"metadata":{},"sourceType":"script"}