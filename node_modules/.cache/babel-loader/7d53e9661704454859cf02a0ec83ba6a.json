{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar partition = require('./partition');\n\nvar styleOne = require('./style').styleOne;\n\nvar constants = require('./constants');\n\nvar helpers = require('../sunburst/helpers');\n\nvar attachFxHandlers = require('../sunburst/fx');\n\nvar onPathbar = true; // for Ancestors\n\nmodule.exports = function drawAncestors(gd, cd, entry, slices, opts) {\n  var barDifY = opts.barDifY;\n  var width = opts.width;\n  var height = opts.height;\n  var viewX = opts.viewX;\n  var viewY = opts.viewY;\n  var pathSlice = opts.pathSlice;\n  var toMoveInsideSlice = opts.toMoveInsideSlice;\n  var strTransform = opts.strTransform;\n  var hasTransition = opts.hasTransition;\n  var handleSlicesExit = opts.handleSlicesExit;\n  var makeUpdateSliceInterpolator = opts.makeUpdateSliceInterpolator;\n  var makeUpdateTextInterpolator = opts.makeUpdateTextInterpolator;\n  var refRect = {};\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var eachWidth = width / trace._entryDepth;\n  var pathIds = helpers.listPath(entry.data, 'id');\n  var sliceData = partition(hierarchy.copy(), [width, height], {\n    packing: 'dice',\n    pad: {\n      inner: 0,\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    }\n  }).descendants(); // edit slices that show up on graph\n\n  sliceData = sliceData.filter(function (pt) {\n    var level = pathIds.indexOf(pt.data.id);\n    if (level === -1) return false;\n    pt.x0 = eachWidth * level;\n    pt.x1 = eachWidth * (level + 1);\n    pt.y0 = barDifY;\n    pt.y1 = barDifY + height;\n    pt.onPathbar = true;\n    return true;\n  });\n  sliceData.reverse();\n  slices = slices.data(sliceData, helpers.getPtId);\n  slices.enter().append('g').classed('pathbar', true);\n  handleSlicesExit(slices, onPathbar, refRect, [width, height], pathSlice);\n  slices.order();\n  var updateSlices = slices;\n\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: false,\n        hideOnLeaves: false,\n        isTransitioning: false\n      });\n    });\n  }\n\n  updateSlices.each(function (pt) {\n    pt._hoverX = viewX(pt.x1 - height / 2);\n    pt._hoverY = viewY(pt.y1 - height / 2);\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', 'all');\n    });\n\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      styleOne: styleOne,\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      hideOnRoot: false,\n      hideOnLeaves: false,\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace, {\n      hovered: false\n    });\n    pt._text = (helpers.getPtLabel(pt) || '').split('<br>').join(' ') || '';\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    sliceText.text(pt._text || ' ') // use one space character instead of a blank string to avoid jumps during transition\n    .classed('slicetext', true).attr('text-anchor', 'start').call(Drawing.font, helpers.determineTextFont(trace, pt, fullLayout.font, trace.pathdir)).call(svgTextUtils.convertToTspans, gd);\n    pt.textBB = Drawing.bBox(sliceText.node());\n    pt.transform = toMoveInsideSlice(pt, {\n      onPathbar: true\n    });\n\n    if (helpers.isOutsideText(trace, pt)) {\n      // consider in/out diff font sizes\n      pt.transform.targetY -= helpers.getOutsideTextFontKey('size', trace, pt, fullLayout.font) - helpers.getInsideTextFontKey('size', trace, pt, fullLayout.font);\n    }\n\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2, onPathbar, refRect, [width, height]);\n        return function (t) {\n          return strTransform(interp(t));\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt));\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}