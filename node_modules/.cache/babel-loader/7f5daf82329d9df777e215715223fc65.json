{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar getAxisGroup = require('../../plots/cartesian/axis_ids').getAxisGroup;\n\nvar orientations = ['v', 'h'];\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var calcdata = gd.calcdata;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n\n  for (var i = 0; i < orientations.length; i++) {\n    var orientation = orientations[i];\n    var posAxis = orientation === 'h' ? ya : xa;\n    var boxList = []; // make list of boxes / candlesticks\n    // For backward compatibility, candlesticks are treated as if they *are* box traces here\n\n    for (var j = 0; j < calcdata.length; j++) {\n      var cd = calcdata[j];\n      var t = cd[0].t;\n      var trace = cd[0].trace;\n\n      if (trace.visible === true && (trace.type === 'box' || trace.type === 'candlestick') && !t.empty && (trace.orientation || 'v') === orientation && trace.xaxis === xa._id && trace.yaxis === ya._id) {\n        boxList.push(j);\n      }\n    }\n\n    setPositionOffset('box', gd, boxList, posAxis);\n  }\n}\n\nfunction setPositionOffset(traceType, gd, boxList, posAxis) {\n  var calcdata = gd.calcdata;\n  var fullLayout = gd._fullLayout;\n  var axId = posAxis._id;\n  var axLetter = axId.charAt(0);\n  var i, j, calcTrace;\n  var pointList = [];\n  var shownPts = 0; // make list of box points\n\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n\n    for (j = 0; j < calcTrace.length; j++) {\n      pointList.push(posAxis.c2l(calcTrace[j].pos, true));\n      shownPts += (calcTrace[j].pts2 || []).length;\n    }\n  }\n\n  if (!pointList.length) return; // box plots - update dPos based on multiple traces\n\n  var boxdv = Lib.distinctVals(pointList);\n  var dPos0 = boxdv.minDiff / 2; // check for forced minimum dtick\n\n  Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);\n  var numKey = traceType === 'violin' ? '_numViolins' : '_numBoxes';\n  var numTotal = fullLayout[numKey];\n  var group = fullLayout[traceType + 'mode'] === 'group' && numTotal > 1;\n  var groupFraction = 1 - fullLayout[traceType + 'gap'];\n  var groupGapFraction = 1 - fullLayout[traceType + 'groupgap'];\n\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n    var trace = calcTrace[0].trace;\n    var t = calcTrace[0].t;\n    var width = trace.width;\n    var side = trace.side; // position coordinate delta\n\n    var dPos; // box half width;\n\n    var bdPos; // box center offset\n\n    var bPos; // half-width within which to accept hover for this box/violin\n    // always split the distance to the closest box/violin\n\n    var wHover;\n\n    if (width) {\n      dPos = bdPos = wHover = width / 2;\n      bPos = 0;\n    } else {\n      dPos = dPos0;\n\n      if (group) {\n        var groupId = getAxisGroup(fullLayout, posAxis._id) + trace.orientation;\n        var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n        var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n        var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n        var num = nOffsetGroups || numTotal;\n        var shift = nOffsetGroups ? trace._offsetIndex : t.num;\n        bdPos = dPos * groupFraction * groupGapFraction / num;\n        bPos = 2 * dPos * (-0.5 + (shift + 0.5) / num) * groupFraction;\n        wHover = dPos * groupFraction / num;\n      } else {\n        bdPos = dPos * groupFraction * groupGapFraction;\n        bPos = 0;\n        wHover = dPos;\n      }\n    }\n\n    t.dPos = dPos;\n    t.bPos = bPos;\n    t.bdPos = bdPos;\n    t.wHover = wHover; // box/violin-only value-space push value\n\n    var pushplus;\n    var pushminus; // edge of box/violin\n\n    var edge = bPos + bdPos;\n    var edgeplus;\n    var edgeminus; // value-space padding\n\n    var vpadplus;\n    var vpadminus; // pixel-space padding\n\n    var ppadplus;\n    var ppadminus; // do we add 5% of both sides (more logic for points beyond box/violin below)\n\n    var padded = Boolean(width); // does this trace show points?\n\n    var hasPts = (trace.boxpoints || trace.points) && shownPts > 0;\n\n    if (side === 'positive') {\n      pushplus = dPos * (width ? 1 : 0.5);\n      edgeplus = edge;\n      pushminus = edgeplus = bPos;\n    } else if (side === 'negative') {\n      pushplus = edgeplus = bPos;\n      pushminus = dPos * (width ? 1 : 0.5);\n      edgeminus = edge;\n    } else {\n      pushplus = pushminus = dPos;\n      edgeplus = edgeminus = edge;\n    }\n\n    if (hasPts) {\n      var pointpos = trace.pointpos;\n      var jitter = trace.jitter;\n      var ms = trace.marker.size / 2;\n      var pp = 0;\n\n      if (pointpos + jitter >= 0) {\n        pp = edge * (pointpos + jitter);\n\n        if (pp > pushplus) {\n          // (++) beyond plus-value, use pp\n          padded = true;\n          ppadplus = ms;\n          vpadplus = pp;\n        } else if (pp > edgeplus) {\n          // (+), use push-value (it's bigger), but add px-pad\n          ppadplus = ms;\n          vpadplus = pushplus;\n        }\n      }\n\n      if (pp <= pushplus) {\n        // (->) fallback to push value\n        vpadplus = pushplus;\n      }\n\n      var pm = 0;\n\n      if (pointpos - jitter <= 0) {\n        pm = -edge * (pointpos - jitter);\n\n        if (pm > pushminus) {\n          // (--) beyond plus-value, use pp\n          padded = true;\n          ppadminus = ms;\n          vpadminus = pm;\n        } else if (pm > edgeminus) {\n          // (-), use push-value (it's bigger), but add px-pad\n          ppadminus = ms;\n          vpadminus = pushminus;\n        }\n      }\n\n      if (pm <= pushminus) {\n        // (<-) fallback to push value\n        vpadminus = pushminus;\n      }\n    } else {\n      vpadplus = pushplus;\n      vpadminus = pushminus;\n    }\n\n    var pos = new Array(calcTrace.length);\n\n    for (j = 0; j < calcTrace.length; j++) {\n      pos[j] = calcTrace[j].pos;\n    }\n\n    trace._extremes[axId] = Axes.findExtremes(posAxis, pos, {\n      padded: padded,\n      vpadminus: vpadminus,\n      vpadplus: vpadplus,\n      vpadLinearized: true,\n      // N.B. SVG px-space positive/negative\n      ppadminus: {\n        x: ppadminus,\n        y: ppadplus\n      }[axLetter],\n      ppadplus: {\n        x: ppadplus,\n        y: ppadminus\n      }[axLetter]\n    });\n  }\n}\n\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setPositionOffset: setPositionOffset\n};","map":null,"metadata":{},"sourceType":"script"}