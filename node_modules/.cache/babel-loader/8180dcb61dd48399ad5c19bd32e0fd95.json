{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar boxHoverPoints = require('../box/hover');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode, hoverLayer) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var hoveron = trace.hoveron;\n  var hasHoveronViolins = hoveron.indexOf('violins') !== -1;\n  var hasHoveronKDE = hoveron.indexOf('kde') !== -1;\n  var closeData = [];\n  var closePtData;\n  var violinLineAttrs;\n\n  if (hasHoveronViolins || hasHoveronKDE) {\n    var closeBoxData = boxHoverPoints.hoverOnBoxes(pointData, xval, yval, hovermode);\n\n    if (hasHoveronKDE && closeBoxData.length > 0) {\n      var xa = pointData.xa;\n      var ya = pointData.ya;\n      var pLetter, vLetter, pAxis, vAxis, vVal;\n\n      if (trace.orientation === 'h') {\n        vVal = xval;\n        pLetter = 'y';\n        pAxis = ya;\n        vLetter = 'x';\n        vAxis = xa;\n      } else {\n        vVal = yval;\n        pLetter = 'x';\n        pAxis = xa;\n        vLetter = 'y';\n        vAxis = ya;\n      }\n\n      var di = cd[pointData.index];\n\n      if (vVal >= di.span[0] && vVal <= di.span[1]) {\n        var kdePointData = Lib.extendFlat({}, pointData);\n        var vValPx = vAxis.c2p(vVal, true);\n        var kdeVal = helpers.getKdeValue(di, trace, vVal);\n        var pOnPath = helpers.getPositionOnKdePath(di, trace, vValPx);\n        var paOffset = pAxis._offset;\n        var paLength = pAxis._length;\n        kdePointData[pLetter + '0'] = pOnPath[0];\n        kdePointData[pLetter + '1'] = pOnPath[1];\n        kdePointData[vLetter + '0'] = kdePointData[vLetter + '1'] = vValPx;\n        kdePointData[vLetter + 'Label'] = vLetter + ': ' + Axes.hoverLabelText(vAxis, vVal) + ', ' + cd[0].t.labels.kde + ' ' + kdeVal.toFixed(3); // move the spike to the KDE point\n\n        kdePointData.spikeDistance = closeBoxData[0].spikeDistance;\n        var spikePosAttr = pLetter + 'Spike';\n        kdePointData[spikePosAttr] = closeBoxData[0][spikePosAttr];\n        closeBoxData[0].spikeDistance = undefined;\n        closeBoxData[0][spikePosAttr] = undefined; // no hovertemplate support yet\n\n        kdePointData.hovertemplate = false;\n        closeData.push(kdePointData);\n        violinLineAttrs = {\n          stroke: pointData.color\n        };\n        violinLineAttrs[pLetter + '1'] = Lib.constrain(paOffset + pOnPath[0], paOffset, paOffset + paLength);\n        violinLineAttrs[pLetter + '2'] = Lib.constrain(paOffset + pOnPath[1], paOffset, paOffset + paLength);\n        violinLineAttrs[vLetter + '1'] = violinLineAttrs[vLetter + '2'] = vAxis._offset + vValPx;\n      }\n    }\n\n    if (hasHoveronViolins) {\n      closeData = closeData.concat(closeBoxData);\n    }\n  }\n\n  if (hoveron.indexOf('points') !== -1) {\n    closePtData = boxHoverPoints.hoverOnPoints(pointData, xval, yval);\n  } // update violin line (if any)\n\n\n  var violinLine = hoverLayer.selectAll('.violinline-' + trace.uid).data(violinLineAttrs ? [0] : []);\n  violinLine.enter().append('line').classed('violinline-' + trace.uid, true).attr('stroke-width', 1.5);\n  violinLine.exit().remove();\n  violinLine.attr(violinLineAttrs); // same combine logic as box hoverPoints\n\n  if (hovermode === 'closest') {\n    if (closePtData) return [closePtData];\n    return closeData;\n  }\n\n  if (closePtData) {\n    closeData.push(closePtData);\n    return closeData;\n  }\n\n  return closeData;\n};","map":null,"metadata":{},"sourceType":"script"}