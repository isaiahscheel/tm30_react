{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar Fx = require('../../components/fx');\n\nvar Color = require('../../components/color');\n\nvar fillText = require('../../lib').fillText;\n\nvar delta = require('../../constants/delta.js');\n\nvar DIRSYMBOL = {\n  increasing: delta.INCREASING.SYMBOL,\n  decreasing: delta.DECREASING.SYMBOL\n};\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n\n  if (trace.hoverlabel.split) {\n    return hoverSplit(pointData, xval, yval, hovermode);\n  }\n\n  return hoverOnPoints(pointData, xval, yval, hovermode);\n}\n\nfunction getClosestPoint(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var type = trace.type;\n  var minAttr = type === 'ohlc' ? 'l' : 'min';\n  var maxAttr = type === 'ohlc' ? 'h' : 'max';\n  var hoverPseudoDistance, spikePseudoDistance; // potentially shift xval for grouped candlesticks\n\n  var centerShift = t.bPos || 0;\n\n  var shiftPos = function (di) {\n    return di.pos + centerShift - xval;\n  }; // ohlc and candlestick call displayHalfWidth different things...\n\n\n  var displayHalfWidth = t.bdPos || t.tickLen;\n  var hoverHalfWidth = t.wHover; // if two figures are overlaying, let the narrowest one win\n\n  var pseudoDistance = Math.min(1, displayHalfWidth / Math.abs(xa.r2c(xa.range[1]) - xa.r2c(xa.range[0])));\n  hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n  spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n  function dx(di) {\n    var pos = shiftPos(di);\n    return Fx.inbox(pos - hoverHalfWidth, pos + hoverHalfWidth, hoverPseudoDistance);\n  }\n\n  function dy(di) {\n    var min = di[minAttr];\n    var max = di[maxAttr];\n    return min === max || Fx.inbox(min - yval, max - yval, hoverPseudoDistance);\n  }\n\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData);\n  if (pointData.index === false) return null;\n  var di = cd[pointData.index];\n  if (di.empty) return null;\n  var dir = di.dir;\n  var container = trace[dir];\n  var lc = container.line.color;\n  if (Color.opacity(lc) && container.line.width) pointData.color = lc;else pointData.color = container.fillcolor;\n  pointData.x0 = xa.c2p(di.pos + centerShift - displayHalfWidth, true);\n  pointData.x1 = xa.c2p(di.pos + centerShift + displayHalfWidth, true);\n  pointData.xLabelVal = di.pos;\n  pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n  pointData.xSpike = xa.c2p(di.pos, true);\n  return pointData;\n}\n\nfunction hoverSplit(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var closeBoxData = [];\n  var closestPoint = getClosestPoint(pointData, xval, yval, hovermode); // skip the rest (for this trace) if we didn't find a close point\n\n  if (!closestPoint) return [];\n  var cdIndex = closestPoint.index;\n  var di = cd[cdIndex];\n  var hoverinfo = di.hi || trace.hoverinfo;\n  var hoverParts = hoverinfo.split('+');\n  var isAll = hoverinfo === 'all';\n  var hasY = isAll || hoverParts.indexOf('y') !== -1; // similar to hoverOnPoints, we return nothing\n  // if all or y is not present.\n\n  if (!hasY) return [];\n  var attrs = ['high', 'open', 'close', 'low']; // several attributes can have the same y-coordinate. We will\n  // bunch them together in a single text block. For this, we keep\n  // a dictionary mapping y-coord -> point data.\n\n  var usedVals = {};\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var val = trace[attr][closestPoint.index];\n    var valPx = ya.c2p(val, true);\n    var pointData2;\n\n    if (val in usedVals) {\n      pointData2 = usedVals[val];\n      pointData2.yLabel += '<br>' + t.labels[attr] + Axes.hoverLabelText(ya, val);\n    } else {\n      // copy out to a new object for each new y-value to label\n      pointData2 = Lib.extendFlat({}, closestPoint);\n      pointData2.y0 = pointData2.y1 = valPx;\n      pointData2.yLabelVal = val;\n      pointData2.yLabel = t.labels[attr] + Axes.hoverLabelText(ya, val);\n      pointData2.name = '';\n      closeBoxData.push(pointData2);\n      usedVals[val] = pointData2;\n    }\n  }\n\n  return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var closestPoint = getClosestPoint(pointData, xval, yval, hovermode); // skip the rest (for this trace) if we didn't find a close point\n\n  if (!closestPoint) return []; // we don't make a calcdata point if we're missing any piece (x/o/h/l/c)\n  // so we need to fix the index here to point to the data arrays\n\n  var cdIndex = closestPoint.index;\n  var di = cd[cdIndex];\n  var i = closestPoint.index = di.i;\n  var dir = di.dir;\n\n  function getLabelLine(attr) {\n    return t.labels[attr] + Axes.hoverLabelText(ya, trace[attr][i]);\n  }\n\n  var hoverinfo = di.hi || trace.hoverinfo;\n  var hoverParts = hoverinfo.split('+');\n  var isAll = hoverinfo === 'all';\n  var hasY = isAll || hoverParts.indexOf('y') !== -1;\n  var hasText = isAll || hoverParts.indexOf('text') !== -1;\n  var textParts = hasY ? [getLabelLine('open'), getLabelLine('high'), getLabelLine('low'), getLabelLine('close') + '  ' + DIRSYMBOL[dir]] : [];\n  if (hasText) fillText(di, trace, textParts); // don't make .yLabelVal or .text, since we're managing hoverinfo\n  // put it all in .extraText\n\n  closestPoint.extraText = textParts.join('<br>'); // this puts the label *and the spike* at the midpoint of the box, ie\n  // halfway between open and close, not between high and low.\n\n  closestPoint.y0 = closestPoint.y1 = ya.c2p(di.yc, true);\n  return [closestPoint];\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverSplit: hoverSplit,\n  hoverOnPoints: hoverOnPoints\n};","map":null,"metadata":{},"sourceType":"script"}