{"ast":null,"code":"/*\n * World Calendars\n * https://github.com/alexcjohnson/world-calendars\n *\n * Batch-converted from kbwood/calendars\n * Many thanks to Keith Wood and all of the contributors to the original project!\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* http://keith-wood.name/calendars.html\n  Traditional Chinese calendar for jQuery v2.0.2.\n  Written by Nicolas Riesco (enquiries@nicolasriesco.net) December 2016.\n  Available under the MIT (http://keith-wood.name/licence.html) license. \n  Please attribute the author if you use it. */\nvar main = require('../main');\n\nvar assign = require('object-assign');\n\nvar gregorianCalendar = main.instance();\n/** Implementation of the traditional Chinese calendar.\n    Source of calendar tables https://github.com/isee15/Lunar-Solar-Calendar-Converter .\n    @class ChineseCalendar\n    @param [language=''] {string} The language code (default English) for localisation. */\n\nfunction ChineseCalendar(language) {\n  this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];\n}\n\nChineseCalendar.prototype = new main.baseCalendar();\nassign(ChineseCalendar.prototype, {\n  /** The calendar name.\n      @memberof ChineseCalendar */\n  name: 'Chinese',\n\n  /** Julian date of start of Gregorian epoch: 1 January 0001 CE.\n     @memberof GregorianCalendar */\n  jdEpoch: 1721425.5,\n\n  /** <code>true</code> if has a year zero, <code>false</code> if not.\n      @memberof ChineseCalendar */\n  hasYearZero: false,\n\n  /** The minimum month number.\n      This calendar uses month indices to account for intercalary months. \n      @memberof ChineseCalendar */\n  minMonth: 0,\n\n  /** The first month in the year.\n      This calendar uses month indices to account for intercalary months. \n      @memberof ChineseCalendar */\n  firstMonth: 0,\n\n  /** The minimum day number.\n      @memberof ChineseCalendar */\n  minDay: 1,\n\n  /** Localisations for the plugin.\n      Entries are objects indexed by the language code ('' being the default US/English).\n      Each object has the following attributes.\n      @memberof ChineseCalendar\n      @property name {string} The calendar name.\n      @property epochs {string[]} The epoch names.\n      @property monthNames {string[]} The long names of the months of the year.\n      @property monthNamesShort {string[]} The short names of the months of the year.\n      @property dayNames {string[]} The long names of the days of the week.\n      @property dayNamesShort {string[]} The short names of the days of the week.\n      @property dayNamesMin {string[]} The minimal names of the days of the week.\n      @property dateFormat {string} The date format for this calendar.\n              See the options on <a href=\"BaseCalendar.html#formatDate\"><code>formatDate</code></a> for details.\n      @property firstDay {number} The number of the first day of the week, starting at 0.\n      @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */\n  regionalOptions: {\n    // Localisations\n    '': {\n      name: 'Chinese',\n      epochs: ['BEC', 'EC'],\n      monthNumbers: function (date, padded) {\n        if (typeof date === 'string') {\n          var match = date.match(MONTH_NUMBER_REGEXP);\n          return match ? match[0] : '';\n        }\n\n        var year = this._validateYear(date);\n\n        var monthIndex = date.month();\n        var month = '' + this.toChineseMonth(year, monthIndex);\n\n        if (padded && month.length < 2) {\n          month = \"0\" + month;\n        }\n\n        if (this.isIntercalaryMonth(year, monthIndex)) {\n          month += 'i';\n        }\n\n        return month;\n      },\n      monthNames: function (date) {\n        if (typeof date === 'string') {\n          var match = date.match(MONTH_NAME_REGEXP);\n          return match ? match[0] : '';\n        }\n\n        var year = this._validateYear(date);\n\n        var monthIndex = date.month();\n        var month = this.toChineseMonth(year, monthIndex);\n        var monthName = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'][month - 1];\n\n        if (this.isIntercalaryMonth(year, monthIndex)) {\n          monthName = '闰' + monthName;\n        }\n\n        return monthName;\n      },\n      monthNamesShort: function (date) {\n        if (typeof date === 'string') {\n          var match = date.match(MONTH_SHORT_NAME_REGEXP);\n          return match ? match[0] : '';\n        }\n\n        var year = this._validateYear(date);\n\n        var monthIndex = date.month();\n        var month = this.toChineseMonth(year, monthIndex);\n        var monthName = ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'][month - 1];\n\n        if (this.isIntercalaryMonth(year, monthIndex)) {\n          monthName = '闰' + monthName;\n        }\n\n        return monthName;\n      },\n      parseMonth: function (year, monthString) {\n        year = this._validateYear(year);\n        var month = parseInt(monthString);\n        var isIntercalary;\n\n        if (!isNaN(month)) {\n          var i = monthString[monthString.length - 1];\n          isIntercalary = i === 'i' || i === 'I';\n        } else {\n          if (monthString[0] === '闰') {\n            isIntercalary = true;\n            monthString = monthString.substring(1);\n          }\n\n          if (monthString[monthString.length - 1] === '月') {\n            monthString = monthString.substring(0, monthString.length - 1);\n          }\n\n          month = 1 + ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'].indexOf(monthString);\n        }\n\n        var monthIndex = this.toMonthIndex(year, month, isIntercalary);\n        return monthIndex;\n      },\n      dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n      dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n      digits: null,\n      dateFormat: 'yyyy/mm/dd',\n      firstDay: 1,\n      isRTL: false\n    }\n  },\n\n  /** Check that a candidate date is from the same calendar and is valid.\n      @memberof BaseCalendar\n      @private\n      @param year {CDate|number} The date or the year to validate.\n      @param error {string} Error message if invalid.\n      @return {number} The year.\n      @throws Error if year out of range. */\n  _validateYear: function (year, error) {\n    if (year.year) {\n      year = year.year();\n    }\n\n    if (typeof year !== 'number' || year < 1888 || year > 2111) {\n      throw error.replace(/\\{0\\}/, this.local.name);\n    }\n\n    return year;\n  },\n\n  /** Retrieve the month index (i.e. accounting for intercalary months).\n      @memberof ChineseCalendar\n      @param year {number} The year.\n      @param month {number} The month (1 for first month).\n      @param [isIntercalary=false] {boolean} If month is intercalary.\n      @return {number} The month index (0 for first month).\n      @throws Error if an invalid month/year or a different calendar used. */\n  toMonthIndex: function (year, month, isIntercalary) {\n    // compute intercalary month in the year (0 if none)\n    var intercalaryMonth = this.intercalaryMonth(year); // validate month\n\n    var invalidIntercalaryMonth = isIntercalary && month !== intercalaryMonth;\n\n    if (invalidIntercalaryMonth || month < 1 || month > 12) {\n      throw main.local.invalidMonth.replace(/\\{0\\}/, this.local.name);\n    } // compute month index\n\n\n    var monthIndex;\n\n    if (!intercalaryMonth) {\n      monthIndex = month - 1;\n    } else if (!isIntercalary && month <= intercalaryMonth) {\n      monthIndex = month - 1;\n    } else {\n      monthIndex = month;\n    }\n\n    return monthIndex;\n  },\n\n  /** Retrieve the month (i.e. accounting for intercalary months).\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date or the year to examine.\n      @param monthIndex {number} The month index (0 for first month).\n      @return {number} The month (1 for first month).\n      @throws Error if an invalid month/year or a different calendar used. */\n  toChineseMonth: function (year, monthIndex) {\n    if (year.year) {\n      year = year.year();\n      monthIndex = year.month();\n    } // compute intercalary month in the year (0 if none)\n\n\n    var intercalaryMonth = this.intercalaryMonth(year); // validate month\n\n    var maxMonthIndex = intercalaryMonth ? 12 : 11;\n\n    if (monthIndex < 0 || monthIndex > maxMonthIndex) {\n      throw main.local.invalidMonth.replace(/\\{0\\}/, this.local.name);\n    } // compute Chinese month\n\n\n    var month;\n\n    if (!intercalaryMonth) {\n      month = monthIndex + 1;\n    } else if (monthIndex < intercalaryMonth) {\n      month = monthIndex + 1;\n    } else {\n      month = monthIndex;\n    }\n\n    return month;\n  },\n\n  /** Determine the intercalary month of a year (if any).\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to examine or the year to examine.\n      @return {number} The intercalary month number, or 0 if none.\n      @throws Error if an invalid year or a different calendar used. */\n  intercalaryMonth: function (year) {\n    year = this._validateYear(year);\n    var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];\n    var intercalaryMonth = monthDaysTable >> 13;\n    return intercalaryMonth;\n  },\n\n  /** Determine whether this date is an intercalary month.\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to examine or the year to examine.\n      @param [monthIndex] {number} The month index to examine.\n      @return {boolean} <code>true</code> if this is an intercalary month, <code>false</code> if not.\n      @throws Error if an invalid year or a different calendar used. */\n  isIntercalaryMonth: function (year, monthIndex) {\n    if (year.year) {\n      year = year.year();\n      monthIndex = year.month();\n    }\n\n    var intercalaryMonth = this.intercalaryMonth(year);\n    return !!intercalaryMonth && intercalaryMonth === monthIndex;\n  },\n\n  /** Determine whether this date is in a leap year.\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to examine or the year to examine.\n      @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.\n      @throws Error if an invalid year or a different calendar used. */\n  leapYear: function (year) {\n    return this.intercalaryMonth(year) !== 0;\n  },\n\n  /** Determine the week of the year for a date - ISO 8601.\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to examine or the year to examine.\n      @param [monthIndex] {number} The month index to examine.\n      @param [day] {number} The day to examine.\n      @return {number} The week of the year.\n      @throws Error if an invalid date or a different calendar used. */\n  weekOfYear: function (year, monthIndex, day) {\n    // compute Chinese new year\n    var validatedYear = this._validateYear(year, main.local.invalidyear);\n\n    var packedDate = CHINESE_NEW_YEAR[validatedYear - CHINESE_NEW_YEAR[0]];\n    var y = packedDate >> 9 & 0xFFF;\n    var m = packedDate >> 5 & 0x0F;\n    var d = packedDate & 0x1F; // find first Thrusday of the year\n\n    var firstThursday;\n    firstThursday = gregorianCalendar.newDate(y, m, d);\n    firstThursday.add(4 - (firstThursday.dayOfWeek() || 7), 'd'); // compute days from first Thursday\n\n    var offset = this.toJD(year, monthIndex, day) - firstThursday.toJD();\n    return 1 + Math.floor(offset / 7);\n  },\n\n  /** Retrieve the number of months in a year.\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to examine or the year to examine.\n      @return {number} The number of months.\n      @throws Error if an invalid year or a different calendar used. */\n  monthsInYear: function (year) {\n    return this.leapYear(year) ? 13 : 12;\n  },\n\n  /** Retrieve the number of days in a month.\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to examine or the year of the month.\n      @param [monthIndex] {number} The month index.\n      @return {number} The number of days in this month.\n      @throws Error if an invalid month/year or a different calendar used. */\n  daysInMonth: function (year, monthIndex) {\n    if (year.year) {\n      monthIndex = year.month();\n      year = year.year();\n    }\n\n    year = this._validateYear(year);\n    var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];\n    var intercalaryMonth = monthDaysTable >> 13;\n    var maxMonthIndex = intercalaryMonth ? 12 : 11;\n\n    if (monthIndex > maxMonthIndex) {\n      throw main.local.invalidMonth.replace(/\\{0\\}/, this.local.name);\n    }\n\n    var daysInMonth = monthDaysTable & 1 << 12 - monthIndex ? 30 : 29;\n    return daysInMonth;\n  },\n\n  /** Determine whether this date is a week day.\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to examine or the year to examine.\n      @param [monthIndex] {number} The month index to examine.\n      @param [day] {number} The day to examine.\n      @return {boolean} <code>true</code> if a week day, <code>false</code> if not.\n      @throws Error if an invalid date or a different calendar used. */\n  weekDay: function (year, monthIndex, day) {\n    return (this.dayOfWeek(year, monthIndex, day) || 7) < 6;\n  },\n\n  /** Retrieve the Julian date equivalent for this date,\n      i.e. days since January 1, 4713 BCE Greenwich noon.\n      @memberof ChineseCalendar\n      @param year {CDate|number} The date to convert or the year to convert.\n      @param [monthIndex] {number} The month index to convert.\n      @param [day] {number} The day to convert.\n      @return {number} The equivalent Julian date.\n      @throws Error if an invalid date or a different calendar used. */\n  toJD: function (year, monthIndex, day) {\n    var date = this._validate(year, month, day, main.local.invalidDate);\n\n    year = this._validateYear(date.year());\n    monthIndex = date.month();\n    day = date.day();\n    var isIntercalary = this.isIntercalaryMonth(year, monthIndex);\n    var month = this.toChineseMonth(year, monthIndex);\n    var solar = toSolar(year, month, day, isIntercalary);\n    return gregorianCalendar.toJD(solar.year, solar.month, solar.day);\n  },\n\n  /** Create a new date from a Julian date.\n      @memberof ChineseCalendar\n      @param jd {number} The Julian date to convert.\n      @return {CDate} The equivalent date. */\n  fromJD: function (jd) {\n    var date = gregorianCalendar.fromJD(jd);\n    var lunar = toLunar(date.year(), date.month(), date.day());\n    var monthIndex = this.toMonthIndex(lunar.year, lunar.month, lunar.isIntercalary);\n    return this.newDate(lunar.year, monthIndex, lunar.day);\n  },\n\n  /** Create a new date from a string.\n      @memberof ChineseCalendar\n      @param dateString {string} String representing a Chinese date\n      @return {CDate} The new date.\n      @throws Error if an invalid date. */\n  fromString: function (dateString) {\n    var match = dateString.match(DATE_REGEXP);\n\n    var year = this._validateYear(+match[1]);\n\n    var month = +match[2];\n    var isIntercalary = !!match[3];\n    var monthIndex = this.toMonthIndex(year, month, isIntercalary);\n    var day = +match[4];\n    return this.newDate(year, monthIndex, day);\n  },\n\n  /** Add period(s) to a date.\n      Cater for no year zero.\n      @memberof ChineseCalendar\n      @param date {CDate} The starting date.\n      @param offset {number} The number of periods to adjust by.\n      @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.\n      @return {CDate} The updated date.\n      @throws Error if a different calendar used. */\n  add: function (date, offset, period) {\n    var year = date.year();\n    var monthIndex = date.month();\n    var isIntercalary = this.isIntercalaryMonth(year, monthIndex);\n    var month = this.toChineseMonth(year, monthIndex);\n    var cdate = Object.getPrototypeOf(ChineseCalendar.prototype).add.call(this, date, offset, period);\n\n    if (period === 'y') {\n      // Resync month\n      var resultYear = cdate.year();\n      var resultMonthIndex = cdate.month(); // Using the fact the month index of an intercalary month\n      // equals its month number:\n\n      var resultCanBeIntercalaryMonth = this.isIntercalaryMonth(resultYear, month);\n      var correctedMonthIndex = isIntercalary && resultCanBeIntercalaryMonth ? this.toMonthIndex(resultYear, month, true) : this.toMonthIndex(resultYear, month, false);\n\n      if (correctedMonthIndex !== resultMonthIndex) {\n        cdate.month(correctedMonthIndex);\n      }\n    }\n\n    return cdate;\n  }\n}); // Used by ChineseCalendar.prototype.fromString\n\nvar DATE_REGEXP = /^\\s*(-?\\d\\d\\d\\d|\\d\\d)[-/](\\d?\\d)([iI]?)[-/](\\d?\\d)/m;\nvar MONTH_NUMBER_REGEXP = /^\\d?\\d[iI]?/m;\nvar MONTH_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?月/m;\nvar MONTH_SHORT_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?/m; // Chinese calendar implementation\n\nmain.calendars.chinese = ChineseCalendar; // Chinese calendar tables from year 1888 to 2111\n//\n// Source:\n// https://github.com/isee15/Lunar-Solar-Calendar-Converter.git\n// Table of intercalary months and days per month from year 1888 to 2111\n//\n// bit (12 - i):        days in the i^th month\n//                      (= 0 if i^th lunar month has 29 days)\n//                      (= 1 if i^th lunar month has 30 days)\n//                      (first month in lunar year is i = 0)\n// bits (13,14,15,16):  intercalary month\n//                      (= 0 if lunar year has no intercalary month)\n\nvar LUNAR_MONTH_DAYS = [1887, 0x1694, 0x16aa, 0x4ad5, 0xab6, 0xc4b7, 0x4ae, 0xa56, 0xb52a, 0x1d2a, 0xd54, 0x75aa, 0x156a, 0x1096d, 0x95c, 0x14ae, 0xaa4d, 0x1a4c, 0x1b2a, 0x8d55, 0xad4, 0x135a, 0x495d, 0x95c, 0xd49b, 0x149a, 0x1a4a, 0xbaa5, 0x16a8, 0x1ad4, 0x52da, 0x12b6, 0xe937, 0x92e, 0x1496, 0xb64b, 0xd4a, 0xda8, 0x95b5, 0x56c, 0x12ae, 0x492f, 0x92e, 0xcc96, 0x1a94, 0x1d4a, 0xada9, 0xb5a, 0x56c, 0x726e, 0x125c, 0xf92d, 0x192a, 0x1a94, 0xdb4a, 0x16aa, 0xad4, 0x955b, 0x4ba, 0x125a, 0x592b, 0x152a, 0xf695, 0xd94, 0x16aa, 0xaab5, 0x9b4, 0x14b6, 0x6a57, 0xa56, 0x1152a, 0x1d2a, 0xd54, 0xd5aa, 0x156a, 0x96c, 0x94ae, 0x14ae, 0xa4c, 0x7d26, 0x1b2a, 0xeb55, 0xad4, 0x12da, 0xa95d, 0x95a, 0x149a, 0x9a4d, 0x1a4a, 0x11aa5, 0x16a8, 0x16d4, 0xd2da, 0x12b6, 0x936, 0x9497, 0x1496, 0x1564b, 0xd4a, 0xda8, 0xd5b4, 0x156c, 0x12ae, 0xa92f, 0x92e, 0xc96, 0x6d4a, 0x1d4a, 0x10d65, 0xb58, 0x156c, 0xb26d, 0x125c, 0x192c, 0x9a95, 0x1a94, 0x1b4a, 0x4b55, 0xad4, 0xf55b, 0x4ba, 0x125a, 0xb92b, 0x152a, 0x1694, 0x96aa, 0x15aa, 0x12ab5, 0x974, 0x14b6, 0xca57, 0xa56, 0x1526, 0x8e95, 0xd54, 0x15aa, 0x49b5, 0x96c, 0xd4ae, 0x149c, 0x1a4c, 0xbd26, 0x1aa6, 0xb54, 0x6d6a, 0x12da, 0x1695d, 0x95a, 0x149a, 0xda4b, 0x1a4a, 0x1aa4, 0xbb54, 0x16b4, 0xada, 0x495b, 0x936, 0xf497, 0x1496, 0x154a, 0xb6a5, 0xda4, 0x15b4, 0x6ab6, 0x126e, 0x1092f, 0x92e, 0xc96, 0xcd4a, 0x1d4a, 0xd64, 0x956c, 0x155c, 0x125c, 0x792e, 0x192c, 0xfa95, 0x1a94, 0x1b4a, 0xab55, 0xad4, 0x14da, 0x8a5d, 0xa5a, 0x1152b, 0x152a, 0x1694, 0xd6aa, 0x15aa, 0xab4, 0x94ba, 0x14b6, 0xa56, 0x7527, 0xd26, 0xee53, 0xd54, 0x15aa, 0xa9b5, 0x96c, 0x14ae, 0x8a4e, 0x1a4c, 0x11d26, 0x1aa4, 0x1b54, 0xcd6a, 0xada, 0x95c, 0x949d, 0x149a, 0x1a2a, 0x5b25, 0x1aa4, 0xfb52, 0x16b4, 0xaba, 0xa95b, 0x936, 0x1496, 0x9a4b, 0x154a, 0x136a5, 0xda4, 0x15ac]; // Table of Chinese New Years from year 1888 to 2111\n// \n// bits (0 to 4):   solar day\n// bits (5 to 8):   solar month\n// bits (9 to 20):  solar year\n\nvar CHINESE_NEW_YEAR = [1887, 0xec04c, 0xec23f, 0xec435, 0xec649, 0xec83e, 0xeca51, 0xecc46, 0xece3a, 0xed04d, 0xed242, 0xed436, 0xed64a, 0xed83f, 0xeda53, 0xedc48, 0xede3d, 0xee050, 0xee244, 0xee439, 0xee64d, 0xee842, 0xeea36, 0xeec4a, 0xeee3e, 0xef052, 0xef246, 0xef43a, 0xef64e, 0xef843, 0xefa37, 0xefc4b, 0xefe41, 0xf0054, 0xf0248, 0xf043c, 0xf0650, 0xf0845, 0xf0a38, 0xf0c4d, 0xf0e42, 0xf1037, 0xf124a, 0xf143e, 0xf1651, 0xf1846, 0xf1a3a, 0xf1c4e, 0xf1e44, 0xf2038, 0xf224b, 0xf243f, 0xf2653, 0xf2848, 0xf2a3b, 0xf2c4f, 0xf2e45, 0xf3039, 0xf324d, 0xf3442, 0xf3636, 0xf384a, 0xf3a3d, 0xf3c51, 0xf3e46, 0xf403b, 0xf424e, 0xf4443, 0xf4638, 0xf484c, 0xf4a3f, 0xf4c52, 0xf4e48, 0xf503c, 0xf524f, 0xf5445, 0xf5639, 0xf584d, 0xf5a42, 0xf5c35, 0xf5e49, 0xf603e, 0xf6251, 0xf6446, 0xf663b, 0xf684f, 0xf6a43, 0xf6c37, 0xf6e4b, 0xf703f, 0xf7252, 0xf7447, 0xf763c, 0xf7850, 0xf7a45, 0xf7c39, 0xf7e4d, 0xf8042, 0xf8254, 0xf8449, 0xf863d, 0xf8851, 0xf8a46, 0xf8c3b, 0xf8e4f, 0xf9044, 0xf9237, 0xf944a, 0xf963f, 0xf9853, 0xf9a47, 0xf9c3c, 0xf9e50, 0xfa045, 0xfa238, 0xfa44c, 0xfa641, 0xfa836, 0xfaa49, 0xfac3d, 0xfae52, 0xfb047, 0xfb23a, 0xfb44e, 0xfb643, 0xfb837, 0xfba4a, 0xfbc3f, 0xfbe53, 0xfc048, 0xfc23c, 0xfc450, 0xfc645, 0xfc839, 0xfca4c, 0xfcc41, 0xfce36, 0xfd04a, 0xfd23d, 0xfd451, 0xfd646, 0xfd83a, 0xfda4d, 0xfdc43, 0xfde37, 0xfe04b, 0xfe23f, 0xfe453, 0xfe648, 0xfe83c, 0xfea4f, 0xfec44, 0xfee38, 0xff04c, 0xff241, 0xff436, 0xff64a, 0xff83e, 0xffa51, 0xffc46, 0xffe3a, 0x10004e, 0x100242, 0x100437, 0x10064b, 0x100841, 0x100a53, 0x100c48, 0x100e3c, 0x10104f, 0x101244, 0x101438, 0x10164c, 0x101842, 0x101a35, 0x101c49, 0x101e3d, 0x102051, 0x102245, 0x10243a, 0x10264e, 0x102843, 0x102a37, 0x102c4b, 0x102e3f, 0x103053, 0x103247, 0x10343b, 0x10364f, 0x103845, 0x103a38, 0x103c4c, 0x103e42, 0x104036, 0x104249, 0x10443d, 0x104651, 0x104846, 0x104a3a, 0x104c4e, 0x104e43, 0x105038, 0x10524a, 0x10543e, 0x105652, 0x105847, 0x105a3b, 0x105c4f, 0x105e45, 0x106039, 0x10624c, 0x106441, 0x106635, 0x106849, 0x106a3d, 0x106c51, 0x106e47, 0x10703c, 0x10724f, 0x107444, 0x107638, 0x10784c, 0x107a3f, 0x107c53, 0x107e48];\n\nfunction toLunar(yearOrDate, monthOrResult, day, result) {\n  var solarDate;\n  var lunarDate;\n\n  if (typeof yearOrDate === 'object') {\n    solarDate = yearOrDate;\n    lunarDate = monthOrResult || {};\n  } else {\n    var isValidYear = typeof yearOrDate === 'number' && yearOrDate >= 1888 && yearOrDate <= 2111;\n    if (!isValidYear) throw new Error(\"Solar year outside range 1888-2111\");\n    var isValidMonth = typeof monthOrResult === 'number' && monthOrResult >= 1 && monthOrResult <= 12;\n    if (!isValidMonth) throw new Error(\"Solar month outside range 1 - 12\");\n    var isValidDay = typeof day === 'number' && day >= 1 && day <= 31;\n    if (!isValidDay) throw new Error(\"Solar day outside range 1 - 31\");\n    solarDate = {\n      year: yearOrDate,\n      month: monthOrResult,\n      day: day\n    };\n    lunarDate = result || {};\n  } // Compute Chinese new year and lunar year\n\n\n  var chineseNewYearPackedDate = CHINESE_NEW_YEAR[solarDate.year - CHINESE_NEW_YEAR[0]];\n  var packedDate = solarDate.year << 9 | solarDate.month << 5 | solarDate.day;\n  lunarDate.year = packedDate >= chineseNewYearPackedDate ? solarDate.year : solarDate.year - 1;\n  chineseNewYearPackedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];\n  var y = chineseNewYearPackedDate >> 9 & 0xFFF;\n  var m = chineseNewYearPackedDate >> 5 & 0x0F;\n  var d = chineseNewYearPackedDate & 0x1F; // Compute days from new year\n\n  var daysFromNewYear;\n  var chineseNewYearJSDate = new Date(y, m - 1, d);\n  var jsDate = new Date(solarDate.year, solarDate.month - 1, solarDate.day);\n  daysFromNewYear = Math.round((jsDate - chineseNewYearJSDate) / (24 * 3600 * 1000)); // Compute lunar month and day\n\n  var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];\n  var i;\n\n  for (i = 0; i < 13; i++) {\n    var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;\n\n    if (daysFromNewYear < daysInMonth) {\n      break;\n    }\n\n    daysFromNewYear -= daysInMonth;\n  }\n\n  var intercalaryMonth = monthDaysTable >> 13;\n\n  if (!intercalaryMonth || i < intercalaryMonth) {\n    lunarDate.isIntercalary = false;\n    lunarDate.month = 1 + i;\n  } else if (i === intercalaryMonth) {\n    lunarDate.isIntercalary = true;\n    lunarDate.month = i;\n  } else {\n    lunarDate.isIntercalary = false;\n    lunarDate.month = i;\n  }\n\n  lunarDate.day = 1 + daysFromNewYear;\n  return lunarDate;\n}\n\nfunction toSolar(yearOrDate, monthOrResult, day, isIntercalaryOrResult, result) {\n  var solarDate;\n  var lunarDate;\n\n  if (typeof yearOrDate === 'object') {\n    lunarDate = yearOrDate;\n    solarDate = monthOrResult || {};\n  } else {\n    var isValidYear = typeof yearOrDate === 'number' && yearOrDate >= 1888 && yearOrDate <= 2111;\n    if (!isValidYear) throw new Error(\"Lunar year outside range 1888-2111\");\n    var isValidMonth = typeof monthOrResult === 'number' && monthOrResult >= 1 && monthOrResult <= 12;\n    if (!isValidMonth) throw new Error(\"Lunar month outside range 1 - 12\");\n    var isValidDay = typeof day === 'number' && day >= 1 && day <= 30;\n    if (!isValidDay) throw new Error(\"Lunar day outside range 1 - 30\");\n    var isIntercalary;\n\n    if (typeof isIntercalaryOrResult === 'object') {\n      isIntercalary = false;\n      solarDate = isIntercalaryOrResult;\n    } else {\n      isIntercalary = !!isIntercalaryOrResult;\n      solarDate = result || {};\n    }\n\n    lunarDate = {\n      year: yearOrDate,\n      month: monthOrResult,\n      day: day,\n      isIntercalary: isIntercalary\n    };\n  } // Compute days from new year\n\n\n  var daysFromNewYear;\n  daysFromNewYear = lunarDate.day - 1;\n  var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];\n  var intercalaryMonth = monthDaysTable >> 13;\n  var monthsFromNewYear;\n\n  if (!intercalaryMonth) {\n    monthsFromNewYear = lunarDate.month - 1;\n  } else if (lunarDate.month > intercalaryMonth) {\n    monthsFromNewYear = lunarDate.month;\n  } else if (lunarDate.isIntercalary) {\n    monthsFromNewYear = lunarDate.month;\n  } else {\n    monthsFromNewYear = lunarDate.month - 1;\n  }\n\n  for (var i = 0; i < monthsFromNewYear; i++) {\n    var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;\n    daysFromNewYear += daysInMonth;\n  } // Compute Chinese new year\n\n\n  var packedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];\n  var y = packedDate >> 9 & 0xFFF;\n  var m = packedDate >> 5 & 0x0F;\n  var d = packedDate & 0x1F; // Compute solar date\n\n  var jsDate = new Date(y, m - 1, d + daysFromNewYear);\n  solarDate.year = jsDate.getFullYear();\n  solarDate.month = 1 + jsDate.getMonth();\n  solarDate.day = jsDate.getDate();\n  return solarDate;\n}","map":null,"metadata":{},"sourceType":"script"}