{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar pieHelpers = require('../pie/helpers');\n\nexports.findEntryWithLevel = function (hierarchy, level) {\n  var out;\n\n  if (level) {\n    hierarchy.eachAfter(function (pt) {\n      if (exports.getPtId(pt) === level) {\n        return out = pt.copy();\n      }\n    });\n  }\n\n  return out || hierarchy;\n};\n\nexports.findEntryWithChild = function (hierarchy, childId) {\n  var out;\n  hierarchy.eachAfter(function (pt) {\n    var children = pt.children || [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (exports.getPtId(child) === childId) {\n        return out = pt.copy();\n      }\n    }\n  });\n  return out || hierarchy;\n};\n\nexports.isEntry = function (pt) {\n  return !pt.parent;\n};\n\nexports.isLeaf = function (pt) {\n  return !pt.children;\n};\n\nexports.getPtId = function (pt) {\n  return pt.data.data.id;\n};\n\nexports.getPtLabel = function (pt) {\n  return pt.data.data.label;\n};\n\nexports.getValue = function (d) {\n  return d.value;\n};\n\nexports.isHierarchyRoot = function (pt) {\n  return getParentId(pt) === '';\n};\n\nexports.setSliceCursor = function (sliceTop, gd, opts) {\n  var hide = opts.isTransitioning;\n\n  if (!hide) {\n    var pt = sliceTop.datum();\n    hide = opts.hideOnRoot && exports.isHierarchyRoot(pt) || opts.hideOnLeaves && exports.isLeaf(pt);\n  }\n\n  setCursor(sliceTop, hide ? null : 'pointer');\n};\n\nfunction determineOutsideTextFont(trace, pt, layoutFont) {\n  return {\n    color: exports.getOutsideTextFontKey('color', trace, pt, layoutFont),\n    family: exports.getOutsideTextFontKey('family', trace, pt, layoutFont),\n    size: exports.getOutsideTextFontKey('size', trace, pt, layoutFont)\n  };\n}\n\nfunction determineInsideTextFont(trace, pt, layoutFont, cont) {\n  var cdi = pt.data.data;\n  var ptNumber = cdi.i;\n  var customColor = Lib.castOption(trace, ptNumber, 'insidetextfont.color');\n\n  if (!customColor && trace._input.textfont) {\n    // Why not simply using trace.textfont? Because if not set, it\n    // defaults to layout.font which has a default color. But if\n    // textfont.color and insidetextfont.color don't supply a value,\n    // a contrasting color shall be used.\n    customColor = Lib.castOption(trace._input, ptNumber, 'textfont.color');\n  }\n\n  return {\n    color: customColor || Color.contrast(cdi.color),\n    family: exports.getInsideTextFontKey('family', cont || trace, pt, layoutFont),\n    size: exports.getInsideTextFontKey('size', cont || trace, pt, layoutFont)\n  };\n}\n\nexports.getInsideTextFontKey = function (keyStr, trace, pt, layoutFont) {\n  var ptNumber = pt.data.data.i;\n  return Lib.castOption(trace, ptNumber, 'insidetextfont.' + keyStr) || Lib.castOption(trace, ptNumber, 'textfont.' + keyStr) || layoutFont.size;\n};\n\nexports.getOutsideTextFontKey = function (keyStr, trace, pt, layoutFont) {\n  var ptNumber = pt.data.data.i;\n  return Lib.castOption(trace, ptNumber, 'outsidetextfont.' + keyStr) || Lib.castOption(trace, ptNumber, 'textfont.' + keyStr) || layoutFont.size;\n};\n\nexports.isOutsideText = function (trace, pt) {\n  return !trace._hasColorscale && exports.isHierarchyRoot(pt);\n};\n\nexports.determineTextFont = function (trace, pt, layoutFont, cont) {\n  return exports.isOutsideText(trace, pt) ? determineOutsideTextFont(trace, pt, layoutFont) : determineInsideTextFont(trace, pt, layoutFont, cont);\n};\n\nexports.hasTransition = function (transitionOpts) {\n  // We could optimize hasTransition per trace,\n  // as sunburst & treemap have no cross-trace logic!\n  return !!(transitionOpts && transitionOpts.duration > 0);\n};\n\nexports.getMaxDepth = function (trace) {\n  return trace.maxdepth >= 0 ? trace.maxdepth : Infinity;\n};\n\nexports.isHeader = function (pt, trace) {\n  // it is only used in treemap.\n  return !(exports.isLeaf(pt) || pt.depth === trace._maxDepth - 1);\n};\n\nfunction getParentId(pt) {\n  return pt.data.data.pid;\n}\n\nexports.getParent = function (hierarchy, pt) {\n  return exports.findEntryWithLevel(hierarchy, getParentId(pt));\n};\n\nexports.listPath = function (d, keyStr) {\n  var parent = d.parent;\n  if (!parent) return [];\n  var list = keyStr ? [parent.data[keyStr]] : [parent];\n  return exports.listPath(parent, keyStr).concat(list);\n};\n\nexports.getPath = function (d) {\n  return exports.listPath(d, 'label').join('/') + '/';\n};\n\nexports.formatValue = pieHelpers.formatPieValue; // TODO: should combine the two in a separate PR - Also please note Lib.formatPercent should support separators.\n\nexports.formatPercent = function (v, separators) {\n  var tx = Lib.formatPercent(v, 0); // use funnel(area) version\n\n  if (tx === '0%') tx = pieHelpers.formatPiePercent(v, separators); // use pie version\n\n  return tx;\n};","map":null,"metadata":{},"sourceType":"script"}