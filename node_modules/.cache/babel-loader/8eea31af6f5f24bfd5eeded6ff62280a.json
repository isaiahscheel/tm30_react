{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar glslify = require('glslify');\n\nvar vertexShaderSource = glslify('./shaders/vertex.glsl');\nvar fragmentShaderSource = glslify('./shaders/fragment.glsl');\n\nvar maxDim = require('./constants').maxDimensionCount;\n\nvar Lib = require('../../lib'); // don't change; otherwise near/far plane lines are lost\n\n\nvar depthLimitEpsilon = 1e-6; // precision of multiselect is the full range divided into this many parts\n\nvar maskHeight = 2048;\nvar dummyPixel = new Uint8Array(4);\nvar dataPixel = new Uint8Array(4);\nvar paletteTextureConfig = {\n  shape: [256, 1],\n  format: 'rgba',\n  type: 'uint8',\n  mag: 'nearest',\n  min: 'nearest'\n};\n\nfunction ensureDraw(regl) {\n  regl.read({\n    x: 0,\n    y: 0,\n    width: 1,\n    height: 1,\n    data: dummyPixel\n  });\n}\n\nfunction clear(regl, x, y, width, height) {\n  var gl = regl._gl;\n  gl.enable(gl.SCISSOR_TEST);\n  gl.scissor(x, y, width, height);\n  regl.clear({\n    color: [0, 0, 0, 0],\n    depth: 1\n  }); // clearing is done in scissored panel only\n}\n\nfunction renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {\n  var rafKey = item.key;\n\n  function render(blockNumber) {\n    var count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);\n\n    if (blockNumber === 0) {\n      // stop drawing possibly stale glyphs before clearing\n      window.cancelAnimationFrame(renderState.currentRafs[rafKey]);\n      delete renderState.currentRafs[rafKey];\n      clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);\n    }\n\n    if (renderState.clearOnly) {\n      return;\n    }\n\n    item.count = 2 * count;\n    item.offset = 2 * blockNumber * blockLineCount;\n    glAes(item);\n\n    if (blockNumber * blockLineCount + count < sampleCount) {\n      renderState.currentRafs[rafKey] = window.requestAnimationFrame(function () {\n        render(blockNumber + 1);\n      });\n    }\n\n    renderState.drawCompleted = false;\n  }\n\n  if (!renderState.drawCompleted) {\n    ensureDraw(regl);\n    renderState.drawCompleted = true;\n  } // start with rendering item 0; recursion handles the rest\n\n\n  render(0);\n}\n\nfunction adjustDepth(d) {\n  // WebGL matrix operations use floats with limited precision, potentially causing a number near a border of [0, 1]\n  // to end up slightly outside the border. With an epsilon, we reduce the chance that a line gets clipped by the\n  // near or the far plane.\n  return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));\n}\n\nfunction palette(unitToColor, opacity) {\n  var result = new Array(256);\n\n  for (var i = 0; i < 256; i++) {\n    result[i] = unitToColor(i / 255).concat(opacity);\n  }\n\n  return result;\n} // Maps the sample index [0...sampleCount - 1] to a range of [0, 1] as the shader expects colors in the [0, 1] range.\n// but first it shifts the sample index by 0, 8 or 16 bits depending on rgbIndex [0..2]\n// with the end result that each line will be of a unique color, making it possible for the pick handler\n// to uniquely identify which line is hovered over (bijective mapping).\n// The inverse, i.e. readPixel is invoked from 'parcoords.js'\n\n\nfunction calcPickColor(i, rgbIndex) {\n  return (i >>> 8 * rgbIndex) % 256 / 255;\n}\n\nfunction makePoints(sampleCount, dims, color) {\n  var points = new Array(sampleCount * (maxDim + 4));\n  var n = 0;\n\n  for (var i = 0; i < sampleCount; i++) {\n    for (var k = 0; k < maxDim; k++) {\n      points[n++] = k < dims.length ? dims[k].paddedUnitValues[i] : 0.5;\n    }\n\n    points[n++] = calcPickColor(i, 2);\n    points[n++] = calcPickColor(i, 1);\n    points[n++] = calcPickColor(i, 0);\n    points[n++] = adjustDepth(color[i]);\n  }\n\n  return points;\n}\n\nfunction makeVecAttr(vecIndex, sampleCount, points) {\n  var pointPairs = new Array(sampleCount * 8);\n  var n = 0;\n\n  for (var i = 0; i < sampleCount; i++) {\n    for (var j = 0; j < 2; j++) {\n      for (var k = 0; k < 4; k++) {\n        var q = vecIndex * 4 + k;\n        var v = points[i * 64 + q];\n\n        if (q === 63 && j === 0) {\n          v *= -1;\n        }\n\n        pointPairs[n++] = v;\n      }\n    }\n  }\n\n  return pointPairs;\n}\n\nfunction pad2(num) {\n  var s = '0' + num;\n  return s.substr(s.length - 2);\n}\n\nfunction getAttrName(i) {\n  return i < maxDim ? 'p' + pad2(i + 1) + '_' + pad2(i + 4) : 'colors';\n}\n\nfunction setAttributes(attributes, sampleCount, points) {\n  for (var i = 0; i <= maxDim; i += 4) {\n    attributes[getAttrName(i)](makeVecAttr(i / 4, sampleCount, points));\n  }\n}\n\nfunction emptyAttributes(regl) {\n  var attributes = {};\n\n  for (var i = 0; i <= maxDim; i += 4) {\n    attributes[getAttrName(i)] = regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array(0)\n    });\n  }\n\n  return attributes;\n}\n\nfunction makeItem(model, leftmost, rightmost, itemNumber, i0, i1, x, y, panelSizeX, panelSizeY, crossfilterDimensionIndex, drwLayer, constraints) {\n  var dims = [[], []];\n\n  for (var k = 0; k < 64; k++) {\n    dims[0][k] = k === i0 ? 1 : 0;\n    dims[1][k] = k === i1 ? 1 : 0;\n  }\n\n  var overdrag = model.lines.canvasOverdrag;\n  var domain = model.domain;\n  var canvasWidth = model.canvasWidth;\n  var canvasHeight = model.canvasHeight;\n  var deselectedLinesColor = model.deselectedLines.color;\n  var itemModel = Lib.extendFlat({\n    key: crossfilterDimensionIndex,\n    resolution: [canvasWidth, canvasHeight],\n    viewBoxPos: [x + overdrag, y],\n    viewBoxSize: [panelSizeX, panelSizeY],\n    i0: i0,\n    i1: i1,\n    dim0A: dims[0].slice(0, 16),\n    dim0B: dims[0].slice(16, 32),\n    dim0C: dims[0].slice(32, 48),\n    dim0D: dims[0].slice(48, 64),\n    dim1A: dims[1].slice(0, 16),\n    dim1B: dims[1].slice(16, 32),\n    dim1C: dims[1].slice(32, 48),\n    dim1D: dims[1].slice(48, 64),\n    drwLayer: drwLayer,\n    contextColor: [deselectedLinesColor[0] / 255, deselectedLinesColor[1] / 255, deselectedLinesColor[2] / 255, deselectedLinesColor[3] < 1 ? deselectedLinesColor[3] : Math.max(1 / 255, Math.pow(1 / model.lines.color.length, 1 / 3))],\n    scissorX: (itemNumber === leftmost ? 0 : x + overdrag) + (model.pad.l - overdrag) + model.layoutWidth * domain.x[0],\n    scissorWidth: (itemNumber === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (itemNumber === leftmost ? x + overdrag : 0),\n    scissorY: y + model.pad.b + model.layoutHeight * domain.y[0],\n    scissorHeight: panelSizeY,\n    viewportX: model.pad.l - overdrag + model.layoutWidth * domain.x[0],\n    viewportY: model.pad.b + model.layoutHeight * domain.y[0],\n    viewportWidth: canvasWidth,\n    viewportHeight: canvasHeight\n  }, constraints);\n  return itemModel;\n}\n\nfunction expandedPixelRange(bounds) {\n  var dh = maskHeight - 1;\n  var a = Math.max(0, Math.floor(bounds[0] * dh), 0);\n  var b = Math.min(dh, Math.ceil(bounds[1] * dh), dh);\n  return [Math.min(a, b), Math.max(a, b)];\n}\n\nmodule.exports = function (canvasGL, d) {\n  // context & pick describe which canvas we're talking about - won't change with new data\n  var isContext = d.context;\n  var isPick = d.pick;\n  var regl = d.regl;\n  var renderState = {\n    currentRafs: {},\n    drawCompleted: true,\n    clearOnly: false\n  }; // state to be set by update and used later\n\n  var model;\n  var vm;\n  var initialDims;\n  var sampleCount;\n  var attributes = emptyAttributes(regl);\n  var maskTexture;\n  var paletteTexture = regl.texture(paletteTextureConfig);\n  var prevAxisOrder = [];\n  update(d);\n  var glAes = regl({\n    profile: false,\n    blend: {\n      enable: isContext,\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 1,\n        dstAlpha: 1 // 'one minus src alpha'\n\n      },\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      color: [0, 0, 0, 0]\n    },\n    depth: {\n      enable: !isContext,\n      mask: true,\n      func: 'less',\n      range: [0, 1]\n    },\n    // for polygons\n    cull: {\n      enable: true,\n      face: 'back'\n    },\n    scissor: {\n      enable: true,\n      box: {\n        x: regl.prop('scissorX'),\n        y: regl.prop('scissorY'),\n        width: regl.prop('scissorWidth'),\n        height: regl.prop('scissorHeight')\n      }\n    },\n    viewport: {\n      x: regl.prop('viewportX'),\n      y: regl.prop('viewportY'),\n      width: regl.prop('viewportWidth'),\n      height: regl.prop('viewportHeight')\n    },\n    dither: false,\n    vert: vertexShaderSource,\n    frag: fragmentShaderSource,\n    primitive: 'lines',\n    lineWidth: 1,\n    attributes: attributes,\n    uniforms: {\n      resolution: regl.prop('resolution'),\n      viewBoxPos: regl.prop('viewBoxPos'),\n      viewBoxSize: regl.prop('viewBoxSize'),\n      dim0A: regl.prop('dim0A'),\n      dim1A: regl.prop('dim1A'),\n      dim0B: regl.prop('dim0B'),\n      dim1B: regl.prop('dim1B'),\n      dim0C: regl.prop('dim0C'),\n      dim1C: regl.prop('dim1C'),\n      dim0D: regl.prop('dim0D'),\n      dim1D: regl.prop('dim1D'),\n      loA: regl.prop('loA'),\n      hiA: regl.prop('hiA'),\n      loB: regl.prop('loB'),\n      hiB: regl.prop('hiB'),\n      loC: regl.prop('loC'),\n      hiC: regl.prop('hiC'),\n      loD: regl.prop('loD'),\n      hiD: regl.prop('hiD'),\n      palette: paletteTexture,\n      contextColor: regl.prop('contextColor'),\n      mask: regl.prop('maskTexture'),\n      drwLayer: regl.prop('drwLayer'),\n      maskHeight: regl.prop('maskHeight')\n    },\n    offset: regl.prop('offset'),\n    count: regl.prop('count')\n  });\n\n  function update(dNew) {\n    model = dNew.model;\n    vm = dNew.viewModel;\n    initialDims = vm.dimensions.slice();\n    sampleCount = initialDims[0] ? initialDims[0].values.length : 0;\n    var lines = model.lines;\n    var color = isPick ? lines.color.map(function (_, i) {\n      return i / lines.color.length;\n    }) : lines.color;\n    var points = makePoints(sampleCount, initialDims, color);\n    setAttributes(attributes, sampleCount, points);\n\n    if (!isContext && !isPick) {\n      paletteTexture = regl.texture(Lib.extendFlat({\n        data: palette(model.unitToColor, 255)\n      }, paletteTextureConfig));\n    }\n  }\n\n  function makeConstraints(isContext) {\n    var i, j, k;\n    var limits = [[], []];\n\n    for (k = 0; k < 64; k++) {\n      var p = !isContext && k < initialDims.length ? initialDims[k].brush.filter.getBounds() : [-Infinity, Infinity];\n      limits[0][k] = p[0];\n      limits[1][k] = p[1];\n    }\n\n    var len = maskHeight * 8;\n    var mask = new Array(len);\n\n    for (i = 0; i < len; i++) {\n      mask[i] = 255;\n    }\n\n    if (!isContext) {\n      for (i = 0; i < initialDims.length; i++) {\n        var u = i % 8;\n        var v = (i - u) / 8;\n        var bitMask = Math.pow(2, u);\n        var dim = initialDims[i];\n        var ranges = dim.brush.filter.get();\n        if (ranges.length < 2) continue; // bail if the bounding box based filter is sufficient\n\n        var prevEnd = expandedPixelRange(ranges[0])[1];\n\n        for (j = 1; j < ranges.length; j++) {\n          var nextRange = expandedPixelRange(ranges[j]);\n\n          for (k = prevEnd + 1; k < nextRange[0]; k++) {\n            mask[k * 8 + v] &= ~bitMask;\n          }\n\n          prevEnd = Math.max(prevEnd, nextRange[1]);\n        }\n      }\n    }\n\n    var textureData = {\n      // 8 units x 8 bits = 64 bits, just sufficient for the almost 64 dimensions we support\n      shape: [8, maskHeight],\n      format: 'alpha',\n      type: 'uint8',\n      mag: 'nearest',\n      min: 'nearest',\n      data: mask\n    };\n    if (maskTexture) maskTexture(textureData);else maskTexture = regl.texture(textureData);\n    return {\n      maskTexture: maskTexture,\n      maskHeight: maskHeight,\n      loA: limits[0].slice(0, 16),\n      loB: limits[0].slice(16, 32),\n      loC: limits[0].slice(32, 48),\n      loD: limits[0].slice(48, 64),\n      hiA: limits[1].slice(0, 16),\n      hiB: limits[1].slice(16, 32),\n      hiC: limits[1].slice(32, 48),\n      hiD: limits[1].slice(48, 64)\n    };\n  }\n\n  function renderGLParcoords(panels, setChanged, clearOnly) {\n    var panelCount = panels.length;\n    var i;\n    var leftmost;\n    var rightmost;\n    var lowestX = Infinity;\n    var highestX = -Infinity;\n\n    for (i = 0; i < panelCount; i++) {\n      if (panels[i].dim0.canvasX < lowestX) {\n        lowestX = panels[i].dim0.canvasX;\n        leftmost = i;\n      }\n\n      if (panels[i].dim1.canvasX > highestX) {\n        highestX = panels[i].dim1.canvasX;\n        rightmost = i;\n      }\n    }\n\n    if (panelCount === 0) {\n      // clear canvas here, as the panel iteration below will not enter the loop body\n      clear(regl, 0, 0, model.canvasWidth, model.canvasHeight);\n    }\n\n    var constraints = makeConstraints(isContext);\n\n    for (i = 0; i < panelCount; i++) {\n      var p = panels[i];\n      var i0 = p.dim0.crossfilterDimensionIndex;\n      var i1 = p.dim1.crossfilterDimensionIndex;\n      var x = p.canvasX;\n      var y = p.canvasY;\n      var nextX = x + p.panelSizeX;\n\n      if (setChanged || !prevAxisOrder[i0] || prevAxisOrder[i0][0] !== x || prevAxisOrder[i0][1] !== nextX) {\n        prevAxisOrder[i0] = [x, nextX];\n        var item = makeItem(model, leftmost, rightmost, i, i0, i1, x, y, p.panelSizeX, p.panelSizeY, p.dim0.crossfilterDimensionIndex, isContext ? 0 : isPick ? 2 : 1, constraints);\n        renderState.clearOnly = clearOnly;\n        var blockLineCount = setChanged ? model.lines.blockLineCount : sampleCount;\n        renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item);\n      }\n    }\n  }\n\n  function readPixel(canvasX, canvasY) {\n    regl.read({\n      x: canvasX,\n      y: canvasY,\n      width: 1,\n      height: 1,\n      data: dataPixel\n    });\n    return dataPixel;\n  }\n\n  function readPixels(canvasX, canvasY, width, height) {\n    var pixelArray = new Uint8Array(4 * width * height);\n    regl.read({\n      x: canvasX,\n      y: canvasY,\n      width: width,\n      height: height,\n      data: pixelArray\n    });\n    return pixelArray;\n  }\n\n  function destroy() {\n    canvasGL.style['pointer-events'] = 'none';\n    paletteTexture.destroy();\n    if (maskTexture) maskTexture.destroy();\n\n    for (var k in attributes) attributes[k].destroy();\n  }\n\n  return {\n    render: renderGLParcoords,\n    readPixel: readPixel,\n    readPixels: readPixels,\n    destroy: destroy,\n    update: update\n  };\n};","map":null,"metadata":{},"sourceType":"script"}