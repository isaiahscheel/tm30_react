{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar makeBlank = require('../../lib/geojson_utils').makeBlank;\n\nmodule.exports = function convert(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var isVisible = trace.visible === true && trace._length !== 0;\n  var heatmap = {\n    layout: {\n      visibility: 'none'\n    },\n    paint: {}\n  };\n  var opts = trace._opts = {\n    heatmap: heatmap,\n    geojson: makeBlank()\n  }; // early return if not visible or placeholder\n\n  if (!isVisible) return opts;\n  var features = [];\n  var i;\n  var z = trace.z;\n  var radius = trace.radius;\n  var hasZ = Lib.isArrayOrTypedArray(z) && z.length;\n  var hasArrayRadius = Lib.isArrayOrTypedArray(radius);\n\n  for (i = 0; i < calcTrace.length; i++) {\n    var cdi = calcTrace[i];\n    var lonlat = cdi.lonlat;\n\n    if (lonlat[0] !== BADNUM) {\n      var props = {};\n\n      if (hasZ) {\n        var zi = cdi.z;\n        props.z = zi !== BADNUM ? zi : 0;\n      }\n\n      if (hasArrayRadius) {\n        props.r = isNumeric(radius[i]) && radius[i] > 0 ? +radius[i] : 0;\n      }\n\n      features.push({\n        type: 'Feature',\n        geometry: {\n          type: 'Point',\n          coordinates: lonlat\n        },\n        properties: props\n      });\n    }\n  }\n\n  var cOpts = Colorscale.extractOpts(trace);\n  var scl = cOpts.reversescale ? Colorscale.flipScale(cOpts.colorscale) : cOpts.colorscale; // Add alpha channel to first colorscale step.\n  // If not, we would essentially color the entire map.\n  // See https://docs.mapbox.com/mapbox-gl-js/example/heatmap-layer/\n\n  var scl01 = scl[0][1];\n  var color0 = Color.opacity(scl01) < 1 ? scl01 : Color.addOpacity(scl01, 0);\n  var heatmapColor = ['interpolate', ['linear'], ['heatmap-density'], 0, color0];\n\n  for (i = 1; i < scl.length; i++) {\n    heatmapColor.push(scl[i][0], scl[i][1]);\n  } // Those \"weights\" have to be in [0, 1], we can do this either:\n  // - as here using a mapbox-gl expression\n  // - or, scale the 'z' property in the feature loop\n\n\n  var zExp = ['interpolate', ['linear'], ['get', 'z'], cOpts.min, 0, cOpts.max, 1];\n  Lib.extendFlat(opts.heatmap.paint, {\n    'heatmap-weight': hasZ ? zExp : 1 / (cOpts.max - cOpts.min),\n    'heatmap-color': heatmapColor,\n    'heatmap-radius': hasArrayRadius ? {\n      type: 'identity',\n      property: 'r'\n    } : trace.radius,\n    'heatmap-opacity': trace.opacity\n  });\n  opts.geojson = {\n    type: 'FeatureCollection',\n    features: features\n  };\n  opts.heatmap.layout.visibility = 'visible';\n  return opts;\n};","map":null,"metadata":{},"sourceType":"script"}