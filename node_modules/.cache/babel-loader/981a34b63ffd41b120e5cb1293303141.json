{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nmodule.exports = function (pathinfo, contours) {\n  var pi0 = pathinfo[0];\n  var z = pi0.z;\n  var i;\n\n  switch (contours.type) {\n    case 'levels':\n      // Why (just) use z[0][0] and z[0][1]?\n      //\n      // N.B. using boundaryMin instead of edgeVal2 here makes the\n      //      `contour_scatter` mock fail\n      var edgeVal2 = Math.min(z[0][0], z[0][1]);\n\n      for (i = 0; i < pathinfo.length; i++) {\n        var pi = pathinfo[i];\n        pi.prefixBoundary = !pi.edgepaths.length && (edgeVal2 > pi.level || pi.starts.length && edgeVal2 === pi.level);\n      }\n\n      break;\n\n    case 'constraint':\n      // after convertToConstraints, pathinfo has length=0\n      pi0.prefixBoundary = false; // joinAllPaths does enough already when edgepaths are present\n\n      if (pi0.edgepaths.length) return;\n      var na = pi0.x.length;\n      var nb = pi0.y.length;\n      var boundaryMax = -Infinity;\n      var boundaryMin = Infinity;\n\n      for (i = 0; i < nb; i++) {\n        boundaryMin = Math.min(boundaryMin, z[i][0]);\n        boundaryMin = Math.min(boundaryMin, z[i][na - 1]);\n        boundaryMax = Math.max(boundaryMax, z[i][0]);\n        boundaryMax = Math.max(boundaryMax, z[i][na - 1]);\n      }\n\n      for (i = 1; i < na - 1; i++) {\n        boundaryMin = Math.min(boundaryMin, z[0][i]);\n        boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);\n        boundaryMax = Math.max(boundaryMax, z[0][i]);\n        boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);\n      }\n\n      var contoursValue = contours.value;\n      var v1, v2;\n\n      switch (contours._operation) {\n        case '>':\n          if (contoursValue > boundaryMax) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n\n        case '<':\n          if (contoursValue < boundaryMin || pi0.starts.length && contoursValue === boundaryMin) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n\n        case '[]':\n          v1 = Math.min(contoursValue[0], contoursValue[1]);\n          v2 = Math.max(contoursValue[0], contoursValue[1]);\n\n          if (v2 < boundaryMin || v1 > boundaryMax || pi0.starts.length && v2 === boundaryMin) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n\n        case '][':\n          v1 = Math.min(contoursValue[0], contoursValue[1]);\n          v2 = Math.max(contoursValue[0], contoursValue[1]);\n\n          if (v1 < boundaryMin && v2 > boundaryMax) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n      }\n\n      break;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}