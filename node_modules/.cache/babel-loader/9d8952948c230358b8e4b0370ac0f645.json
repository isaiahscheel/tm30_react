{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n/*\n * Return a function that evaluates a set of linear or bicubic control points.\n * This will get evaluated a lot, so we'll at least do a bit of extra work to\n * flatten some of the choices. In particular, we'll unroll the linear/bicubic\n * combinations and we'll allow computing results in parallel to cut down\n * on repeated arithmetic.\n *\n * Take note that we don't search for the correct range in this function. The\n * reason is for consistency due to the corrresponding derivative function. In\n * particular, the derivatives aren't continuous across cells, so it's important\n * to be able control whether the derivative at a cell boundary is approached\n * from one side or the other.\n */\n\nmodule.exports = function (arrays, na, nb, asmoothing, bsmoothing) {\n  var imax = na - 2;\n  var jmax = nb - 2;\n\n  if (asmoothing && bsmoothing) {\n    return function (out, i, j) {\n      if (!out) out = [];\n      var f0, f1, f2, f3, ak, k;\n      var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n      var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n      var u = Math.max(0, Math.min(1, i - i0));\n      var v = Math.max(0, Math.min(1, j - j0)); // Since it's a grid of control points, the actual indices are * 3:\n\n      i0 *= 3;\n      j0 *= 3; // Precompute some numbers:\n\n      var u2 = u * u;\n      var u3 = u2 * u;\n      var ou = 1 - u;\n      var ou2 = ou * ou;\n      var ou3 = ou2 * ou;\n      var v2 = v * v;\n      var v3 = v2 * v;\n      var ov = 1 - v;\n      var ov2 = ov * ov;\n      var ov3 = ov2 * ov;\n\n      for (k = 0; k < arrays.length; k++) {\n        ak = arrays[k];\n        f0 = ou3 * ak[j0][i0] + 3 * (ou2 * u * ak[j0][i0 + 1] + ou * u2 * ak[j0][i0 + 2]) + u3 * ak[j0][i0 + 3];\n        f1 = ou3 * ak[j0 + 1][i0] + 3 * (ou2 * u * ak[j0 + 1][i0 + 1] + ou * u2 * ak[j0 + 1][i0 + 2]) + u3 * ak[j0 + 1][i0 + 3];\n        f2 = ou3 * ak[j0 + 2][i0] + 3 * (ou2 * u * ak[j0 + 2][i0 + 1] + ou * u2 * ak[j0 + 2][i0 + 2]) + u3 * ak[j0 + 2][i0 + 3];\n        f3 = ou3 * ak[j0 + 3][i0] + 3 * (ou2 * u * ak[j0 + 3][i0 + 1] + ou * u2 * ak[j0 + 3][i0 + 2]) + u3 * ak[j0 + 3][i0 + 3];\n        out[k] = ov3 * f0 + 3 * (ov2 * v * f1 + ov * v2 * f2) + v3 * f3;\n      }\n\n      return out;\n    };\n  } else if (asmoothing) {\n    // Handle smooth in the a-direction but linear in the b-direction by performing four\n    // linear interpolations followed by one cubic interpolation of the result\n    return function (out, i, j) {\n      if (!out) out = [];\n      var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n      var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n      var u = Math.max(0, Math.min(1, i - i0));\n      var v = Math.max(0, Math.min(1, j - j0));\n      var f0, f1, f2, f3, k, ak;\n      i0 *= 3;\n      var u2 = u * u;\n      var u3 = u2 * u;\n      var ou = 1 - u;\n      var ou2 = ou * ou;\n      var ou3 = ou2 * ou;\n      var ov = 1 - v;\n\n      for (k = 0; k < arrays.length; k++) {\n        ak = arrays[k];\n        f0 = ov * ak[j0][i0] + v * ak[j0 + 1][i0];\n        f1 = ov * ak[j0][i0 + 1] + v * ak[j0 + 1][i0 + 1];\n        f2 = ov * ak[j0][i0 + 2] + v * ak[j0 + 1][i0 + 1];\n        f3 = ov * ak[j0][i0 + 3] + v * ak[j0 + 1][i0 + 1];\n        out[k] = ou3 * f0 + 3 * (ou2 * u * f1 + ou * u2 * f2) + u3 * f3;\n      }\n\n      return out;\n    };\n  } else if (bsmoothing) {\n    // Same as the above case, except reversed:\n    return function (out, i, j) {\n      if (!out) out = [];\n      var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n      var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n      var u = Math.max(0, Math.min(1, i - i0));\n      var v = Math.max(0, Math.min(1, j - j0));\n      var f0, f1, f2, f3, k, ak;\n      j0 *= 3;\n      var v2 = v * v;\n      var v3 = v2 * v;\n      var ov = 1 - v;\n      var ov2 = ov * ov;\n      var ov3 = ov2 * ov;\n      var ou = 1 - u;\n\n      for (k = 0; k < arrays.length; k++) {\n        ak = arrays[k];\n        f0 = ou * ak[j0][i0] + u * ak[j0][i0 + 1];\n        f1 = ou * ak[j0 + 1][i0] + u * ak[j0 + 1][i0 + 1];\n        f2 = ou * ak[j0 + 2][i0] + u * ak[j0 + 2][i0 + 1];\n        f3 = ou * ak[j0 + 3][i0] + u * ak[j0 + 3][i0 + 1];\n        out[k] = ov3 * f0 + 3 * (ov2 * v * f1 + ov * v2 * f2) + v3 * f3;\n      }\n\n      return out;\n    };\n  } else {\n    // Finally, both directions are linear:\n    return function (out, i, j) {\n      if (!out) out = [];\n      var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n      var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n      var u = Math.max(0, Math.min(1, i - i0));\n      var v = Math.max(0, Math.min(1, j - j0));\n      var f0, f1, k, ak;\n      var ov = 1 - v;\n      var ou = 1 - u;\n\n      for (k = 0; k < arrays.length; k++) {\n        ak = arrays[k];\n        f0 = ou * ak[j0][i0] + u * ak[j0][i0 + 1];\n        f1 = ou * ak[j0 + 1][i0] + u * ak[j0 + 1][i0 + 1];\n        out[k] = ov * f0 + v * f1;\n      }\n\n      return out;\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script"}