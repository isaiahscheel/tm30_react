{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib'); // special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V2.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\n\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\n\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\n\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\n\nexports.extractPathCoords = function (path, paramsToUse) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n  });\n  return extractedCoordinates;\n};\n\nexports.getDataToPixel = function (gd, axis, isVertical) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n\n  if (axis) {\n    var d2r = exports.shapePositionToRange(axis);\n\n    dataToPixel = function (v) {\n      return axis._offset + axis.r2p(d2r(v, true));\n    };\n\n    if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n  } else if (isVertical) {\n    dataToPixel = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  return dataToPixel;\n};\n\nexports.getPixelToData = function (gd, axis, isVertical) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n\n  if (axis) {\n    var r2d = exports.rangeToShapePosition(axis);\n\n    pixelToData = function (p) {\n      return r2d(axis.p2r(p - axis._offset));\n    };\n  } else if (isVertical) {\n    pixelToData = function (p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function (p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n\n  return pixelToData;\n};\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\n\n\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};","map":null,"metadata":{},"sourceType":"script"}