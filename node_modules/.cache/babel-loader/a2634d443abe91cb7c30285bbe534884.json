{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../registry');\n\nvar Lib = require('../lib');\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\n\n\nexports.manageCommandObserver = function (gd, container, commandList, onchange) {\n  var ret = {};\n  var enabled = true;\n\n  if (container && container._commandObserver) {\n    ret = container._commandObserver;\n  }\n\n  if (!ret.cache) {\n    ret.cache = {};\n  } // Either create or just recompute this:\n\n\n  ret.lookupTable = {};\n  var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n  if (container && container._commandObserver) {\n    if (!binding) {\n      // If container exists and there are no longer any bindings,\n      // remove existing:\n      if (container._commandObserver.remove) {\n        container._commandObserver.remove();\n\n        container._commandObserver = null;\n        return ret;\n      }\n    } else {\n      // If container exists and there *are* bindings, then the lookup\n      // table should have been updated and check is already attached,\n      // so there's nothing to be done:\n      return ret;\n    }\n  } // Determine whether there's anything to do for this binding:\n\n\n  if (binding) {\n    // Build the cache:\n    bindingValueHasChanged(gd, binding, ret.cache);\n\n    ret.check = function check() {\n      if (!enabled) return;\n      var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n      if (update.changed && onchange) {\n        // Disable checks for the duration of this command in order to avoid\n        // infinite loops:\n        if (ret.lookupTable[update.value] !== undefined) {\n          ret.disable();\n          Promise.resolve(onchange({\n            value: update.value,\n            type: binding.type,\n            prop: binding.prop,\n            traces: binding.traces,\n            index: ret.lookupTable[update.value]\n          })).then(ret.enable, ret.enable);\n        }\n      }\n\n      return update.changed;\n    };\n\n    var checkEvents = ['plotly_relayout', 'plotly_redraw', 'plotly_restyle', 'plotly_update', 'plotly_animatingframe', 'plotly_afterplot'];\n\n    for (var i = 0; i < checkEvents.length; i++) {\n      gd._internalOn(checkEvents[i], ret.check);\n    }\n\n    ret.remove = function () {\n      for (var i = 0; i < checkEvents.length; i++) {\n        gd._removeInternalListener(checkEvents[i], ret.check);\n      }\n    };\n  } else {\n    // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n    // is a start\n    Lib.log('Unable to automatically bind plot updates to API command');\n    ret.lookupTable = {};\n\n    ret.remove = function () {};\n  }\n\n  ret.disable = function disable() {\n    enabled = false;\n  };\n\n  ret.enable = function enable() {\n    enabled = true;\n  };\n\n  if (container) {\n    container._commandObserver = ret;\n  }\n\n  return ret;\n};\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\n\n\nexports.hasSimpleAPICommandBindings = function (gd, commandList, bindingsByValue) {\n  var i;\n  var n = commandList.length;\n  var refBinding;\n\n  for (i = 0; i < n; i++) {\n    var binding;\n    var command = commandList[i];\n    var method = command.method;\n    var args = command.args;\n    if (!Array.isArray(args)) args = []; // If any command has no method, refuse to bind:\n\n    if (!method) {\n      return false;\n    }\n\n    var bindings = exports.computeAPICommandBindings(gd, method, args); // Right now, handle one and *only* one property being set:\n\n    if (bindings.length !== 1) {\n      return false;\n    }\n\n    if (!refBinding) {\n      refBinding = bindings[0];\n\n      if (Array.isArray(refBinding.traces)) {\n        refBinding.traces.sort();\n      }\n    } else {\n      binding = bindings[0];\n\n      if (binding.type !== refBinding.type) {\n        return false;\n      }\n\n      if (binding.prop !== refBinding.prop) {\n        return false;\n      }\n\n      if (Array.isArray(refBinding.traces)) {\n        if (Array.isArray(binding.traces)) {\n          binding.traces.sort();\n\n          for (var j = 0; j < refBinding.traces.length; j++) {\n            if (refBinding.traces[j] !== binding.traces[j]) {\n              return false;\n            }\n          }\n        } else {\n          return false;\n        }\n      } else {\n        if (binding.prop !== refBinding.prop) {\n          return false;\n        }\n      }\n    }\n\n    binding = bindings[0];\n    var value = binding.value;\n\n    if (Array.isArray(value)) {\n      if (value.length === 1) {\n        value = value[0];\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingsByValue) {\n      bindingsByValue[value] = i;\n    }\n  }\n\n  return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n  var container, value, obj;\n  var changed = false;\n\n  if (binding.type === 'data') {\n    // If it's data, we need to get a trace. Based on the limited scope\n    // of what we cover, we can just take the first trace from the list,\n    // or otherwise just the first trace:\n    container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n  } else if (binding.type === 'layout') {\n    container = gd._fullLayout;\n  } else {\n    return false;\n  }\n\n  value = Lib.nestedProperty(container, binding.prop).get();\n  obj = cache[binding.type] = cache[binding.type] || {};\n\n  if (obj.hasOwnProperty(binding.prop)) {\n    if (obj[binding.prop] !== value) {\n      changed = true;\n    }\n  }\n\n  obj[binding.prop] = value;\n  return {\n    changed: changed,\n    value: value\n  };\n}\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\n\n\nexports.executeAPICommand = function (gd, method, args) {\n  if (method === 'skip') return Promise.resolve();\n  var _method = Registry.apiMethodRegistry[method];\n  var allArgs = [gd];\n  if (!Array.isArray(args)) args = [];\n\n  for (var i = 0; i < args.length; i++) {\n    allArgs.push(args[i]);\n  }\n\n  return _method.apply(null, allArgs).catch(function (err) {\n    Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n    return Promise.reject(err);\n  });\n};\n\nexports.computeAPICommandBindings = function (gd, method, args) {\n  var bindings;\n  if (!Array.isArray(args)) args = [];\n\n  switch (method) {\n    case 'restyle':\n      bindings = computeDataBindings(gd, args);\n      break;\n\n    case 'relayout':\n      bindings = computeLayoutBindings(gd, args);\n      break;\n\n    case 'update':\n      bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));\n      break;\n\n    case 'animate':\n      bindings = computeAnimateBindings(gd, args);\n      break;\n\n    default:\n      // This is the case where intelligent logic about what affects\n      // this command is not implemented. It causes no ill effects.\n      // For example, addFrames simply won't bind to a control component.\n      bindings = [];\n  }\n\n  return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n  // We'll assume that the only relevant modification an animation\n  // makes that's meaningfully tracked is the frame:\n  if (Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n    return [{\n      type: 'layout',\n      prop: '_currentFrame',\n      value: args[0][0].toString()\n    }];\n  } else {\n    return [];\n  }\n}\n\nfunction computeLayoutBindings(gd, args) {\n  var bindings = [];\n  var astr = args[0];\n  var aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = args[1];\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = astr;\n  } else {\n    return bindings;\n  }\n\n  crawl(aobj, function (path, attrName, attr) {\n    bindings.push({\n      type: 'layout',\n      prop: path,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n  var traces, astr, val, aobj;\n  var bindings = []; // Logic copied from Plotly.restyle:\n\n  astr = args[0];\n  val = args[1];\n  traces = args[2];\n  aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = astr;\n\n    if (traces === undefined) {\n      traces = val;\n    }\n  } else {\n    return bindings;\n  }\n\n  if (traces === undefined) {\n    // Explicitly assign this to null instead of undefined:\n    traces = null;\n  }\n\n  crawl(aobj, function (path, attrName, _attr) {\n    var thisTraces;\n    var attr;\n\n    if (Array.isArray(_attr)) {\n      attr = _attr.slice();\n      var nAttr = Math.min(attr.length, gd.data.length);\n\n      if (traces) {\n        nAttr = Math.min(nAttr, traces.length);\n      }\n\n      thisTraces = [];\n\n      for (var j = 0; j < nAttr; j++) {\n        thisTraces[j] = traces ? traces[j] : j;\n      }\n    } else {\n      attr = _attr;\n      thisTraces = traces ? traces.slice() : null;\n    } // Convert [7] to just 7 when traces is null:\n\n\n    if (thisTraces === null) {\n      if (Array.isArray(attr)) {\n        attr = attr[0];\n      }\n    } else if (Array.isArray(thisTraces)) {\n      if (!Array.isArray(attr)) {\n        var tmp = attr;\n        attr = [];\n\n        for (var i = 0; i < thisTraces.length; i++) {\n          attr[i] = tmp;\n        }\n      }\n\n      attr.length = Math.min(thisTraces.length, attr.length);\n    }\n\n    bindings.push({\n      type: 'data',\n      prop: path,\n      traces: thisTraces,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n  Object.keys(attrs).forEach(function (attrName) {\n    var attr = attrs[attrName];\n    if (attrName[0] === '_') return;\n    var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n    if (Lib.isPlainObject(attr)) {\n      crawl(attr, callback, thisPath, depth + 1);\n    } else {\n      // Only execute the callback on leaf nodes:\n      callback(thisPath, attrName, attr);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}