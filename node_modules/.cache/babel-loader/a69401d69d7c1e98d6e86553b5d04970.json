{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar numConstants = require('../../constants/numerical');\n\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\nvar LOG_CLIP_PLUS = LOG_CLIP + 0.5;\nvar LOG_CLIP_MINUS = LOG_CLIP - 0.5;\n\nvar Lib = require('../../lib');\n\nvar segmentsIntersect = Lib.segmentsIntersect;\nvar constrain = Lib.constrain;\n\nvar constants = require('./constants');\n\nmodule.exports = function linePoints(d, opts) {\n  var xa = opts.xaxis;\n  var ya = opts.yaxis;\n  var xLog = xa.type === 'log';\n  var yLog = ya.type === 'log';\n  var xLen = xa._length;\n  var yLen = ya._length;\n  var connectGaps = opts.connectGaps;\n  var baseTolerance = opts.baseTolerance;\n  var shape = opts.shape;\n  var linear = shape === 'linear';\n  var fill = opts.fill && opts.fill !== 'none';\n  var segments = [];\n  var minTolerance = constants.minTolerance;\n  var len = d.length;\n  var pts = new Array(len);\n  var pti = 0;\n  var i; // pt variables are pixel coordinates [x,y] of one point\n  // these four are the outputs of clustering on a line\n\n  var clusterStartPt, clusterEndPt, clusterHighPt, clusterLowPt; // \"this\" is the next point we're considering adding to the cluster\n\n  var thisPt; // did we encounter the high point first, then a low point, or vice versa?\n\n  var clusterHighFirst; // the first two points in the cluster determine its unit vector\n  // so the second is always in the \"High\" direction\n\n  var clusterUnitVector; // the pixel delta from clusterStartPt\n\n  var thisVector; // val variables are (signed) pixel distances along the cluster vector\n\n  var clusterRefDist, clusterHighVal, clusterLowVal, thisVal; // deviation variables are (signed) pixel distances normal to the cluster vector\n\n  var clusterMinDeviation, clusterMaxDeviation, thisDeviation; // turn one calcdata point into pixel coordinates\n\n  function getPt(index) {\n    var di = d[index];\n    if (!di) return false;\n    var x = opts.linearized ? xa.l2p(di.x) : xa.c2p(di.x);\n    var y = opts.linearized ? ya.l2p(di.y) : ya.c2p(di.y); // if non-positive log values, set them VERY far off-screen\n    // so the line looks essentially straight from the previous point.\n\n    if (x === BADNUM) {\n      if (xLog) x = xa.c2p(di.x, true);\n      if (x === BADNUM) return false; // If BOTH were bad log values, make the line follow a constant\n      // exponent rather than a constant slope\n\n      if (yLog && y === BADNUM) {\n        x *= Math.abs(xa._m * yLen * (xa._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS) / (ya._m * xLen * (ya._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS)));\n      }\n\n      x *= 1000;\n    }\n\n    if (y === BADNUM) {\n      if (yLog) y = ya.c2p(di.y, true);\n      if (y === BADNUM) return false;\n      y *= 1000;\n    }\n\n    return [x, y];\n  }\n\n  function crossesViewport(xFrac0, yFrac0, xFrac1, yFrac1) {\n    var dx = xFrac1 - xFrac0;\n    var dy = yFrac1 - yFrac0;\n    var dx0 = 0.5 - xFrac0;\n    var dy0 = 0.5 - yFrac0;\n    var norm2 = dx * dx + dy * dy;\n    var dot = dx * dx0 + dy * dy0;\n\n    if (dot > 0 && dot < norm2) {\n      var cross = dx0 * dy - dy0 * dx;\n      if (cross * cross < norm2) return true;\n    }\n  }\n\n  var latestXFrac, latestYFrac; // if we're off-screen, increase tolerance over baseTolerance\n\n  function getTolerance(pt, nextPt) {\n    var xFrac = pt[0] / xLen;\n    var yFrac = pt[1] / yLen;\n    var offScreenFraction = Math.max(0, -xFrac, xFrac - 1, -yFrac, yFrac - 1);\n\n    if (offScreenFraction && latestXFrac !== undefined && crossesViewport(xFrac, yFrac, latestXFrac, latestYFrac)) {\n      offScreenFraction = 0;\n    }\n\n    if (offScreenFraction && nextPt && crossesViewport(xFrac, yFrac, nextPt[0] / xLen, nextPt[1] / yLen)) {\n      offScreenFraction = 0;\n    }\n\n    return (1 + constants.toleranceGrowth * offScreenFraction) * baseTolerance;\n  }\n\n  function ptDist(pt1, pt2) {\n    var dx = pt1[0] - pt2[0];\n    var dy = pt1[1] - pt2[1];\n    return Math.sqrt(dx * dx + dy * dy);\n  } // last bit of filtering: clip paths that are VERY far off-screen\n  // so we don't get near the browser's hard limit (+/- 2^29 px in Chrome and FF)\n\n\n  var maxScreensAway = constants.maxScreensAway; // find the intersections between the segment from pt1 to pt2\n  // and the large rectangle maxScreensAway around the viewport\n  // if one of pt1 and pt2 is inside and the other outside, there\n  // will be only one intersection.\n  // if both are outside there will be 0 or 2 intersections\n  // (or 1 if it's right at a corner - we'll treat that like 0)\n  // returns an array of intersection pts\n\n  var xEdge0 = -xLen * maxScreensAway;\n  var xEdge1 = xLen * (1 + maxScreensAway);\n  var yEdge0 = -yLen * maxScreensAway;\n  var yEdge1 = yLen * (1 + maxScreensAway);\n  var edges = [[xEdge0, yEdge0, xEdge1, yEdge0], [xEdge1, yEdge0, xEdge1, yEdge1], [xEdge1, yEdge1, xEdge0, yEdge1], [xEdge0, yEdge1, xEdge0, yEdge0]];\n  var xEdge, yEdge, lastXEdge, lastYEdge, lastFarPt, edgePt; // for linear line shape, edge intersections should be linearly interpolated\n  // spline uses this too, which isn't precisely correct but is actually pretty\n  // good, because Catmull-Rom weights far-away points less in creating the curvature\n\n  function getLinearEdgeIntersections(pt1, pt2) {\n    var out = [];\n    var ptCount = 0;\n\n    for (var i = 0; i < 4; i++) {\n      var edge = edges[i];\n      var ptInt = segmentsIntersect(pt1[0], pt1[1], pt2[0], pt2[1], edge[0], edge[1], edge[2], edge[3]);\n\n      if (ptInt && (!ptCount || Math.abs(ptInt.x - out[0][0]) > 1 || Math.abs(ptInt.y - out[0][1]) > 1)) {\n        ptInt = [ptInt.x, ptInt.y]; // if we have 2 intersections, make sure the closest one to pt1 comes first\n\n        if (ptCount && ptDist(ptInt, pt1) < ptDist(out[0], pt1)) out.unshift(ptInt);else out.push(ptInt);\n        ptCount++;\n      }\n    }\n\n    return out;\n  }\n\n  function onlyConstrainedPoint(pt) {\n    if (pt[0] < xEdge0 || pt[0] > xEdge1 || pt[1] < yEdge0 || pt[1] > yEdge1) {\n      return [constrain(pt[0], xEdge0, xEdge1), constrain(pt[1], yEdge0, yEdge1)];\n    }\n  }\n\n  function sameEdge(pt1, pt2) {\n    if (pt1[0] === pt2[0] && (pt1[0] === xEdge0 || pt1[0] === xEdge1)) return true;\n    if (pt1[1] === pt2[1] && (pt1[1] === yEdge0 || pt1[1] === yEdge1)) return true;\n  } // for line shapes hv and vh, movement in the two dimensions is decoupled,\n  // so all we need to do is constrain each dimension independently\n\n\n  function getHVEdgeIntersections(pt1, pt2) {\n    var out = [];\n    var ptInt1 = onlyConstrainedPoint(pt1);\n    var ptInt2 = onlyConstrainedPoint(pt2);\n    if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;\n    if (ptInt1) out.push(ptInt1);\n    if (ptInt2) out.push(ptInt2);\n    return out;\n  } // hvh and vhv we sometimes have to move one of the intersection points\n  // out BEYOND the clipping rect, by a maximum of a factor of 2, so that\n  // the midpoint line is drawn in the right place\n\n\n  function getABAEdgeIntersections(dim, limit0, limit1) {\n    return function (pt1, pt2) {\n      var ptInt1 = onlyConstrainedPoint(pt1);\n      var ptInt2 = onlyConstrainedPoint(pt2);\n      var out = [];\n      if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;\n      if (ptInt1) out.push(ptInt1);\n      if (ptInt2) out.push(ptInt2);\n      var midShift = 2 * Lib.constrain((pt1[dim] + pt2[dim]) / 2, limit0, limit1) - ((ptInt1 || pt1)[dim] + (ptInt2 || pt2)[dim]);\n\n      if (midShift) {\n        var ptToAlter;\n\n        if (ptInt1 && ptInt2) {\n          ptToAlter = midShift > 0 === ptInt1[dim] > ptInt2[dim] ? ptInt1 : ptInt2;\n        } else ptToAlter = ptInt1 || ptInt2;\n\n        ptToAlter[dim] += midShift;\n      }\n\n      return out;\n    };\n  }\n\n  var getEdgeIntersections;\n\n  if (shape === 'linear' || shape === 'spline') {\n    getEdgeIntersections = getLinearEdgeIntersections;\n  } else if (shape === 'hv' || shape === 'vh') {\n    getEdgeIntersections = getHVEdgeIntersections;\n  } else if (shape === 'hvh') getEdgeIntersections = getABAEdgeIntersections(0, xEdge0, xEdge1);else if (shape === 'vhv') getEdgeIntersections = getABAEdgeIntersections(1, yEdge0, yEdge1); // a segment pt1->pt2 entirely outside the nearby region:\n  // find the corner it gets closest to touching\n\n\n  function getClosestCorner(pt1, pt2) {\n    var dx = pt2[0] - pt1[0];\n    var m = (pt2[1] - pt1[1]) / dx;\n    var b = (pt1[1] * pt2[0] - pt2[1] * pt1[0]) / dx;\n    if (b > 0) return [m > 0 ? xEdge0 : xEdge1, yEdge1];else return [m > 0 ? xEdge1 : xEdge0, yEdge0];\n  }\n\n  function updateEdge(pt) {\n    var x = pt[0];\n    var y = pt[1];\n    var xSame = x === pts[pti - 1][0];\n    var ySame = y === pts[pti - 1][1]; // duplicate point?\n\n    if (xSame && ySame) return;\n\n    if (pti > 1) {\n      // backtracking along an edge?\n      var xSame2 = x === pts[pti - 2][0];\n      var ySame2 = y === pts[pti - 2][1];\n\n      if (xSame && (x === xEdge0 || x === xEdge1) && xSame2) {\n        if (ySame2) pti--; // backtracking exactly - drop prev pt and don't add\n        else pts[pti - 1] = pt; // not exact: replace the prev pt\n      } else if (ySame && (y === yEdge0 || y === yEdge1) && ySame2) {\n        if (xSame2) pti--;else pts[pti - 1] = pt;\n      } else pts[pti++] = pt;\n    } else pts[pti++] = pt;\n  }\n\n  function updateEdgesForReentry(pt) {\n    // if we're outside the nearby region and going back in,\n    // we may need to loop around a corner point\n    if (pts[pti - 1][0] !== pt[0] && pts[pti - 1][1] !== pt[1]) {\n      updateEdge([lastXEdge, lastYEdge]);\n    }\n\n    updateEdge(pt);\n    lastFarPt = null;\n    lastXEdge = lastYEdge = 0;\n  }\n\n  function addPt(pt) {\n    latestXFrac = pt[0] / xLen;\n    latestYFrac = pt[1] / yLen; // Are we more than maxScreensAway off-screen any direction?\n    // if so, clip to this box, but in such a way that on-screen\n    // drawing is unchanged\n\n    xEdge = pt[0] < xEdge0 ? xEdge0 : pt[0] > xEdge1 ? xEdge1 : 0;\n    yEdge = pt[1] < yEdge0 ? yEdge0 : pt[1] > yEdge1 ? yEdge1 : 0;\n\n    if (xEdge || yEdge) {\n      if (!pti) {\n        // to get fills right - if first point is far, push it toward the\n        // screen in whichever direction(s) are far\n        pts[pti++] = [xEdge || pt[0], yEdge || pt[1]];\n      } else if (lastFarPt) {\n        // both this point and the last are outside the nearby region\n        // check if we're crossing the nearby region\n        var intersections = getEdgeIntersections(lastFarPt, pt);\n\n        if (intersections.length > 1) {\n          updateEdgesForReentry(intersections[0]);\n          pts[pti++] = intersections[1];\n        }\n      } else {\n        // we're leaving the nearby region - add the point where we left it\n        edgePt = getEdgeIntersections(pts[pti - 1], pt)[0];\n        pts[pti++] = edgePt;\n      }\n\n      var lastPt = pts[pti - 1];\n\n      if (xEdge && yEdge && (lastPt[0] !== xEdge || lastPt[1] !== yEdge)) {\n        // we've gone out beyond a new corner: add the corner too\n        // so that the next point will take the right winding\n        if (lastFarPt) {\n          if (lastXEdge !== xEdge && lastYEdge !== yEdge) {\n            if (lastXEdge && lastYEdge) {\n              // we've gone around to an opposite corner - we\n              // need to add the correct extra corner\n              // in order to get the right winding\n              updateEdge(getClosestCorner(lastFarPt, pt));\n            } else {\n              // we're coming from a far edge - the extra corner\n              // we need is determined uniquely by the sectors\n              updateEdge([lastXEdge || xEdge, lastYEdge || yEdge]);\n            }\n          } else if (lastXEdge && lastYEdge) {\n            updateEdge([lastXEdge, lastYEdge]);\n          }\n        }\n\n        updateEdge([xEdge, yEdge]);\n      } else if (lastXEdge - xEdge && lastYEdge - yEdge) {\n        // we're coming from an edge or far corner to an edge - again the\n        // extra corner we need is uniquely determined by the sectors\n        updateEdge([xEdge || lastXEdge, yEdge || lastYEdge]);\n      }\n\n      lastFarPt = pt;\n      lastXEdge = xEdge;\n      lastYEdge = yEdge;\n    } else {\n      if (lastFarPt) {\n        // this point is in range but the previous wasn't: add its entry pt first\n        updateEdgesForReentry(getEdgeIntersections(lastFarPt, pt)[0]);\n      }\n\n      pts[pti++] = pt;\n    }\n  } // loop over ALL points in this trace\n\n\n  for (i = 0; i < len; i++) {\n    clusterStartPt = getPt(i);\n    if (!clusterStartPt) continue;\n    pti = 0;\n    lastFarPt = null;\n    addPt(clusterStartPt); // loop over one segment of the trace\n\n    for (i++; i < len; i++) {\n      clusterHighPt = getPt(i);\n\n      if (!clusterHighPt) {\n        if (connectGaps) continue;else break;\n      } // can't decimate if nonlinear line shape\n      // TODO: we *could* decimate [hv]{2,3} shapes if we restricted clusters to horz or vert again\n      // but spline would be verrry awkward to decimate\n\n\n      if (!linear || !opts.simplify) {\n        addPt(clusterHighPt);\n        continue;\n      }\n\n      var nextPt = getPt(i + 1);\n      clusterRefDist = ptDist(clusterHighPt, clusterStartPt); // #3147 - always include the very first and last points for fills\n\n      if (!(fill && (pti === 0 || pti === len - 1)) && clusterRefDist < getTolerance(clusterHighPt, nextPt) * minTolerance) continue;\n      clusterUnitVector = [(clusterHighPt[0] - clusterStartPt[0]) / clusterRefDist, (clusterHighPt[1] - clusterStartPt[1]) / clusterRefDist];\n      clusterLowPt = clusterStartPt;\n      clusterHighVal = clusterRefDist;\n      clusterLowVal = clusterMinDeviation = clusterMaxDeviation = 0;\n      clusterHighFirst = false;\n      clusterEndPt = clusterHighPt; // loop over one cluster of points that collapse onto one line\n\n      for (i++; i < d.length; i++) {\n        thisPt = nextPt;\n        nextPt = getPt(i + 1);\n\n        if (!thisPt) {\n          if (connectGaps) continue;else break;\n        }\n\n        thisVector = [thisPt[0] - clusterStartPt[0], thisPt[1] - clusterStartPt[1]]; // cross product (or dot with normal to the cluster vector)\n\n        thisDeviation = thisVector[0] * clusterUnitVector[1] - thisVector[1] * clusterUnitVector[0];\n        clusterMinDeviation = Math.min(clusterMinDeviation, thisDeviation);\n        clusterMaxDeviation = Math.max(clusterMaxDeviation, thisDeviation);\n        if (clusterMaxDeviation - clusterMinDeviation > getTolerance(thisPt, nextPt)) break;\n        clusterEndPt = thisPt;\n        thisVal = thisVector[0] * clusterUnitVector[0] + thisVector[1] * clusterUnitVector[1];\n\n        if (thisVal > clusterHighVal) {\n          clusterHighVal = thisVal;\n          clusterHighPt = thisPt;\n          clusterHighFirst = false;\n        } else if (thisVal < clusterLowVal) {\n          clusterLowVal = thisVal;\n          clusterLowPt = thisPt;\n          clusterHighFirst = true;\n        }\n      } // insert this cluster into pts\n      // we've already inserted the start pt, now check if we have high and low pts\n\n\n      if (clusterHighFirst) {\n        addPt(clusterHighPt);\n        if (clusterEndPt !== clusterLowPt) addPt(clusterLowPt);\n      } else {\n        if (clusterLowPt !== clusterStartPt) addPt(clusterLowPt);\n        if (clusterEndPt !== clusterHighPt) addPt(clusterHighPt);\n      } // and finally insert the end pt\n\n\n      addPt(clusterEndPt); // have we reached the end of this segment?\n\n      if (i >= d.length || !thisPt) break; // otherwise we have an out-of-cluster point to insert as next clusterStartPt\n\n      addPt(thisPt);\n      clusterStartPt = thisPt;\n    } // to get fills right - repeat what we did at the start\n\n\n    if (lastFarPt) updateEdge([lastXEdge || lastFarPt[0], lastYEdge || lastFarPt[1]]);\n    segments.push(pts.slice(0, pti));\n  }\n\n  return segments;\n};","map":null,"metadata":{},"sourceType":"script"}