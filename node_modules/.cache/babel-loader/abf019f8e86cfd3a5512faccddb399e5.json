{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar render = require('./render');\n\nvar Fx = require('../../components/fx');\n\nvar Color = require('../../components/color');\n\nvar Lib = require('../../lib');\n\nvar cn = require('./constants').cn;\n\nvar _ = Lib._;\n\nfunction renderableValuePresent(d) {\n  return d !== '';\n}\n\nfunction ownTrace(selection, d) {\n  return selection.filter(function (s) {\n    return s.key === d.traceId;\n  });\n}\n\nfunction makeTranslucent(element, alpha) {\n  d3.select(element).select('path').style('fill-opacity', alpha);\n  d3.select(element).select('rect').style('fill-opacity', alpha);\n}\n\nfunction makeTextContrasty(element) {\n  d3.select(element).select('text.name').style('fill', 'black');\n}\n\nfunction relatedLinks(d) {\n  return function (l) {\n    return d.node.sourceLinks.indexOf(l.link) !== -1 || d.node.targetLinks.indexOf(l.link) !== -1;\n  };\n}\n\nfunction relatedNodes(l) {\n  return function (d) {\n    return d.node.sourceLinks.indexOf(l.link) !== -1 || d.node.targetLinks.indexOf(l.link) !== -1;\n  };\n}\n\nfunction nodeHoveredStyle(sankeyNode, d, sankey) {\n  if (d && sankey) {\n    ownTrace(sankey, d).selectAll('.' + cn.sankeyLink).filter(relatedLinks(d)).call(linkHoveredStyle.bind(0, d, sankey, false));\n  }\n}\n\nfunction nodeNonHoveredStyle(sankeyNode, d, sankey) {\n  if (d && sankey) {\n    ownTrace(sankey, d).selectAll('.' + cn.sankeyLink).filter(relatedLinks(d)).call(linkNonHoveredStyle.bind(0, d, sankey, false));\n  }\n}\n\nfunction linkHoveredStyle(d, sankey, visitNodes, sankeyLink) {\n  var label = sankeyLink.datum().link.label;\n  sankeyLink.style('fill-opacity', function (l) {\n    if (!l.link.concentrationscale) {\n      return 0.4;\n    }\n  });\n\n  if (label) {\n    ownTrace(sankey, d).selectAll('.' + cn.sankeyLink).filter(function (l) {\n      return l.link.label === label;\n    }).style('fill-opacity', function (l) {\n      if (!l.link.concentrationscale) {\n        return 0.4;\n      }\n    });\n  }\n\n  if (visitNodes) {\n    ownTrace(sankey, d).selectAll('.' + cn.sankeyNode).filter(relatedNodes(d)).call(nodeHoveredStyle);\n  }\n}\n\nfunction linkNonHoveredStyle(d, sankey, visitNodes, sankeyLink) {\n  var label = sankeyLink.datum().link.label;\n  sankeyLink.style('fill-opacity', function (d) {\n    return d.tinyColorAlpha;\n  });\n\n  if (label) {\n    ownTrace(sankey, d).selectAll('.' + cn.sankeyLink).filter(function (l) {\n      return l.link.label === label;\n    }).style('fill-opacity', function (d) {\n      return d.tinyColorAlpha;\n    });\n  }\n\n  if (visitNodes) {\n    ownTrace(sankey, d).selectAll(cn.sankeyNode).filter(relatedNodes(d)).call(nodeNonHoveredStyle);\n  }\n} // does not support array values for now\n\n\nfunction castHoverOption(trace, attr) {\n  var labelOpts = trace.hoverlabel || {};\n  var val = Lib.nestedProperty(labelOpts, attr).get();\n  return Array.isArray(val) ? false : val;\n}\n\nmodule.exports = function plot(gd, calcData) {\n  var fullLayout = gd._fullLayout;\n  var svg = fullLayout._paper;\n  var size = fullLayout._size; // stash initial view\n\n  for (var i = 0; i < gd._fullData.length; i++) {\n    if (!gd._fullData[i].visible) continue;\n    if (gd._fullData[i].type !== cn.sankey) continue;\n\n    if (!gd._fullData[i]._viewInitial) {\n      var node = gd._fullData[i].node;\n      gd._fullData[i]._viewInitial = {\n        node: {\n          groups: node.groups.slice(),\n          x: node.x.slice(),\n          y: node.y.slice()\n        }\n      };\n    }\n  }\n\n  var linkSelect = function (element, d) {\n    var evt = d.link;\n    evt.originalEvent = d3.event;\n    gd._hoverdata = [evt];\n    Fx.click(gd, {\n      target: true\n    });\n  };\n\n  var linkHover = function (element, d, sankey) {\n    if (gd._fullLayout.hovermode === false) return;\n    d3.select(element).call(linkHoveredStyle.bind(0, d, sankey, true));\n\n    if (d.link.trace.link.hoverinfo !== 'skip') {\n      d.link.fullData = d.link.trace;\n      gd.emit('plotly_hover', {\n        event: d3.event,\n        points: [d.link]\n      });\n    }\n  };\n\n  var sourceLabel = _(gd, 'source:') + ' ';\n  var targetLabel = _(gd, 'target:') + ' ';\n  var concentrationLabel = _(gd, 'concentration:') + ' ';\n  var incomingLabel = _(gd, 'incoming flow count:') + ' ';\n  var outgoingLabel = _(gd, 'outgoing flow count:') + ' ';\n\n  var linkHoverFollow = function (element, d) {\n    if (gd._fullLayout.hovermode === false) return;\n    var obj = d.link.trace.link;\n    if (obj.hoverinfo === 'none' || obj.hoverinfo === 'skip') return;\n    var hoverItems = [];\n\n    function hoverCenterPosition(link) {\n      var hoverCenterX, hoverCenterY;\n\n      if (link.circular) {\n        hoverCenterX = (link.circularPathData.leftInnerExtent + link.circularPathData.rightInnerExtent) / 2 + d.parent.translateX;\n        hoverCenterY = link.circularPathData.verticalFullExtent + d.parent.translateY;\n      } else {\n        hoverCenterX = (link.source.x1 + link.target.x0) / 2 + d.parent.translateX;\n        hoverCenterY = (link.y0 + link.y1) / 2 + d.parent.translateY;\n      }\n\n      return [hoverCenterX, hoverCenterY];\n    } // For each related links, create a hoverItem\n\n\n    var anchorIndex = 0;\n\n    for (var i = 0; i < d.flow.links.length; i++) {\n      var link = d.flow.links[i];\n      if (gd._fullLayout.hovermode === 'closest' && d.link.pointNumber !== link.pointNumber) continue;\n      if (d.link.pointNumber === link.pointNumber) anchorIndex = i;\n      link.fullData = link.trace;\n      obj = d.link.trace.link;\n      var hoverCenter = hoverCenterPosition(link);\n      var hovertemplateLabels = {\n        valueLabel: d3.format(d.valueFormat)(link.value) + d.valueSuffix\n      };\n      hoverItems.push({\n        x: hoverCenter[0],\n        y: hoverCenter[1],\n        name: hovertemplateLabels.valueLabel,\n        text: [link.label || '', sourceLabel + link.source.label, targetLabel + link.target.label, link.concentrationscale ? concentrationLabel + d3.format('%0.2f')(link.flow.labelConcentration) : ''].filter(renderableValuePresent).join('<br>'),\n        color: castHoverOption(obj, 'bgcolor') || Color.addOpacity(link.color, 1),\n        borderColor: castHoverOption(obj, 'bordercolor'),\n        fontFamily: castHoverOption(obj, 'font.family'),\n        fontSize: castHoverOption(obj, 'font.size'),\n        fontColor: castHoverOption(obj, 'font.color'),\n        nameLength: castHoverOption(obj, 'namelength'),\n        textAlign: castHoverOption(obj, 'align'),\n        idealAlign: d3.event.x < hoverCenter[0] ? 'right' : 'left',\n        hovertemplate: obj.hovertemplate,\n        hovertemplateLabels: hovertemplateLabels,\n        eventData: [link]\n      });\n    }\n\n    var tooltips = Fx.loneHover(hoverItems, {\n      container: fullLayout._hoverlayer.node(),\n      outerContainer: fullLayout._paper.node(),\n      gd: gd,\n      anchorIndex: anchorIndex\n    });\n    tooltips.each(function () {\n      var tooltip = this;\n\n      if (!d.link.concentrationscale) {\n        makeTranslucent(tooltip, 0.65);\n      }\n\n      makeTextContrasty(tooltip);\n    });\n  };\n\n  var linkUnhover = function (element, d, sankey) {\n    if (gd._fullLayout.hovermode === false) return;\n    d3.select(element).call(linkNonHoveredStyle.bind(0, d, sankey, true));\n\n    if (d.link.trace.link.hoverinfo !== 'skip') {\n      d.link.fullData = d.link.trace;\n      gd.emit('plotly_unhover', {\n        event: d3.event,\n        points: [d.link]\n      });\n    }\n\n    Fx.loneUnhover(fullLayout._hoverlayer.node());\n  };\n\n  var nodeSelect = function (element, d, sankey) {\n    var evt = d.node;\n    evt.originalEvent = d3.event;\n    gd._hoverdata = [evt];\n    d3.select(element).call(nodeNonHoveredStyle, d, sankey);\n    Fx.click(gd, {\n      target: true\n    });\n  };\n\n  var nodeHover = function (element, d, sankey) {\n    if (gd._fullLayout.hovermode === false) return;\n    d3.select(element).call(nodeHoveredStyle, d, sankey);\n\n    if (d.node.trace.node.hoverinfo !== 'skip') {\n      d.node.fullData = d.node.trace;\n      gd.emit('plotly_hover', {\n        event: d3.event,\n        points: [d.node]\n      });\n    }\n  };\n\n  var nodeHoverFollow = function (element, d) {\n    if (gd._fullLayout.hovermode === false) return;\n    var obj = d.node.trace.node;\n    if (obj.hoverinfo === 'none' || obj.hoverinfo === 'skip') return;\n    var nodeRect = d3.select(element).select('.' + cn.nodeRect);\n\n    var rootBBox = gd._fullLayout._paperdiv.node().getBoundingClientRect();\n\n    var boundingBox = nodeRect.node().getBoundingClientRect();\n    var hoverCenterX0 = boundingBox.left - 2 - rootBBox.left;\n    var hoverCenterX1 = boundingBox.right + 2 - rootBBox.left;\n    var hoverCenterY = boundingBox.top + boundingBox.height / 4 - rootBBox.top;\n    var hovertemplateLabels = {\n      valueLabel: d3.format(d.valueFormat)(d.node.value) + d.valueSuffix\n    };\n    d.node.fullData = d.node.trace;\n    var tooltip = Fx.loneHover({\n      x0: hoverCenterX0,\n      x1: hoverCenterX1,\n      y: hoverCenterY,\n      name: d3.format(d.valueFormat)(d.node.value) + d.valueSuffix,\n      text: [d.node.label, incomingLabel + d.node.targetLinks.length, outgoingLabel + d.node.sourceLinks.length].filter(renderableValuePresent).join('<br>'),\n      color: castHoverOption(obj, 'bgcolor') || d.tinyColorHue,\n      borderColor: castHoverOption(obj, 'bordercolor'),\n      fontFamily: castHoverOption(obj, 'font.family'),\n      fontSize: castHoverOption(obj, 'font.size'),\n      fontColor: castHoverOption(obj, 'font.color'),\n      nameLength: castHoverOption(obj, 'namelength'),\n      textAlign: castHoverOption(obj, 'align'),\n      idealAlign: 'left',\n      hovertemplate: obj.hovertemplate,\n      hovertemplateLabels: hovertemplateLabels,\n      eventData: [d.node]\n    }, {\n      container: fullLayout._hoverlayer.node(),\n      outerContainer: fullLayout._paper.node(),\n      gd: gd\n    });\n    makeTranslucent(tooltip, 0.85);\n    makeTextContrasty(tooltip);\n  };\n\n  var nodeUnhover = function (element, d, sankey) {\n    if (gd._fullLayout.hovermode === false) return;\n    d3.select(element).call(nodeNonHoveredStyle, d, sankey);\n\n    if (d.node.trace.node.hoverinfo !== 'skip') {\n      d.node.fullData = d.node.trace;\n      gd.emit('plotly_unhover', {\n        event: d3.event,\n        points: [d.node]\n      });\n    }\n\n    Fx.loneUnhover(fullLayout._hoverlayer.node());\n  };\n\n  render(gd, svg, calcData, {\n    width: size.w,\n    height: size.h,\n    margin: {\n      t: size.t,\n      r: size.r,\n      b: size.b,\n      l: size.l\n    }\n  }, {\n    linkEvents: {\n      hover: linkHover,\n      follow: linkHoverFollow,\n      unhover: linkUnhover,\n      select: linkSelect\n    },\n    nodeEvents: {\n      hover: nodeHover,\n      follow: nodeHoverFollow,\n      unhover: nodeUnhover,\n      select: nodeSelect\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}