{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar createMesh = require('gl-mesh3d');\n\nvar triangulate = require('delaunay-triangulate');\n\nvar alphaShape = require('alpha-shape');\n\nvar convexHull = require('convex-hull');\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nvar zip3 = require('../../plots/gl3d/zip3');\n\nfunction Mesh3DTrace(scene, mesh, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = mesh;\n  this.name = '';\n  this.color = '#fff';\n  this.data = null;\n  this.showContour = false;\n}\n\nvar proto = Mesh3DTrace.prototype;\n\nproto.handlePick = function (selection) {\n  if (selection.object === this.mesh) {\n    var selectIndex = selection.index = selection.data.index;\n    selection.traceCoordinate = [this.data.x[selectIndex], this.data.y[selectIndex], this.data.z[selectIndex]];\n    var text = this.data.hovertext || this.data.text;\n\n    if (Array.isArray(text) && text[selectIndex] !== undefined) {\n      selection.textLabel = text[selectIndex];\n    } else if (text) {\n      selection.textLabel = text;\n    }\n\n    return true;\n  }\n};\n\nfunction parseColorArray(colors) {\n  var b = [];\n  var len = colors.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = str2RgbaArray(colors[i]);\n  }\n\n  return b;\n} // Unpack position data\n\n\nfunction toDataCoords(axis, coord, scale, calendar) {\n  var b = [];\n  var len = coord.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = axis.d2l(coord[i], 0, calendar) * scale;\n  }\n\n  return b;\n} // Round indices if passed as floats\n\n\nfunction toRoundIndex(a) {\n  var b = [];\n  var len = a.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = Math.round(a[i]);\n  }\n\n  return b;\n}\n\nfunction delaunayCells(delaunayaxis, positions) {\n  var d = ['x', 'y', 'z'].indexOf(delaunayaxis);\n  var b = [];\n  var len = positions.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = [positions[i][(d + 1) % 3], positions[i][(d + 2) % 3]];\n  }\n\n  return triangulate(b);\n} // Validate indices\n\n\nfunction hasValidIndices(list, numVertices) {\n  var len = list.length;\n\n  for (var i = 0; i < len; i++) {\n    if (list[i] <= -0.5 || list[i] >= numVertices - 0.5) {\n      // Note: the indices would be rounded -0.49 is valid.\n      return false;\n    }\n  }\n\n  return true;\n}\n\nproto.update = function (data) {\n  var scene = this.scene;\n  var layout = scene.fullSceneLayout;\n  this.data = data;\n  var numVertices = data.x.length;\n  var positions = zip3(toDataCoords(layout.xaxis, data.x, scene.dataScale[0], data.xcalendar), toDataCoords(layout.yaxis, data.y, scene.dataScale[1], data.ycalendar), toDataCoords(layout.zaxis, data.z, scene.dataScale[2], data.zcalendar));\n  var cells;\n\n  if (data.i && data.j && data.k) {\n    if (data.i.length !== data.j.length || data.j.length !== data.k.length || !hasValidIndices(data.i, numVertices) || !hasValidIndices(data.j, numVertices) || !hasValidIndices(data.k, numVertices)) {\n      return;\n    }\n\n    cells = zip3(toRoundIndex(data.i), toRoundIndex(data.j), toRoundIndex(data.k));\n  } else if (data.alphahull === 0) {\n    cells = convexHull(positions);\n  } else if (data.alphahull > 0) {\n    cells = alphaShape(data.alphahull, positions);\n  } else {\n    cells = delaunayCells(data.delaunayaxis, positions);\n  }\n\n  var config = {\n    positions: positions,\n    cells: cells,\n    lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],\n    ambient: data.lighting.ambient,\n    diffuse: data.lighting.diffuse,\n    specular: data.lighting.specular,\n    roughness: data.lighting.roughness,\n    fresnel: data.lighting.fresnel,\n    vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,\n    faceNormalsEpsilon: data.lighting.facenormalsepsilon,\n    opacity: data.opacity,\n    contourEnable: data.contour.show,\n    contourColor: str2RgbaArray(data.contour.color).slice(0, 3),\n    contourWidth: data.contour.width,\n    useFacetNormals: data.flatshading\n  };\n\n  if (data.intensity) {\n    var cOpts = extractOpts(data);\n    this.color = '#fff';\n    config.vertexIntensity = data.intensity;\n    config.vertexIntensityBounds = [cOpts.min, cOpts.max];\n    config.colormap = parseColorScale(data);\n  } else if (data.vertexcolor) {\n    this.color = data.vertexcolor[0];\n    config.vertexColors = parseColorArray(data.vertexcolor);\n  } else if (data.facecolor) {\n    this.color = data.facecolor[0];\n    config.cellColors = parseColorArray(data.facecolor);\n  } else {\n    this.color = data.color;\n    config.meshColor = str2RgbaArray(data.color);\n  } // Update mesh\n\n\n  this.mesh.update(config);\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\n\nfunction createMesh3DTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var mesh = createMesh({\n    gl: gl\n  });\n  var result = new Mesh3DTrace(scene, mesh, data.uid);\n  mesh._trace = result;\n  result.update(data);\n  scene.glplot.add(mesh);\n  return result;\n}\n\nmodule.exports = createMesh3DTrace;","map":null,"metadata":{},"sourceType":"script"}