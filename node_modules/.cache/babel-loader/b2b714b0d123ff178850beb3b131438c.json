{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar c = require('./constants');\n\nvar d3 = require('d3');\n\nvar gup = require('../../lib/gup');\n\nvar Drawing = require('../../components/drawing');\n\nvar svgUtil = require('../../lib/svg_text_utils');\n\nvar raiseToTop = require('../../lib').raiseToTop;\n\nvar cancelEeaseColumn = require('../../lib').cancelTransition;\n\nvar prepareData = require('./data_preparation_helper');\n\nvar splitData = require('./data_split_helpers');\n\nvar Color = require('../../components/color');\n\nmodule.exports = function plot(gd, wrappedTraceHolders) {\n  var dynamic = !gd._context.staticPlot;\n\n  var table = gd._fullLayout._paper.selectAll('.' + c.cn.table).data(wrappedTraceHolders.map(function (wrappedTraceHolder) {\n    var traceHolder = gup.unwrap(wrappedTraceHolder);\n    var trace = traceHolder.trace;\n    return prepareData(gd, trace);\n  }), gup.keyFun);\n\n  table.exit().remove();\n  table.enter().append('g').classed(c.cn.table, true).attr('overflow', 'visible').style('box-sizing', 'content-box').style('position', 'absolute').style('left', 0).style('overflow', 'visible').style('shape-rendering', 'crispEdges').style('pointer-events', 'all');\n  table.attr('width', function (d) {\n    return d.width + d.size.l + d.size.r;\n  }).attr('height', function (d) {\n    return d.height + d.size.t + d.size.b;\n  }).attr('transform', function (d) {\n    return 'translate(' + d.translateX + ',' + d.translateY + ')';\n  });\n  var tableControlView = table.selectAll('.' + c.cn.tableControlView).data(gup.repeat, gup.keyFun);\n  var cvEnter = tableControlView.enter().append('g').classed(c.cn.tableControlView, true).style('box-sizing', 'content-box');\n\n  if (dynamic) {\n    cvEnter.on('mousemove', function (d) {\n      tableControlView.filter(function (dd) {\n        return d === dd;\n      }).call(renderScrollbarKit, gd);\n    }).on('mousewheel', function (d) {\n      if (d.scrollbarState.wheeling) return;\n      d.scrollbarState.wheeling = true;\n      var newY = d.scrollY + d3.event.deltaY;\n      var noChange = makeDragRow(gd, tableControlView, null, newY)(d);\n\n      if (!noChange) {\n        d3.event.stopPropagation();\n        d3.event.preventDefault();\n      }\n\n      d.scrollbarState.wheeling = false;\n    }).call(renderScrollbarKit, gd, true);\n  }\n\n  tableControlView.attr('transform', function (d) {\n    return 'translate(' + d.size.l + ' ' + d.size.t + ')';\n  }); // scrollBackground merely ensures that mouse events are captured even on crazy fast scrollwheeling\n  // otherwise rendering glitches may occur\n\n  var scrollBackground = tableControlView.selectAll('.' + c.cn.scrollBackground).data(gup.repeat, gup.keyFun);\n  scrollBackground.enter().append('rect').classed(c.cn.scrollBackground, true).attr('fill', 'none');\n  scrollBackground.attr('width', function (d) {\n    return d.width;\n  }).attr('height', function (d) {\n    return d.height;\n  });\n  tableControlView.each(function (d) {\n    Drawing.setClipUrl(d3.select(this), scrollAreaBottomClipKey(gd, d), gd);\n  });\n  var yColumn = tableControlView.selectAll('.' + c.cn.yColumn).data(function (vm) {\n    return vm.columns;\n  }, gup.keyFun);\n  yColumn.enter().append('g').classed(c.cn.yColumn, true);\n  yColumn.exit().remove();\n  yColumn.attr('transform', function (d) {\n    return 'translate(' + d.x + ' 0)';\n  });\n\n  if (dynamic) {\n    yColumn.call(d3.behavior.drag().origin(function (d) {\n      var movedColumn = d3.select(this);\n      easeColumn(movedColumn, d, -c.uplift);\n      raiseToTop(this);\n      d.calcdata.columnDragInProgress = true;\n      renderScrollbarKit(tableControlView.filter(function (dd) {\n        return d.calcdata.key === dd.key;\n      }), gd);\n      return d;\n    }).on('drag', function (d) {\n      var movedColumn = d3.select(this);\n\n      var getter = function (dd) {\n        return (d === dd ? d3.event.x : dd.x) + dd.columnWidth / 2;\n      };\n\n      d.x = Math.max(-c.overdrag, Math.min(d.calcdata.width + c.overdrag - d.columnWidth, d3.event.x));\n      var sortableColumns = flatData(yColumn).filter(function (dd) {\n        return dd.calcdata.key === d.calcdata.key;\n      });\n      var newOrder = sortableColumns.sort(function (a, b) {\n        return getter(a) - getter(b);\n      });\n      newOrder.forEach(function (dd, i) {\n        dd.xIndex = i;\n        dd.x = d === dd ? dd.x : dd.xScale(dd);\n      });\n      yColumn.filter(function (dd) {\n        return d !== dd;\n      }).transition().ease(c.transitionEase).duration(c.transitionDuration).attr('transform', function (d) {\n        return 'translate(' + d.x + ' 0)';\n      });\n      movedColumn.call(cancelEeaseColumn).attr('transform', 'translate(' + d.x + ' -' + c.uplift + ' )');\n    }).on('dragend', function (d) {\n      var movedColumn = d3.select(this);\n      var p = d.calcdata;\n      d.x = d.xScale(d);\n      d.calcdata.columnDragInProgress = false;\n      easeColumn(movedColumn, d, 0);\n      columnMoved(gd, p, p.columns.map(function (dd) {\n        return dd.xIndex;\n      }));\n    }));\n  }\n\n  yColumn.each(function (d) {\n    Drawing.setClipUrl(d3.select(this), columnBoundaryClipKey(gd, d), gd);\n  });\n  var columnBlock = yColumn.selectAll('.' + c.cn.columnBlock).data(splitData.splitToPanels, gup.keyFun);\n  columnBlock.enter().append('g').classed(c.cn.columnBlock, true).attr('id', function (d) {\n    return d.key;\n  });\n  columnBlock.style('cursor', function (d) {\n    return d.dragHandle ? 'ew-resize' : d.calcdata.scrollbarState.barWiggleRoom ? 'ns-resize' : 'default';\n  });\n  var headerColumnBlock = columnBlock.filter(headerBlock);\n  var cellsColumnBlock = columnBlock.filter(cellsBlock);\n\n  if (dynamic) {\n    cellsColumnBlock.call(d3.behavior.drag().origin(function (d) {\n      d3.event.stopPropagation();\n      return d;\n    }).on('drag', makeDragRow(gd, tableControlView, -1)).on('dragend', function () {// fixme emit plotly notification\n    }));\n  } // initial rendering: header is rendered first, as it may may have async LaTeX (show header first)\n  // but blocks are _entered_ the way they are due to painter's algo (header on top)\n\n\n  renderColumnCellTree(gd, tableControlView, headerColumnBlock, columnBlock);\n  renderColumnCellTree(gd, tableControlView, cellsColumnBlock, columnBlock);\n  var scrollAreaClip = tableControlView.selectAll('.' + c.cn.scrollAreaClip).data(gup.repeat, gup.keyFun);\n  scrollAreaClip.enter().append('clipPath').classed(c.cn.scrollAreaClip, true).attr('id', function (d) {\n    return scrollAreaBottomClipKey(gd, d);\n  });\n  var scrollAreaClipRect = scrollAreaClip.selectAll('.' + c.cn.scrollAreaClipRect).data(gup.repeat, gup.keyFun);\n  scrollAreaClipRect.enter().append('rect').classed(c.cn.scrollAreaClipRect, true).attr('x', -c.overdrag).attr('y', -c.uplift).attr('fill', 'none');\n  scrollAreaClipRect.attr('width', function (d) {\n    return d.width + 2 * c.overdrag;\n  }).attr('height', function (d) {\n    return d.height + c.uplift;\n  });\n  var columnBoundary = yColumn.selectAll('.' + c.cn.columnBoundary).data(gup.repeat, gup.keyFun);\n  columnBoundary.enter().append('g').classed(c.cn.columnBoundary, true);\n  var columnBoundaryClippath = yColumn.selectAll('.' + c.cn.columnBoundaryClippath).data(gup.repeat, gup.keyFun); // SVG spec doesn't mandate wrapping into a <defs> and doesn't seem to cause a speed difference\n\n  columnBoundaryClippath.enter().append('clipPath').classed(c.cn.columnBoundaryClippath, true);\n  columnBoundaryClippath.attr('id', function (d) {\n    return columnBoundaryClipKey(gd, d);\n  });\n  var columnBoundaryRect = columnBoundaryClippath.selectAll('.' + c.cn.columnBoundaryRect).data(gup.repeat, gup.keyFun);\n  columnBoundaryRect.enter().append('rect').classed(c.cn.columnBoundaryRect, true).attr('fill', 'none');\n  columnBoundaryRect.attr('width', function (d) {\n    return d.columnWidth + 2 * roundHalfWidth(d);\n  }).attr('height', function (d) {\n    return d.calcdata.height + 2 * roundHalfWidth(d) + c.uplift;\n  }).attr('x', function (d) {\n    return -roundHalfWidth(d);\n  }).attr('y', function (d) {\n    return -roundHalfWidth(d);\n  });\n  updateBlockYPosition(null, cellsColumnBlock, tableControlView);\n};\n\nfunction roundHalfWidth(d) {\n  return Math.ceil(d.calcdata.maxLineWidth / 2);\n}\n\nfunction scrollAreaBottomClipKey(gd, d) {\n  return 'clip' + gd._fullLayout._uid + '_scrollAreaBottomClip_' + d.key;\n}\n\nfunction columnBoundaryClipKey(gd, d) {\n  return 'clip' + gd._fullLayout._uid + '_columnBoundaryClippath_' + d.calcdata.key + '_' + d.specIndex;\n}\n\nfunction flatData(selection) {\n  return [].concat.apply([], selection.map(function (g) {\n    return g;\n  })).map(function (g) {\n    return g.__data__;\n  });\n}\n\nfunction renderScrollbarKit(tableControlView, gd, bypassVisibleBar) {\n  function calcTotalHeight(d) {\n    var blocks = d.rowBlocks;\n    return firstRowAnchor(blocks, blocks.length - 1) + (blocks.length ? rowsHeight(blocks[blocks.length - 1], Infinity) : 1);\n  }\n\n  var scrollbarKit = tableControlView.selectAll('.' + c.cn.scrollbarKit).data(gup.repeat, gup.keyFun);\n  scrollbarKit.enter().append('g').classed(c.cn.scrollbarKit, true).style('shape-rendering', 'geometricPrecision');\n  scrollbarKit.each(function (d) {\n    var s = d.scrollbarState;\n    s.totalHeight = calcTotalHeight(d);\n    s.scrollableAreaHeight = d.groupHeight - headerHeight(d);\n    s.currentlyVisibleHeight = Math.min(s.totalHeight, s.scrollableAreaHeight);\n    s.ratio = s.currentlyVisibleHeight / s.totalHeight;\n    s.barLength = Math.max(s.ratio * s.currentlyVisibleHeight, c.goldenRatio * c.scrollbarWidth);\n    s.barWiggleRoom = s.currentlyVisibleHeight - s.barLength;\n    s.wiggleRoom = Math.max(0, s.totalHeight - s.scrollableAreaHeight);\n    s.topY = s.barWiggleRoom === 0 ? 0 : d.scrollY / s.wiggleRoom * s.barWiggleRoom;\n    s.bottomY = s.topY + s.barLength;\n    s.dragMultiplier = s.wiggleRoom / s.barWiggleRoom;\n  }).attr('transform', function (d) {\n    var xPosition = d.width + c.scrollbarWidth / 2 + c.scrollbarOffset;\n    return 'translate(' + xPosition + ' ' + headerHeight(d) + ')';\n  });\n  var scrollbar = scrollbarKit.selectAll('.' + c.cn.scrollbar).data(gup.repeat, gup.keyFun);\n  scrollbar.enter().append('g').classed(c.cn.scrollbar, true);\n  var scrollbarSlider = scrollbar.selectAll('.' + c.cn.scrollbarSlider).data(gup.repeat, gup.keyFun);\n  scrollbarSlider.enter().append('g').classed(c.cn.scrollbarSlider, true);\n  scrollbarSlider.attr('transform', function (d) {\n    return 'translate(0 ' + (d.scrollbarState.topY || 0) + ')';\n  });\n  var scrollbarGlyph = scrollbarSlider.selectAll('.' + c.cn.scrollbarGlyph).data(gup.repeat, gup.keyFun);\n  scrollbarGlyph.enter().append('line').classed(c.cn.scrollbarGlyph, true).attr('stroke', 'black').attr('stroke-width', c.scrollbarWidth).attr('stroke-linecap', 'round').attr('y1', c.scrollbarWidth / 2);\n  scrollbarGlyph.attr('y2', function (d) {\n    return d.scrollbarState.barLength - c.scrollbarWidth / 2;\n  }).attr('stroke-opacity', function (d) {\n    return d.columnDragInProgress || !d.scrollbarState.barWiggleRoom || bypassVisibleBar ? 0 : 0.4;\n  }); // cancel transition: possible pending (also, delayed) transition\n\n  scrollbarGlyph.transition().delay(0).duration(0);\n  scrollbarGlyph.transition().delay(c.scrollbarHideDelay).duration(c.scrollbarHideDuration).attr('stroke-opacity', 0);\n  var scrollbarCaptureZone = scrollbar.selectAll('.' + c.cn.scrollbarCaptureZone).data(gup.repeat, gup.keyFun);\n  scrollbarCaptureZone.enter().append('line').classed(c.cn.scrollbarCaptureZone, true).attr('stroke', 'white').attr('stroke-opacity', 0.01) // some browser might get rid of a 0 opacity element\n  .attr('stroke-width', c.scrollbarCaptureWidth).attr('stroke-linecap', 'butt').attr('y1', 0).on('mousedown', function (d) {\n    var y = d3.event.y;\n    var bbox = this.getBoundingClientRect();\n    var s = d.scrollbarState;\n    var pixelVal = y - bbox.top;\n    var inverseScale = d3.scale.linear().domain([0, s.scrollableAreaHeight]).range([0, s.totalHeight]).clamp(true);\n\n    if (!(s.topY <= pixelVal && pixelVal <= s.bottomY)) {\n      makeDragRow(gd, tableControlView, null, inverseScale(pixelVal - s.barLength / 2))(d);\n    }\n  }).call(d3.behavior.drag().origin(function (d) {\n    d3.event.stopPropagation();\n    d.scrollbarState.scrollbarScrollInProgress = true;\n    return d;\n  }).on('drag', makeDragRow(gd, tableControlView)).on('dragend', function () {// fixme emit Plotly event\n  }));\n  scrollbarCaptureZone.attr('y2', function (d) {\n    return d.scrollbarState.scrollableAreaHeight;\n  }); // Remove scroll glyph and capture zone on static plots\n  // as they don't render properly when converted to PDF\n  // in the Chrome PDF viewer\n  // https://github.com/plotly/streambed/issues/11618\n\n  if (gd._context.staticPlot) {\n    scrollbarGlyph.remove();\n    scrollbarCaptureZone.remove();\n  }\n}\n\nfunction renderColumnCellTree(gd, tableControlView, columnBlock, allColumnBlock) {\n  // fixme this perf hotspot\n  // this is performance critical code as scrolling calls it on every revolver switch\n  // it appears sufficiently fast but there are plenty of low-hanging fruits for performance optimization\n  var columnCells = renderColumnCells(columnBlock);\n  var columnCell = renderColumnCell(columnCells);\n  supplyStylingValues(columnCell);\n  var cellRect = renderCellRect(columnCell);\n  sizeAndStyleRect(cellRect);\n  var cellTextHolder = renderCellTextHolder(columnCell);\n  var cellText = renderCellText(cellTextHolder);\n  setFont(cellText);\n  populateCellText(cellText, tableControlView, allColumnBlock, gd); // doing this at the end when text, and text stlying are set\n\n  setCellHeightAndPositionY(columnCell);\n}\n\nfunction renderColumnCells(columnBlock) {\n  var columnCells = columnBlock.selectAll('.' + c.cn.columnCells).data(gup.repeat, gup.keyFun);\n  columnCells.enter().append('g').classed(c.cn.columnCells, true);\n  columnCells.exit().remove();\n  return columnCells;\n}\n\nfunction renderColumnCell(columnCells) {\n  var columnCell = columnCells.selectAll('.' + c.cn.columnCell).data(splitData.splitToCells, function (d) {\n    return d.keyWithinBlock;\n  });\n  columnCell.enter().append('g').classed(c.cn.columnCell, true);\n  columnCell.exit().remove();\n  return columnCell;\n}\n\nfunction renderCellRect(columnCell) {\n  var cellRect = columnCell.selectAll('.' + c.cn.cellRect).data(gup.repeat, function (d) {\n    return d.keyWithinBlock;\n  });\n  cellRect.enter().append('rect').classed(c.cn.cellRect, true);\n  return cellRect;\n}\n\nfunction renderCellText(cellTextHolder) {\n  var cellText = cellTextHolder.selectAll('.' + c.cn.cellText).data(gup.repeat, function (d) {\n    return d.keyWithinBlock;\n  });\n  cellText.enter().append('text').classed(c.cn.cellText, true).style('cursor', function () {\n    return 'auto';\n  }).on('mousedown', function () {\n    d3.event.stopPropagation();\n  });\n  return cellText;\n}\n\nfunction renderCellTextHolder(columnCell) {\n  var cellTextHolder = columnCell.selectAll('.' + c.cn.cellTextHolder).data(gup.repeat, function (d) {\n    return d.keyWithinBlock;\n  });\n  cellTextHolder.enter().append('g').classed(c.cn.cellTextHolder, true).style('shape-rendering', 'geometricPrecision');\n  return cellTextHolder;\n}\n\nfunction supplyStylingValues(columnCell) {\n  columnCell.each(function (d, i) {\n    var spec = d.calcdata.cells.font;\n    var col = d.column.specIndex;\n    var font = {\n      size: gridPick(spec.size, col, i),\n      color: gridPick(spec.color, col, i),\n      family: gridPick(spec.family, col, i)\n    };\n    d.rowNumber = d.key;\n    d.align = gridPick(d.calcdata.cells.align, col, i);\n    d.cellBorderWidth = gridPick(d.calcdata.cells.line.width, col, i);\n    d.font = font;\n  });\n}\n\nfunction setFont(cellText) {\n  cellText.each(function (d) {\n    Drawing.font(d3.select(this), d.font);\n  });\n}\n\nfunction sizeAndStyleRect(cellRect) {\n  cellRect.attr('width', function (d) {\n    return d.column.columnWidth;\n  }).attr('stroke-width', function (d) {\n    return d.cellBorderWidth;\n  }).each(function (d) {\n    var atomicSelection = d3.select(this);\n    Color.stroke(atomicSelection, gridPick(d.calcdata.cells.line.color, d.column.specIndex, d.rowNumber));\n    Color.fill(atomicSelection, gridPick(d.calcdata.cells.fill.color, d.column.specIndex, d.rowNumber));\n  });\n}\n\nfunction populateCellText(cellText, tableControlView, allColumnBlock, gd) {\n  cellText.text(function (d) {\n    var col = d.column.specIndex;\n    var row = d.rowNumber;\n    var userSuppliedContent = d.value;\n    var stringSupplied = typeof userSuppliedContent === 'string';\n    var hasBreaks = stringSupplied && userSuppliedContent.match(/<br>/i);\n    var userBrokenText = !stringSupplied || hasBreaks;\n    d.mayHaveMarkup = stringSupplied && userSuppliedContent.match(/[<&>]/);\n    var latex = isLatex(userSuppliedContent);\n    d.latex = latex;\n    var prefix = latex ? '' : gridPick(d.calcdata.cells.prefix, col, row) || '';\n    var suffix = latex ? '' : gridPick(d.calcdata.cells.suffix, col, row) || '';\n    var format = latex ? null : gridPick(d.calcdata.cells.format, col, row) || null;\n    var prefixSuffixedText = prefix + (format ? d3.format(format)(d.value) : d.value) + suffix;\n    var hasWrapSplitCharacter;\n    d.wrappingNeeded = !d.wrapped && !userBrokenText && !latex && (hasWrapSplitCharacter = hasWrapCharacter(prefixSuffixedText));\n    d.cellHeightMayIncrease = hasBreaks || latex || d.mayHaveMarkup || (hasWrapSplitCharacter === void 0 ? hasWrapCharacter(prefixSuffixedText) : hasWrapSplitCharacter);\n    d.needsConvertToTspans = d.mayHaveMarkup || d.wrappingNeeded || d.latex;\n    var textToRender;\n\n    if (d.wrappingNeeded) {\n      var hrefPreservedText = c.wrapSplitCharacter === ' ' ? prefixSuffixedText.replace(/<a href=/ig, '<a_href=') : prefixSuffixedText;\n      var fragments = hrefPreservedText.split(c.wrapSplitCharacter);\n      var hrefRestoredFragments = c.wrapSplitCharacter === ' ' ? fragments.map(function (frag) {\n        return frag.replace(/<a_href=/ig, '<a href=');\n      }) : fragments;\n      d.fragments = hrefRestoredFragments.map(function (f) {\n        return {\n          text: f,\n          width: null\n        };\n      });\n      d.fragments.push({\n        fragment: c.wrapSpacer,\n        width: null\n      });\n      textToRender = hrefRestoredFragments.join(c.lineBreaker) + c.lineBreaker + c.wrapSpacer;\n    } else {\n      delete d.fragments;\n      textToRender = prefixSuffixedText;\n    }\n\n    return textToRender;\n  }).attr('dy', function (d) {\n    return d.needsConvertToTspans ? 0 : '0.75em';\n  }).each(function (d) {\n    var element = this;\n    var selection = d3.select(element); // finalize what's in the DOM\n\n    var renderCallback = d.wrappingNeeded ? wrapTextMaker : updateYPositionMaker;\n\n    if (d.needsConvertToTspans) {\n      svgUtil.convertToTspans(selection, gd, renderCallback(allColumnBlock, element, tableControlView, gd, d));\n    } else {\n      d3.select(element.parentNode) // basic cell adjustment - compliance with `cellPad`\n      .attr('transform', function (d) {\n        return 'translate(' + xPosition(d) + ' ' + c.cellPad + ')';\n      }).attr('text-anchor', function (d) {\n        return {\n          left: 'start',\n          center: 'middle',\n          right: 'end'\n        }[d.align];\n      });\n    }\n  });\n}\n\nfunction isLatex(content) {\n  return typeof content === 'string' && content.match(c.latexCheck);\n}\n\nfunction hasWrapCharacter(text) {\n  return text.indexOf(c.wrapSplitCharacter) !== -1;\n}\n\nfunction columnMoved(gd, calcdata, indices) {\n  var o = calcdata.gdColumnsOriginalOrder;\n  calcdata.gdColumns.sort(function (a, b) {\n    return indices[o.indexOf(a)] - indices[o.indexOf(b)];\n  });\n  calcdata.columnorder = indices; // TODO: there's no data here, but also this reordering is not reflected\n  // in gd.data or even gd._fullData.\n  // For now I will not attempt to persist this in _preGUI\n\n  gd.emit('plotly_restyle');\n}\n\nfunction gridPick(spec, col, row) {\n  if (Array.isArray(spec)) {\n    var column = spec[Math.min(col, spec.length - 1)];\n\n    if (Array.isArray(column)) {\n      return column[Math.min(row, column.length - 1)];\n    } else {\n      return column;\n    }\n  } else {\n    return spec;\n  }\n}\n\nfunction easeColumn(selection, d, y) {\n  selection.transition().ease(c.releaseTransitionEase).duration(c.releaseTransitionDuration).attr('transform', 'translate(' + d.x + ' ' + y + ')');\n}\n\nfunction cellsBlock(d) {\n  return d.type === 'cells';\n}\n\nfunction headerBlock(d) {\n  return d.type === 'header';\n}\n/**\n * Revolver panel and cell contents layouting\n */\n\n\nfunction headerHeight(d) {\n  var headerBlocks = d.rowBlocks.length ? d.rowBlocks[0].auxiliaryBlocks : [];\n  return headerBlocks.reduce(function (p, n) {\n    return p + rowsHeight(n, Infinity);\n  }, 0);\n}\n\nfunction findPagesAndCacheHeights(blocks, scrollY, scrollHeight) {\n  var pages = [];\n  var pTop = 0;\n\n  for (var blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n    var block = blocks[blockIndex];\n    var blockRows = block.rows;\n    var rowsHeight = 0;\n\n    for (var i = 0; i < blockRows.length; i++) {\n      rowsHeight += blockRows[i].rowHeight;\n    } // caching allRowsHeight on the block - it's safe as this function is always called from within the code part\n    // that handles increases to row heights\n\n\n    block.allRowsHeight = rowsHeight;\n    var pBottom = pTop + rowsHeight;\n    var windowTop = scrollY;\n    var windowBottom = windowTop + scrollHeight;\n\n    if (windowTop < pBottom && windowBottom > pTop) {\n      pages.push(blockIndex);\n    }\n\n    pTop += rowsHeight; // consider this nice final optimization; put it in `for` condition - caveat, currently the\n    // block.allRowsHeight relies on being invalidated, so enabling this opt may not be safe\n    // if(pages.length > 1) break;\n  }\n\n  return pages;\n}\n\nfunction updateBlockYPosition(gd, cellsColumnBlock, tableControlView) {\n  var d = flatData(cellsColumnBlock)[0];\n  if (d === undefined) return;\n  var blocks = d.rowBlocks;\n  var calcdata = d.calcdata;\n  var bottom = firstRowAnchor(blocks, blocks.length);\n  var scrollHeight = d.calcdata.groupHeight - headerHeight(d);\n  var scrollY = calcdata.scrollY = Math.max(0, Math.min(bottom - scrollHeight, calcdata.scrollY));\n  var pages = findPagesAndCacheHeights(blocks, scrollY, scrollHeight);\n\n  if (pages.length === 1) {\n    if (pages[0] === blocks.length - 1) {\n      pages.unshift(pages[0] - 1);\n    } else {\n      pages.push(pages[0] + 1);\n    }\n  } // make phased out page jump by 2 while leaving stationary page intact\n\n\n  if (pages[0] % 2) {\n    pages.reverse();\n  }\n\n  cellsColumnBlock.each(function (d, i) {\n    // these values will also be needed when a block is translated again due to growing cell height\n    d.page = pages[i];\n    d.scrollY = scrollY;\n  });\n  cellsColumnBlock.attr('transform', function (d) {\n    var yTranslate = firstRowAnchor(d.rowBlocks, d.page) - d.scrollY;\n    return 'translate(0 ' + yTranslate + ')';\n  }); // conditionally rerendering panel 0 and 1\n\n  if (gd) {\n    conditionalPanelRerender(gd, tableControlView, cellsColumnBlock, pages, d.prevPages, d, 0);\n    conditionalPanelRerender(gd, tableControlView, cellsColumnBlock, pages, d.prevPages, d, 1);\n    renderScrollbarKit(tableControlView, gd);\n  }\n}\n\nfunction makeDragRow(gd, allTableControlView, optionalMultiplier, optionalPosition) {\n  return function dragRow(eventD) {\n    // may come from whichever DOM event target: drag, wheel, bar... eventD corresponds to event target\n    var d = eventD.calcdata ? eventD.calcdata : eventD;\n    var tableControlView = allTableControlView.filter(function (dd) {\n      return d.key === dd.key;\n    });\n    var multiplier = optionalMultiplier || d.scrollbarState.dragMultiplier;\n    var initialScrollY = d.scrollY;\n    d.scrollY = optionalPosition === void 0 ? d.scrollY + multiplier * d3.event.dy : optionalPosition;\n    var cellsColumnBlock = tableControlView.selectAll('.' + c.cn.yColumn).selectAll('.' + c.cn.columnBlock).filter(cellsBlock);\n    updateBlockYPosition(gd, cellsColumnBlock, tableControlView); // return false if we've \"used\" the scroll, ie it did something,\n    // so the event shouldn't bubble (if appropriate)\n\n    return d.scrollY === initialScrollY;\n  };\n}\n\nfunction conditionalPanelRerender(gd, tableControlView, cellsColumnBlock, pages, prevPages, d, revolverIndex) {\n  var shouldComponentUpdate = pages[revolverIndex] !== prevPages[revolverIndex];\n\n  if (shouldComponentUpdate) {\n    clearTimeout(d.currentRepaint[revolverIndex]);\n    d.currentRepaint[revolverIndex] = setTimeout(function () {\n      // setTimeout might lag rendering but yields a smoother scroll, because fast scrolling makes\n      // some repaints invisible ie. wasteful (DOM work blocks the main thread)\n      var toRerender = cellsColumnBlock.filter(function (d, i) {\n        return i === revolverIndex && pages[i] !== prevPages[i];\n      });\n      renderColumnCellTree(gd, tableControlView, toRerender, cellsColumnBlock);\n      prevPages[revolverIndex] = pages[revolverIndex];\n    });\n  }\n}\n\nfunction wrapTextMaker(columnBlock, element, tableControlView, gd) {\n  return function wrapText() {\n    var cellTextHolder = d3.select(element.parentNode);\n    cellTextHolder.each(function (d) {\n      var fragments = d.fragments;\n      cellTextHolder.selectAll('tspan.line').each(function (dd, i) {\n        fragments[i].width = this.getComputedTextLength();\n      }); // last element is only for measuring the separator character, so it's ignored:\n\n      var separatorLength = fragments[fragments.length - 1].width;\n      var rest = fragments.slice(0, -1);\n      var currentRow = [];\n      var currentAddition, currentAdditionLength;\n      var currentRowLength = 0;\n      var rowLengthLimit = d.column.columnWidth - 2 * c.cellPad;\n      d.value = '';\n\n      while (rest.length) {\n        currentAddition = rest.shift();\n        currentAdditionLength = currentAddition.width + separatorLength;\n\n        if (currentRowLength + currentAdditionLength > rowLengthLimit) {\n          d.value += currentRow.join(c.wrapSpacer) + c.lineBreaker;\n          currentRow = [];\n          currentRowLength = 0;\n        }\n\n        currentRow.push(currentAddition.text);\n        currentRowLength += currentAdditionLength;\n      }\n\n      if (currentRowLength) {\n        d.value += currentRow.join(c.wrapSpacer);\n      }\n\n      d.wrapped = true;\n    }); // the pre-wrapped text was rendered only for the text measurements\n\n    cellTextHolder.selectAll('tspan.line').remove(); // resupply text, now wrapped\n\n    populateCellText(cellTextHolder.select('.' + c.cn.cellText), tableControlView, columnBlock, gd);\n    d3.select(element.parentNode.parentNode).call(setCellHeightAndPositionY);\n  };\n}\n\nfunction updateYPositionMaker(columnBlock, element, tableControlView, gd, d) {\n  return function updateYPosition() {\n    if (d.settledY) return;\n    var cellTextHolder = d3.select(element.parentNode);\n    var l = getBlock(d);\n    var rowIndex = d.key - l.firstRowIndex;\n    var declaredRowHeight = l.rows[rowIndex].rowHeight;\n    var requiredHeight = d.cellHeightMayIncrease ? element.parentNode.getBoundingClientRect().height + 2 * c.cellPad : declaredRowHeight;\n    var finalHeight = Math.max(requiredHeight, declaredRowHeight);\n    var increase = finalHeight - l.rows[rowIndex].rowHeight;\n\n    if (increase) {\n      // current row height increased\n      l.rows[rowIndex].rowHeight = finalHeight;\n      columnBlock.selectAll('.' + c.cn.columnCell).call(setCellHeightAndPositionY);\n      updateBlockYPosition(null, columnBlock.filter(cellsBlock), 0); // if d.column.type === 'header', then the scrollbar has to be pushed downward to the scrollable area\n      // if d.column.type === 'cells', it can still be relevant if total scrolling content height is less than the\n      //                               scrollable window, as increases to row heights may need scrollbar updates\n\n      renderScrollbarKit(tableControlView, gd, true);\n    }\n\n    cellTextHolder.attr('transform', function () {\n      // this code block is only invoked for items where d.cellHeightMayIncrease is truthy\n      var element = this;\n      var columnCellElement = element.parentNode;\n      var box = columnCellElement.getBoundingClientRect();\n      var rectBox = d3.select(element.parentNode).select('.' + c.cn.cellRect).node().getBoundingClientRect();\n      var currentTransform = element.transform.baseVal.consolidate();\n      var yPosition = rectBox.top - box.top + (currentTransform ? currentTransform.matrix.f : c.cellPad);\n      return 'translate(' + xPosition(d, d3.select(element.parentNode).select('.' + c.cn.cellTextHolder).node().getBoundingClientRect().width) + ' ' + yPosition + ')';\n    });\n    d.settledY = true;\n  };\n}\n\nfunction xPosition(d, optionalWidth) {\n  switch (d.align) {\n    case 'left':\n      return c.cellPad;\n\n    case 'right':\n      return d.column.columnWidth - (optionalWidth || 0) - c.cellPad;\n\n    case 'center':\n      return (d.column.columnWidth - (optionalWidth || 0)) / 2;\n\n    default:\n      return c.cellPad;\n  }\n}\n\nfunction setCellHeightAndPositionY(columnCell) {\n  columnCell.attr('transform', function (d) {\n    var headerHeight = d.rowBlocks[0].auxiliaryBlocks.reduce(function (p, n) {\n      return p + rowsHeight(n, Infinity);\n    }, 0);\n    var l = getBlock(d);\n    var rowAnchor = rowsHeight(l, d.key);\n    var yOffset = rowAnchor + headerHeight;\n    return 'translate(0 ' + yOffset + ')';\n  }).selectAll('.' + c.cn.cellRect).attr('height', function (d) {\n    return getRow(getBlock(d), d.key).rowHeight;\n  });\n}\n\nfunction firstRowAnchor(blocks, page) {\n  var total = 0;\n\n  for (var i = page - 1; i >= 0; i--) {\n    total += allRowsHeight(blocks[i]);\n  }\n\n  return total;\n}\n\nfunction rowsHeight(rowBlock, key) {\n  var total = 0;\n\n  for (var i = 0; i < rowBlock.rows.length && rowBlock.rows[i].rowIndex < key; i++) {\n    total += rowBlock.rows[i].rowHeight;\n  }\n\n  return total;\n}\n\nfunction allRowsHeight(rowBlock) {\n  var cached = rowBlock.allRowsHeight;\n\n  if (cached !== void 0) {\n    return cached;\n  }\n\n  var total = 0;\n\n  for (var i = 0; i < rowBlock.rows.length; i++) {\n    total += rowBlock.rows[i].rowHeight;\n  }\n\n  rowBlock.allRowsHeight = total;\n  return total;\n}\n\nfunction getBlock(d) {\n  return d.rowBlocks[d.page];\n}\n\nfunction getRow(l, i) {\n  return l.rows[i - l.firstRowIndex];\n}","map":null,"metadata":{},"sourceType":"script"}