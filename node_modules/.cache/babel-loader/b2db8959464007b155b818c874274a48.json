{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\n\nvar calcAxisExpansion = require('../scatter/calc').calcAxisExpansion;\n\nvar calcColorscale = require('../scatter/colorscale_calc');\n\nvar convertMarkerSelection = require('../scattergl/convert').markerSelection;\n\nvar convertMarkerStyle = require('../scattergl/convert').markerStyle;\n\nvar sceneUpdate = require('./scene_update');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\n\nmodule.exports = function calc(gd, trace) {\n  var dimensions = trace.dimensions;\n  var commonLength = trace._length;\n  var opts = {}; // 'c' for calculated, 'l' for linear,\n  // only differ here for log axes, pass ldata to createMatrix as 'data'\n\n  var cdata = opts.cdata = [];\n  var ldata = opts.data = []; // keep track of visible dimensions\n\n  var visibleDims = trace._visibleDims = [];\n  var i, k, dim, xa, ya;\n\n  function makeCalcdata(ax, dim) {\n    // call makeCalcdata with fake input\n    var ccol = ax.makeCalcdata({\n      v: dim.values,\n      vcalendar: trace.calendar\n    }, 'v');\n\n    for (var j = 0; j < ccol.length; j++) {\n      ccol[j] = ccol[j] === BADNUM ? NaN : ccol[j];\n    }\n\n    cdata.push(ccol);\n    ldata.push(ax.type === 'log' ? Lib.simpleMap(ccol, ax.c2l) : ccol);\n  }\n\n  for (i = 0; i < dimensions.length; i++) {\n    dim = dimensions[i];\n\n    if (dim.visible) {\n      xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n      ya = AxisIDs.getFromId(gd, trace._diag[i][1]); // if corresponding x & y axes don't have matching types, skip dim\n\n      if (xa && ya && xa.type !== ya.type) {\n        Lib.log('Skipping splom dimension ' + i + ' with conflicting axis types');\n        continue;\n      }\n\n      if (xa) {\n        makeCalcdata(xa, dim);\n\n        if (ya && ya.type === 'category') {\n          ya._categories = xa._categories.slice();\n        }\n      } else {\n        // should not make it here, if both xa and ya undefined\n        makeCalcdata(ya, dim);\n      }\n\n      visibleDims.push(i);\n    }\n  }\n\n  calcColorscale(gd, trace);\n  Lib.extendFlat(opts, convertMarkerStyle(trace));\n  var visibleLength = cdata.length;\n  var hasTooManyPoints = visibleLength * commonLength > TOO_MANY_POINTS; // Reuse SVG scatter axis expansion routine.\n  // For graphs with very large number of points and array marker.size,\n  // use average marker size instead to speed things up.\n\n  var ppad;\n\n  if (hasTooManyPoints) {\n    ppad = 2 * (opts.sizeAvg || Math.max(opts.size, 3));\n  } else {\n    ppad = calcMarkerSize(trace, commonLength);\n  }\n\n  for (k = 0; k < visibleDims.length; k++) {\n    i = visibleDims[k];\n    dim = dimensions[i];\n    xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};\n    ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};\n    calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);\n  }\n\n  var scene = sceneUpdate(gd, trace);\n  if (!scene.matrix) scene.matrix = true;\n  scene.matrixOptions = opts;\n  scene.selectedOptions = convertMarkerSelection(trace, trace.selected);\n  scene.unselectedOptions = convertMarkerSelection(trace, trace.unselected);\n  return [{\n    x: false,\n    y: false,\n    t: {},\n    trace: trace\n  }];\n};","map":null,"metadata":{},"sourceType":"script"}