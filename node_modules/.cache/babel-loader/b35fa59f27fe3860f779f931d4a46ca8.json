{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar rgba = require('color-rgba');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Drawing = require('../../components/drawing');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar gup = require('../../lib/gup');\n\nvar keyFun = gup.keyFun;\nvar repeat = gup.repeat;\nvar unwrap = gup.unwrap;\n\nvar helpers = require('./helpers');\n\nvar c = require('./constants');\n\nvar brush = require('./axisbrush');\n\nvar lineLayerMaker = require('./lines');\n\nfunction findExtreme(fn, values, len) {\n  return Lib.aggNums(fn, null, values, len);\n}\n\nfunction findExtremes(values, len) {\n  return fixExtremes(findExtreme(Math.min, values, len), findExtreme(Math.max, values, len));\n}\n\nfunction dimensionExtent(dimension) {\n  var range = dimension.range;\n  return range ? fixExtremes(range[0], range[1]) : findExtremes(dimension.values, dimension._length);\n}\n\nfunction fixExtremes(lo, hi) {\n  if (isNaN(lo) || !isFinite(lo)) {\n    lo = 0;\n  }\n\n  if (isNaN(hi) || !isFinite(hi)) {\n    hi = 0;\n  } // avoid a degenerate (zero-width) domain\n\n\n  if (lo === hi) {\n    if (lo === 0) {\n      // no use to multiplying zero, so add/subtract in this case\n      lo -= 1;\n      hi += 1;\n    } else {\n      // this keeps the range in the order of magnitude of the data\n      lo *= 0.9;\n      hi *= 1.1;\n    }\n  }\n\n  return [lo, hi];\n}\n\nfunction toText(formatter, texts) {\n  if (texts) {\n    return function (v, i) {\n      var text = texts[i];\n      if (text === null || text === undefined) return formatter(v);\n      return text;\n    };\n  }\n\n  return formatter;\n}\n\nfunction domainScale(height, padding, dimension, tickvals, ticktext) {\n  var extent = dimensionExtent(dimension);\n\n  if (tickvals) {\n    return d3.scale.ordinal().domain(tickvals.map(toText(d3.format(dimension.tickformat), ticktext))).range(tickvals.map(function (d) {\n      var unitVal = (d - extent[0]) / (extent[1] - extent[0]);\n      return height - padding + unitVal * (2 * padding - height);\n    }));\n  }\n\n  return d3.scale.linear().domain(extent).range([height - padding, padding]);\n}\n\nfunction unitToPaddedPx(height, padding) {\n  return d3.scale.linear().range([padding, height - padding]);\n}\n\nfunction domainToPaddedUnitScale(dimension, padFraction) {\n  return d3.scale.linear().domain(dimensionExtent(dimension)).range([padFraction, 1 - padFraction]);\n}\n\nfunction ordinalScale(dimension) {\n  if (!dimension.tickvals) return;\n  var extent = dimensionExtent(dimension);\n  return d3.scale.ordinal().domain(dimension.tickvals).range(dimension.tickvals.map(function (d) {\n    return (d - extent[0]) / (extent[1] - extent[0]);\n  }));\n}\n\nfunction unitToColorScale(cscale) {\n  var colorStops = cscale.map(function (d) {\n    return d[0];\n  });\n  var colorTuples = cscale.map(function (d) {\n    var RGBA = rgba(d[1]);\n    return d3.rgb('rgb(' + RGBA[0] + ',' + RGBA[1] + ',' + RGBA[2] + ')');\n  });\n\n  var prop = function (n) {\n    return function (o) {\n      return o[n];\n    };\n  }; // We can't use d3 color interpolation as we may have non-uniform color palette raster\n  // (various color stop distances).\n\n\n  var polylinearUnitScales = 'rgb'.split('').map(function (key) {\n    return d3.scale.linear().clamp(true).domain(colorStops).range(colorTuples.map(prop(key)));\n  });\n  return function (d) {\n    return polylinearUnitScales.map(function (s) {\n      return s(d);\n    });\n  };\n}\n\nfunction someFiltersActive(view) {\n  return view.dimensions.some(function (p) {\n    return p.brush.filterSpecified;\n  });\n}\n\nfunction model(layout, d, i) {\n  var cd0 = unwrap(d);\n  var trace = cd0.trace;\n  var lineColor = helpers.convertTypedArray(cd0.lineColor);\n  var line = trace.line;\n  var deselectedLines = {\n    color: rgba(c.deselectedLineColor)\n  };\n  var cOpts = Colorscale.extractOpts(line);\n  var cscale = cOpts.reversescale ? Colorscale.flipScale(cd0.cscale) : cd0.cscale;\n  var domain = trace.domain;\n  var dimensions = trace.dimensions;\n  var width = layout.width;\n  var labelAngle = trace.labelangle;\n  var labelSide = trace.labelside;\n  var labelFont = trace.labelfont;\n  var tickFont = trace.tickfont;\n  var rangeFont = trace.rangefont;\n  var lines = Lib.extendDeepNoArrays({}, line, {\n    color: lineColor.map(d3.scale.linear().domain(dimensionExtent({\n      values: lineColor,\n      range: [cOpts.min, cOpts.max],\n      _length: trace._length\n    }))),\n    blockLineCount: c.blockLineCount,\n    canvasOverdrag: c.overdrag * c.canvasPixelRatio\n  });\n  var groupWidth = Math.floor(width * (domain.x[1] - domain.x[0]));\n  var groupHeight = Math.floor(layout.height * (domain.y[1] - domain.y[0]));\n  var pad = layout.margin || {\n    l: 80,\n    r: 80,\n    t: 100,\n    b: 80\n  };\n  var rowContentWidth = groupWidth;\n  var rowHeight = groupHeight;\n  return {\n    key: i,\n    colCount: dimensions.filter(helpers.isVisible).length,\n    dimensions: dimensions,\n    tickDistance: c.tickDistance,\n    unitToColor: unitToColorScale(cscale),\n    lines: lines,\n    deselectedLines: deselectedLines,\n    labelAngle: labelAngle,\n    labelSide: labelSide,\n    labelFont: labelFont,\n    tickFont: tickFont,\n    rangeFont: rangeFont,\n    layoutWidth: width,\n    layoutHeight: layout.height,\n    domain: domain,\n    translateX: domain.x[0] * width,\n    translateY: layout.height - domain.y[1] * layout.height,\n    pad: pad,\n    canvasWidth: rowContentWidth * c.canvasPixelRatio + 2 * lines.canvasOverdrag,\n    canvasHeight: rowHeight * c.canvasPixelRatio,\n    width: rowContentWidth,\n    height: rowHeight,\n    canvasPixelRatio: c.canvasPixelRatio\n  };\n}\n\nfunction viewModel(state, callbacks, model) {\n  var width = model.width;\n  var height = model.height;\n  var dimensions = model.dimensions;\n  var canvasPixelRatio = model.canvasPixelRatio;\n\n  var xScale = function (d) {\n    return width * d / Math.max(1, model.colCount - 1);\n  };\n\n  var unitPad = c.verticalPadding / height;\n\n  var _unitToPaddedPx = unitToPaddedPx(height, c.verticalPadding);\n\n  var vm = {\n    key: model.key,\n    xScale: xScale,\n    model: model,\n    inBrushDrag: false // consider factoring it out and putting it in a centralized global-ish gesture state object\n\n  };\n  var uniqueKeys = {};\n  vm.dimensions = dimensions.filter(helpers.isVisible).map(function (dimension, i) {\n    var domainToPaddedUnit = domainToPaddedUnitScale(dimension, unitPad);\n    var foundKey = uniqueKeys[dimension.label];\n    uniqueKeys[dimension.label] = (foundKey || 0) + 1;\n    var key = dimension.label + (foundKey ? '__' + foundKey : '');\n    var specifiedConstraint = dimension.constraintrange;\n    var filterRangeSpecified = specifiedConstraint && specifiedConstraint.length;\n\n    if (filterRangeSpecified && !Array.isArray(specifiedConstraint[0])) {\n      specifiedConstraint = [specifiedConstraint];\n    }\n\n    var filterRange = filterRangeSpecified ? specifiedConstraint.map(function (d) {\n      return d.map(domainToPaddedUnit);\n    }) : [[-Infinity, Infinity]];\n\n    var brushMove = function () {\n      var p = vm;\n      p.focusLayer && p.focusLayer.render(p.panels, true);\n      var filtersActive = someFiltersActive(p);\n\n      if (!state.contextShown() && filtersActive) {\n        p.contextLayer && p.contextLayer.render(p.panels, true);\n        state.contextShown(true);\n      } else if (state.contextShown() && !filtersActive) {\n        p.contextLayer && p.contextLayer.render(p.panels, true, true);\n        state.contextShown(false);\n      }\n    };\n\n    var truncatedValues = dimension.values;\n\n    if (truncatedValues.length > dimension._length) {\n      truncatedValues = truncatedValues.slice(0, dimension._length);\n    }\n\n    var tickvals = dimension.tickvals;\n    var ticktext;\n\n    function makeTickItem(v, i) {\n      return {\n        val: v,\n        text: ticktext[i]\n      };\n    }\n\n    function sortTickItem(a, b) {\n      return a.val - b.val;\n    }\n\n    if (Array.isArray(tickvals) && tickvals.length) {\n      ticktext = dimension.ticktext; // ensure ticktext and tickvals have same length\n\n      if (!Array.isArray(ticktext) || !ticktext.length) {\n        ticktext = tickvals.map(d3.format(dimension.tickformat));\n      } else if (ticktext.length > tickvals.length) {\n        ticktext = ticktext.slice(0, tickvals.length);\n      } else if (tickvals.length > ticktext.length) {\n        tickvals = tickvals.slice(0, ticktext.length);\n      } // check if we need to sort tickvals/ticktext\n\n\n      for (var j = 1; j < tickvals.length; j++) {\n        if (tickvals[j] < tickvals[j - 1]) {\n          var tickItems = tickvals.map(makeTickItem).sort(sortTickItem);\n\n          for (var k = 0; k < tickvals.length; k++) {\n            tickvals[k] = tickItems[k].val;\n            ticktext[k] = tickItems[k].text;\n          }\n\n          break;\n        }\n      }\n    } else tickvals = undefined;\n\n    truncatedValues = helpers.convertTypedArray(truncatedValues);\n    truncatedValues = helpers.convertTypedArray(truncatedValues);\n    return {\n      key: key,\n      label: dimension.label,\n      tickFormat: dimension.tickformat,\n      tickvals: tickvals,\n      ticktext: ticktext,\n      ordinal: helpers.isOrdinal(dimension),\n      multiselect: dimension.multiselect,\n      xIndex: i,\n      crossfilterDimensionIndex: i,\n      visibleIndex: dimension._index,\n      height: height,\n      values: truncatedValues,\n      paddedUnitValues: truncatedValues.map(domainToPaddedUnit),\n      unitTickvals: tickvals && tickvals.map(domainToPaddedUnit),\n      xScale: xScale,\n      x: xScale(i),\n      canvasX: xScale(i) * canvasPixelRatio,\n      unitToPaddedPx: _unitToPaddedPx,\n      domainScale: domainScale(height, c.verticalPadding, dimension, tickvals, ticktext),\n      ordinalScale: ordinalScale(dimension),\n      parent: vm,\n      model: model,\n      brush: brush.makeBrush(state, filterRangeSpecified, filterRange, function () {\n        state.linePickActive(false);\n      }, brushMove, function (f) {\n        vm.focusLayer.render(vm.panels, true);\n        vm.pickLayer && vm.pickLayer.render(vm.panels, true);\n        state.linePickActive(true);\n\n        if (callbacks && callbacks.filterChanged) {\n          var invScale = domainToPaddedUnit.invert; // update gd.data as if a Plotly.restyle were fired\n\n          var newRanges = f.map(function (r) {\n            return r.map(invScale).sort(Lib.sorterAsc);\n          }).sort(function (a, b) {\n            return a[0] - b[0];\n          });\n          callbacks.filterChanged(vm.key, dimension._index, newRanges);\n        }\n      })\n    };\n  });\n  return vm;\n}\n\nfunction styleExtentTexts(selection) {\n  selection.classed(c.cn.axisExtentText, true).attr('text-anchor', 'middle').style('cursor', 'default').style('user-select', 'none');\n}\n\nfunction parcoordsInteractionState() {\n  var linePickActive = true;\n  var contextShown = false;\n  return {\n    linePickActive: function (val) {\n      return arguments.length ? linePickActive = !!val : linePickActive;\n    },\n    contextShown: function (val) {\n      return arguments.length ? contextShown = !!val : contextShown;\n    }\n  };\n}\n\nfunction calcTilt(angle, position) {\n  var dir = position === 'top' ? 1 : -1;\n  var radians = angle * Math.PI / 180;\n  var dx = Math.sin(radians);\n  var dy = Math.cos(radians);\n  return {\n    dir: dir,\n    dx: dx,\n    dy: dy,\n    degrees: angle\n  };\n}\n\nfunction updatePanelLayout(yAxis, vm) {\n  var panels = vm.panels || (vm.panels = []);\n  var data = yAxis.data();\n\n  for (var i = 0; i < data.length - 1; i++) {\n    var p = panels[i] || (panels[i] = {});\n    var dim0 = data[i];\n    var dim1 = data[i + 1];\n    p.dim0 = dim0;\n    p.dim1 = dim1;\n    p.canvasX = dim0.canvasX;\n    p.panelSizeX = dim1.canvasX - dim0.canvasX;\n    p.panelSizeY = vm.model.canvasHeight;\n    p.y = 0;\n    p.canvasY = 0;\n  }\n}\n\nfunction calcAllTicks(cd) {\n  for (var i = 0; i < cd.length; i++) {\n    for (var j = 0; j < cd[i].length; j++) {\n      var trace = cd[i][j].trace;\n      var dimensions = trace.dimensions;\n\n      for (var k = 0; k < dimensions.length; k++) {\n        var values = dimensions[k].values;\n        var dim = dimensions[k]._ax;\n\n        if (dim) {\n          if (!dim.range) {\n            dim.range = findExtremes(values, trace._length);\n          } else {\n            dim.range = fixExtremes(dim.range[0], dim.range[1]);\n          }\n\n          if (!dim.dtick) {\n            dim.dtick = 0.01 * (Math.abs(dim.range[1] - dim.range[0]) || 1);\n          }\n\n          dim.tickformat = dimensions[k].tickformat;\n          Axes.calcTicks(dim);\n          dim.cleanRange();\n        }\n      }\n    }\n  }\n}\n\nfunction linearFormat(dim, v) {\n  return Axes.tickText(dim._ax, v, false).text;\n}\n\nfunction extremeText(d, isTop) {\n  if (d.ordinal) return '';\n  var domain = d.domainScale.domain();\n  var v = domain[isTop ? domain.length - 1 : 0];\n  return linearFormat(d.model.dimensions[d.visibleIndex], v);\n}\n\nmodule.exports = function parcoords(gd, cdModule, layout, callbacks) {\n  var fullLayout = gd._fullLayout;\n  var svg = fullLayout._toppaper;\n  var glContainer = fullLayout._glcontainer;\n  calcAllTicks(cdModule);\n  var state = parcoordsInteractionState();\n  var vm = cdModule.filter(function (d) {\n    return unwrap(d).trace.visible;\n  }).map(model.bind(0, layout)).map(viewModel.bind(0, state, callbacks));\n  glContainer.each(function (d, i) {\n    return Lib.extendFlat(d, vm[i]);\n  });\n  var glLayers = glContainer.selectAll('.gl-canvas').each(function (d) {\n    // FIXME: figure out how to handle multiple instances\n    d.viewModel = vm[0];\n    d.model = d.viewModel ? d.viewModel.model : null;\n  });\n  var lastHovered = null;\n  var pickLayer = glLayers.filter(function (d) {\n    return d.pick;\n  }); // emit hover / unhover event\n\n  pickLayer.style('pointer-events', 'auto').on('mousemove', function (d) {\n    if (state.linePickActive() && d.lineLayer && callbacks && callbacks.hover) {\n      var event = d3.event;\n      var cw = this.width;\n      var ch = this.height;\n      var pointer = d3.mouse(this);\n      var x = pointer[0];\n      var y = pointer[1];\n\n      if (x < 0 || y < 0 || x >= cw || y >= ch) {\n        return;\n      }\n\n      var pixel = d.lineLayer.readPixel(x, ch - 1 - y);\n      var found = pixel[3] !== 0; // inverse of the calcPickColor in `lines.js`; detailed comment there\n\n      var curveNumber = found ? pixel[2] + 256 * (pixel[1] + 256 * pixel[0]) : null;\n      var eventData = {\n        x: x,\n        y: y,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        dataIndex: d.model.key,\n        curveNumber: curveNumber\n      };\n\n      if (curveNumber !== lastHovered) {\n        // don't unnecessarily repeat the same hit (or miss)\n        if (found) {\n          callbacks.hover(eventData);\n        } else if (callbacks.unhover) {\n          callbacks.unhover(eventData);\n        }\n\n        lastHovered = curveNumber;\n      }\n    }\n  });\n  glLayers.style('opacity', function (d) {\n    return d.pick ? 0 : 1;\n  });\n  svg.style('background', 'rgba(255, 255, 255, 0)');\n  var controlOverlay = svg.selectAll('.' + c.cn.parcoords).data(vm, keyFun);\n  controlOverlay.exit().remove();\n  controlOverlay.enter().append('g').classed(c.cn.parcoords, true).style('shape-rendering', 'crispEdges').style('pointer-events', 'none');\n  controlOverlay.attr('transform', function (d) {\n    return 'translate(' + d.model.translateX + ',' + d.model.translateY + ')';\n  });\n  var parcoordsControlView = controlOverlay.selectAll('.' + c.cn.parcoordsControlView).data(repeat, keyFun);\n  parcoordsControlView.enter().append('g').classed(c.cn.parcoordsControlView, true);\n  parcoordsControlView.attr('transform', function (d) {\n    return 'translate(' + d.model.pad.l + ',' + d.model.pad.t + ')';\n  });\n  var yAxis = parcoordsControlView.selectAll('.' + c.cn.yAxis).data(function (p) {\n    return p.dimensions;\n  }, keyFun);\n  yAxis.enter().append('g').classed(c.cn.yAxis, true);\n  parcoordsControlView.each(function (p) {\n    updatePanelLayout(yAxis, p);\n  });\n  glLayers.each(function (d) {\n    if (d.viewModel) {\n      if (!d.lineLayer || callbacks) {\n        // recreate in case of having callbacks e.g. restyle. Should we test for callback to be a restyle?\n        d.lineLayer = lineLayerMaker(this, d);\n      } else d.lineLayer.update(d);\n\n      if (d.key || d.key === 0) d.viewModel[d.key] = d.lineLayer;\n      var setChanged = !d.context || // don't update background\n      callbacks; // unless there is a callback on the context layer. Should we test the callback?\n\n      d.lineLayer.render(d.viewModel.panels, setChanged);\n    }\n  });\n  yAxis.attr('transform', function (d) {\n    return 'translate(' + d.xScale(d.xIndex) + ', 0)';\n  }); // drag column for reordering columns\n\n  yAxis.call(d3.behavior.drag().origin(function (d) {\n    return d;\n  }).on('drag', function (d) {\n    var p = d.parent;\n    state.linePickActive(false);\n    d.x = Math.max(-c.overdrag, Math.min(d.model.width + c.overdrag, d3.event.x));\n    d.canvasX = d.x * d.model.canvasPixelRatio;\n    yAxis.sort(function (a, b) {\n      return a.x - b.x;\n    }).each(function (e, i) {\n      e.xIndex = i;\n      e.x = d === e ? e.x : e.xScale(e.xIndex);\n      e.canvasX = e.x * e.model.canvasPixelRatio;\n    });\n    updatePanelLayout(yAxis, p);\n    yAxis.filter(function (e) {\n      return Math.abs(d.xIndex - e.xIndex) !== 0;\n    }).attr('transform', function (d) {\n      return 'translate(' + d.xScale(d.xIndex) + ', 0)';\n    });\n    d3.select(this).attr('transform', 'translate(' + d.x + ', 0)');\n    yAxis.each(function (e, i0, i1) {\n      if (i1 === d.parent.key) p.dimensions[i0] = e;\n    });\n    p.contextLayer && p.contextLayer.render(p.panels, false, !someFiltersActive(p));\n    p.focusLayer.render && p.focusLayer.render(p.panels);\n  }).on('dragend', function (d) {\n    var p = d.parent;\n    d.x = d.xScale(d.xIndex);\n    d.canvasX = d.x * d.model.canvasPixelRatio;\n    updatePanelLayout(yAxis, p);\n    d3.select(this).attr('transform', function (d) {\n      return 'translate(' + d.x + ', 0)';\n    });\n    p.contextLayer && p.contextLayer.render(p.panels, false, !someFiltersActive(p));\n    p.focusLayer && p.focusLayer.render(p.panels);\n    p.pickLayer && p.pickLayer.render(p.panels, true);\n    state.linePickActive(true);\n\n    if (callbacks && callbacks.axesMoved) {\n      callbacks.axesMoved(p.key, p.dimensions.map(function (e) {\n        return e.crossfilterDimensionIndex;\n      }));\n    }\n  }));\n  yAxis.exit().remove();\n  var axisOverlays = yAxis.selectAll('.' + c.cn.axisOverlays).data(repeat, keyFun);\n  axisOverlays.enter().append('g').classed(c.cn.axisOverlays, true);\n  axisOverlays.selectAll('.' + c.cn.axis).remove();\n  var axis = axisOverlays.selectAll('.' + c.cn.axis).data(repeat, keyFun);\n  axis.enter().append('g').classed(c.cn.axis, true);\n  axis.each(function (d) {\n    var wantedTickCount = d.model.height / d.model.tickDistance;\n    var scale = d.domainScale;\n    var sdom = scale.domain();\n    d3.select(this).call(d3.svg.axis().orient('left').tickSize(4).outerTickSize(2).ticks(wantedTickCount, d.tickFormat) // works for continuous scales only...\n    .tickValues(d.ordinal ? // and this works for ordinal scales\n    sdom : null).tickFormat(function (v) {\n      return helpers.isOrdinal(d) ? v : linearFormat(d.model.dimensions[d.visibleIndex], v);\n    }).scale(scale));\n    Drawing.font(axis.selectAll('text'), d.model.tickFont);\n  });\n  axis.selectAll('.domain, .tick>line').attr('fill', 'none').attr('stroke', 'black').attr('stroke-opacity', 0.25).attr('stroke-width', '1px');\n  axis.selectAll('text').style('text-shadow', '1px 1px 1px #fff, -1px -1px 1px #fff, 1px -1px 1px #fff, -1px 1px 1px #fff').style('cursor', 'default').style('user-select', 'none');\n  var axisHeading = axisOverlays.selectAll('.' + c.cn.axisHeading).data(repeat, keyFun);\n  axisHeading.enter().append('g').classed(c.cn.axisHeading, true);\n  var axisTitle = axisHeading.selectAll('.' + c.cn.axisTitle).data(repeat, keyFun);\n  axisTitle.enter().append('text').classed(c.cn.axisTitle, true).attr('text-anchor', 'middle').style('cursor', 'ew-resize').style('user-select', 'none').style('pointer-events', 'auto');\n  axisTitle.text(function (d) {\n    return d.label;\n  }).each(function (d) {\n    var e = d3.select(this);\n    Drawing.font(e, d.model.labelFont);\n    svgTextUtils.convertToTspans(e, gd);\n  }).attr('transform', function (d) {\n    var tilt = calcTilt(d.model.labelAngle, d.model.labelSide);\n    var r = c.axisTitleOffset;\n    return (tilt.dir > 0 ? '' : 'translate(0,' + (2 * r + d.model.height) + ')') + 'rotate(' + tilt.degrees + ')' + 'translate(' + -r * tilt.dx + ',' + -r * tilt.dy + ')';\n  }).attr('text-anchor', function (d) {\n    var tilt = calcTilt(d.model.labelAngle, d.model.labelSide);\n    var adx = Math.abs(tilt.dx);\n    var ady = Math.abs(tilt.dy);\n\n    if (2 * adx > ady) {\n      return tilt.dir * tilt.dx < 0 ? 'start' : 'end';\n    } else {\n      return 'middle';\n    }\n  });\n  var axisExtent = axisOverlays.selectAll('.' + c.cn.axisExtent).data(repeat, keyFun);\n  axisExtent.enter().append('g').classed(c.cn.axisExtent, true);\n  var axisExtentTop = axisExtent.selectAll('.' + c.cn.axisExtentTop).data(repeat, keyFun);\n  axisExtentTop.enter().append('g').classed(c.cn.axisExtentTop, true);\n  axisExtentTop.attr('transform', 'translate(' + 0 + ',' + -c.axisExtentOffset + ')');\n  var axisExtentTopText = axisExtentTop.selectAll('.' + c.cn.axisExtentTopText).data(repeat, keyFun);\n  axisExtentTopText.enter().append('text').classed(c.cn.axisExtentTopText, true).call(styleExtentTexts);\n  axisExtentTopText.text(function (d) {\n    return extremeText(d, true);\n  }).each(function (d) {\n    Drawing.font(d3.select(this), d.model.rangeFont);\n  });\n  var axisExtentBottom = axisExtent.selectAll('.' + c.cn.axisExtentBottom).data(repeat, keyFun);\n  axisExtentBottom.enter().append('g').classed(c.cn.axisExtentBottom, true);\n  axisExtentBottom.attr('transform', function (d) {\n    return 'translate(' + 0 + ',' + (d.model.height + c.axisExtentOffset) + ')';\n  });\n  var axisExtentBottomText = axisExtentBottom.selectAll('.' + c.cn.axisExtentBottomText).data(repeat, keyFun);\n  axisExtentBottomText.enter().append('text').classed(c.cn.axisExtentBottomText, true).attr('dy', '0.75em').call(styleExtentTexts);\n  axisExtentBottomText.text(function (d) {\n    return extremeText(d, false);\n  }).each(function (d) {\n    Drawing.font(d3.select(this), d.model.rangeFont);\n  });\n  brush.ensureAxisBrush(axisOverlays);\n};","map":null,"metadata":{},"sourceType":"script"}