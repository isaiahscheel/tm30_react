{"ast":null,"code":"'use strict';\n\nmodule.exports = createFilteredVector;\n\nvar cubicHermite = require('cubic-hermite');\n\nvar bsearch = require('binary-search-bounds');\n\nfunction clamp(lo, hi, x) {\n  return Math.min(hi, Math.max(lo, x));\n}\n\nfunction FilteredVector(state0, velocity0, t0) {\n  this.dimension = state0.length;\n  this.bounds = [new Array(this.dimension), new Array(this.dimension)];\n\n  for (var i = 0; i < this.dimension; ++i) {\n    this.bounds[0][i] = -Infinity;\n    this.bounds[1][i] = Infinity;\n  }\n\n  this._state = state0.slice().reverse();\n  this._velocity = velocity0.slice().reverse();\n  this._time = [t0];\n  this._scratch = [state0.slice(), state0.slice(), state0.slice(), state0.slice(), state0.slice()];\n}\n\nvar proto = FilteredVector.prototype;\n\nproto.flush = function (t) {\n  var idx = bsearch.gt(this._time, t) - 1;\n\n  if (idx <= 0) {\n    return;\n  }\n\n  this._time.splice(0, idx);\n\n  this._state.splice(0, idx * this.dimension);\n\n  this._velocity.splice(0, idx * this.dimension);\n};\n\nproto.curve = function (t) {\n  var time = this._time;\n  var n = time.length;\n  var idx = bsearch.le(time, t);\n  var result = this._scratch[0];\n  var state = this._state;\n  var velocity = this._velocity;\n  var d = this.dimension;\n  var bounds = this.bounds;\n\n  if (idx < 0) {\n    var ptr = d - 1;\n\n    for (var i = 0; i < d; ++i, --ptr) {\n      result[i] = state[ptr];\n    }\n  } else if (idx >= n - 1) {\n    var ptr = state.length - 1;\n    var tf = t - time[n - 1];\n\n    for (var i = 0; i < d; ++i, --ptr) {\n      result[i] = state[ptr] + tf * velocity[ptr];\n    }\n  } else {\n    var ptr = d * (idx + 1) - 1;\n    var t0 = time[idx];\n    var t1 = time[idx + 1];\n    var dt = t1 - t0 || 1.0;\n    var x0 = this._scratch[1];\n    var x1 = this._scratch[2];\n    var v0 = this._scratch[3];\n    var v1 = this._scratch[4];\n    var steady = true;\n\n    for (var i = 0; i < d; ++i, --ptr) {\n      x0[i] = state[ptr];\n      v0[i] = velocity[ptr] * dt;\n      x1[i] = state[ptr + d];\n      v1[i] = velocity[ptr + d] * dt;\n      steady = steady && x0[i] === x1[i] && v0[i] === v1[i] && v0[i] === 0.0;\n    }\n\n    if (steady) {\n      for (var i = 0; i < d; ++i) {\n        result[i] = x0[i];\n      }\n    } else {\n      cubicHermite(x0, v0, x1, v1, (t - t0) / dt, result);\n    }\n  }\n\n  var lo = bounds[0];\n  var hi = bounds[1];\n\n  for (var i = 0; i < d; ++i) {\n    result[i] = clamp(lo[i], hi[i], result[i]);\n  }\n\n  return result;\n};\n\nproto.dcurve = function (t) {\n  var time = this._time;\n  var n = time.length;\n  var idx = bsearch.le(time, t);\n  var result = this._scratch[0];\n  var state = this._state;\n  var velocity = this._velocity;\n  var d = this.dimension;\n\n  if (idx >= n - 1) {\n    var ptr = state.length - 1;\n    var tf = t - time[n - 1];\n\n    for (var i = 0; i < d; ++i, --ptr) {\n      result[i] = velocity[ptr];\n    }\n  } else {\n    var ptr = d * (idx + 1) - 1;\n    var t0 = time[idx];\n    var t1 = time[idx + 1];\n    var dt = t1 - t0 || 1.0;\n    var x0 = this._scratch[1];\n    var x1 = this._scratch[2];\n    var v0 = this._scratch[3];\n    var v1 = this._scratch[4];\n    var steady = true;\n\n    for (var i = 0; i < d; ++i, --ptr) {\n      x0[i] = state[ptr];\n      v0[i] = velocity[ptr] * dt;\n      x1[i] = state[ptr + d];\n      v1[i] = velocity[ptr + d] * dt;\n      steady = steady && x0[i] === x1[i] && v0[i] === v1[i] && v0[i] === 0.0;\n    }\n\n    if (steady) {\n      for (var i = 0; i < d; ++i) {\n        result[i] = 0.0;\n      }\n    } else {\n      cubicHermite.derivative(x0, v0, x1, v1, (t - t0) / dt, result);\n\n      for (var i = 0; i < d; ++i) {\n        result[i] /= dt;\n      }\n    }\n  }\n\n  return result;\n};\n\nproto.lastT = function () {\n  var time = this._time;\n  return time[time.length - 1];\n};\n\nproto.stable = function () {\n  var velocity = this._velocity;\n  var ptr = velocity.length;\n\n  for (var i = this.dimension - 1; i >= 0; --i) {\n    if (velocity[--ptr]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nproto.jump = function (t) {\n  var t0 = this.lastT();\n  var d = this.dimension;\n\n  if (t < t0 || arguments.length !== d + 1) {\n    return;\n  }\n\n  var state = this._state;\n  var velocity = this._velocity;\n  var ptr = state.length - this.dimension;\n  var bounds = this.bounds;\n  var lo = bounds[0];\n  var hi = bounds[1];\n\n  this._time.push(t0, t);\n\n  for (var j = 0; j < 2; ++j) {\n    for (var i = 0; i < d; ++i) {\n      state.push(state[ptr++]);\n      velocity.push(0);\n    }\n  }\n\n  this._time.push(t);\n\n  for (var i = d; i > 0; --i) {\n    state.push(clamp(lo[i - 1], hi[i - 1], arguments[i]));\n    velocity.push(0);\n  }\n};\n\nproto.push = function (t) {\n  var t0 = this.lastT();\n  var d = this.dimension;\n\n  if (t < t0 || arguments.length !== d + 1) {\n    return;\n  }\n\n  var state = this._state;\n  var velocity = this._velocity;\n  var ptr = state.length - this.dimension;\n  var dt = t - t0;\n  var bounds = this.bounds;\n  var lo = bounds[0];\n  var hi = bounds[1];\n  var sf = dt > 1e-6 ? 1 / dt : 0;\n\n  this._time.push(t);\n\n  for (var i = d; i > 0; --i) {\n    var xc = clamp(lo[i - 1], hi[i - 1], arguments[i]);\n    state.push(xc);\n    velocity.push((xc - state[ptr++]) * sf);\n  }\n};\n\nproto.set = function (t) {\n  var d = this.dimension;\n\n  if (t < this.lastT() || arguments.length !== d + 1) {\n    return;\n  }\n\n  var state = this._state;\n  var velocity = this._velocity;\n  var bounds = this.bounds;\n  var lo = bounds[0];\n  var hi = bounds[1];\n\n  this._time.push(t);\n\n  for (var i = d; i > 0; --i) {\n    state.push(clamp(lo[i - 1], hi[i - 1], arguments[i]));\n    velocity.push(0);\n  }\n};\n\nproto.move = function (t) {\n  var t0 = this.lastT();\n  var d = this.dimension;\n\n  if (t <= t0 || arguments.length !== d + 1) {\n    return;\n  }\n\n  var state = this._state;\n  var velocity = this._velocity;\n  var statePtr = state.length - this.dimension;\n  var bounds = this.bounds;\n  var lo = bounds[0];\n  var hi = bounds[1];\n  var dt = t - t0;\n  var sf = dt > 1e-6 ? 1 / dt : 0.0;\n\n  this._time.push(t);\n\n  for (var i = d; i > 0; --i) {\n    var dx = arguments[i];\n    state.push(clamp(lo[i - 1], hi[i - 1], state[statePtr++] + dx));\n    velocity.push(dx * sf);\n  }\n};\n\nproto.idle = function (t) {\n  var t0 = this.lastT();\n\n  if (t < t0) {\n    return;\n  }\n\n  var d = this.dimension;\n  var state = this._state;\n  var velocity = this._velocity;\n  var statePtr = state.length - d;\n  var bounds = this.bounds;\n  var lo = bounds[0];\n  var hi = bounds[1];\n  var dt = t - t0;\n\n  this._time.push(t);\n\n  for (var i = d - 1; i >= 0; --i) {\n    state.push(clamp(lo[i], hi[i], state[statePtr] + dt * velocity[statePtr]));\n    velocity.push(0);\n    statePtr += 1;\n  }\n};\n\nfunction getZero(d) {\n  var result = new Array(d);\n\n  for (var i = 0; i < d; ++i) {\n    result[i] = 0.0;\n  }\n\n  return result;\n}\n\nfunction createFilteredVector(initState, initVelocity, initTime) {\n  switch (arguments.length) {\n    case 0:\n      return new FilteredVector([0], [0], 0);\n\n    case 1:\n      if (typeof initState === 'number') {\n        var zero = getZero(initState);\n        return new FilteredVector(zero, zero, 0);\n      } else {\n        return new FilteredVector(initState, getZero(initState.length), 0);\n      }\n\n    case 2:\n      if (typeof initVelocity === 'number') {\n        var zero = getZero(initState.length);\n        return new FilteredVector(initState, zero, +initVelocity);\n      } else {\n        initTime = 0;\n      }\n\n    case 3:\n      if (initState.length !== initVelocity.length) {\n        throw new Error('state and velocity lengths must match');\n      }\n\n      return new FilteredVector(initState, initVelocity, initTime);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}