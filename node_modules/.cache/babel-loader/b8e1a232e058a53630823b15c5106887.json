{"ast":null,"code":"\"use strict\"; //High level idea:\n// 1. Use Clarkson's incremental construction to find convex hull\n// 2. Point location in triangulation by jump and walk\n\nmodule.exports = incrementalConvexHull;\n\nvar orient = require(\"robust-orientation\");\n\nvar compareCell = require(\"simplicial-complex\").compareCells;\n\nfunction compareInt(a, b) {\n  return a - b;\n}\n\nfunction Simplex(vertices, adjacent, boundary) {\n  this.vertices = vertices;\n  this.adjacent = adjacent;\n  this.boundary = boundary;\n  this.lastVisited = -1;\n}\n\nSimplex.prototype.flip = function () {\n  var t = this.vertices[0];\n  this.vertices[0] = this.vertices[1];\n  this.vertices[1] = t;\n  var u = this.adjacent[0];\n  this.adjacent[0] = this.adjacent[1];\n  this.adjacent[1] = u;\n};\n\nfunction GlueFacet(vertices, cell, index) {\n  this.vertices = vertices;\n  this.cell = cell;\n  this.index = index;\n}\n\nfunction compareGlue(a, b) {\n  return compareCell(a.vertices, b.vertices);\n}\n\nfunction bakeOrient(d) {\n  var code = [\"function orient(){var tuple=this.tuple;return test(\"];\n\n  for (var i = 0; i <= d; ++i) {\n    if (i > 0) {\n      code.push(\",\");\n    }\n\n    code.push(\"tuple[\", i, \"]\");\n  }\n\n  code.push(\")}return orient\");\n  var proc = new Function(\"test\", code.join(\"\"));\n  var test = orient[d + 1];\n\n  if (!test) {\n    test = orient;\n  }\n\n  return proc(test);\n}\n\nvar BAKED = [];\n\nfunction Triangulation(dimension, vertices, simplices) {\n  this.dimension = dimension;\n  this.vertices = vertices;\n  this.simplices = simplices;\n  this.interior = simplices.filter(function (c) {\n    return !c.boundary;\n  });\n  this.tuple = new Array(dimension + 1);\n\n  for (var i = 0; i <= dimension; ++i) {\n    this.tuple[i] = this.vertices[i];\n  }\n\n  var o = BAKED[dimension];\n\n  if (!o) {\n    o = BAKED[dimension] = bakeOrient(dimension);\n  }\n\n  this.orient = o;\n}\n\nvar proto = Triangulation.prototype; //Degenerate situation where we are on boundary, but coplanar to face\n\nproto.handleBoundaryDegeneracy = function (cell, point) {\n  var d = this.dimension;\n  var n = this.vertices.length - 1;\n  var tuple = this.tuple;\n  var verts = this.vertices; //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n\n  var toVisit = [cell];\n  cell.lastVisited = -n;\n\n  while (toVisit.length > 0) {\n    cell = toVisit.pop();\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n\n      if (!neighbor.boundary || neighbor.lastVisited <= -n) {\n        continue;\n      }\n\n      var nv = neighbor.vertices;\n\n      for (var j = 0; j <= d; ++j) {\n        var vv = nv[j];\n\n        if (vv < 0) {\n          tuple[j] = point;\n        } else {\n          tuple[j] = verts[vv];\n        }\n      }\n\n      var o = this.orient();\n\n      if (o > 0) {\n        return neighbor;\n      }\n\n      neighbor.lastVisited = -n;\n\n      if (o === 0) {\n        toVisit.push(neighbor);\n      }\n    }\n  }\n\n  return null;\n};\n\nproto.walk = function (point, random) {\n  //Alias local properties\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple; //Compute initial jump cell\n\n  var initIndex = random ? this.interior.length * Math.random() | 0 : this.interior.length - 1;\n  var cell = this.interior[initIndex]; //Start walking\n\n  outerLoop: while (!cell.boundary) {\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n\n    for (var i = 0; i <= d; ++i) {\n      tuple[i] = verts[cellVerts[i]];\n    }\n\n    cell.lastVisited = n; //Find farthest adjacent cell\n\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n\n      if (neighbor.lastVisited >= n) {\n        continue;\n      }\n\n      var prev = tuple[i];\n      tuple[i] = point;\n      var o = this.orient();\n      tuple[i] = prev;\n\n      if (o < 0) {\n        cell = neighbor;\n        continue outerLoop;\n      } else {\n        if (!neighbor.boundary) {\n          neighbor.lastVisited = n;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n    }\n\n    return;\n  }\n\n  return cell;\n};\n\nproto.addPeaks = function (point, cell) {\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple;\n  var interior = this.interior;\n  var simplices = this.simplices; //Walking finished at boundary, time to add peaks\n\n  var tovisit = [cell]; //Stretch initial boundary cell into a peak\n\n  cell.lastVisited = n;\n  cell.vertices[cell.vertices.indexOf(-1)] = n;\n  cell.boundary = false;\n  interior.push(cell); //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n\n  var glueFacets = []; //Do a traversal of the boundary walking outward from starting peak\n\n  while (tovisit.length > 0) {\n    //Pop off peak and walk over adjacent cells\n    var cell = tovisit.pop();\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n    var indexOfN = cellVerts.indexOf(n);\n\n    if (indexOfN < 0) {\n      continue;\n    }\n\n    for (var i = 0; i <= d; ++i) {\n      if (i === indexOfN) {\n        continue;\n      } //For each boundary neighbor of the cell\n\n\n      var neighbor = cellAdj[i];\n\n      if (!neighbor.boundary || neighbor.lastVisited >= n) {\n        continue;\n      }\n\n      var nv = neighbor.vertices; //Test if neighbor is a peak\n\n      if (neighbor.lastVisited !== -n) {\n        //Compute orientation of p relative to each boundary peak\n        var indexOfNeg1 = 0;\n\n        for (var j = 0; j <= d; ++j) {\n          if (nv[j] < 0) {\n            indexOfNeg1 = j;\n            tuple[j] = point;\n          } else {\n            tuple[j] = verts[nv[j]];\n          }\n        }\n\n        var o = this.orient(); //Test if neighbor cell is also a peak\n\n        if (o > 0) {\n          nv[indexOfNeg1] = n;\n          neighbor.boundary = false;\n          interior.push(neighbor);\n          tovisit.push(neighbor);\n          neighbor.lastVisited = n;\n          continue;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n\n      var na = neighbor.adjacent; //Otherwise, replace neighbor with new face\n\n      var vverts = cellVerts.slice();\n      var vadj = cellAdj.slice();\n      var ncell = new Simplex(vverts, vadj, true);\n      simplices.push(ncell); //Connect to neighbor\n\n      var opposite = na.indexOf(cell);\n\n      if (opposite < 0) {\n        continue;\n      }\n\n      na[opposite] = ncell;\n      vadj[indexOfN] = neighbor; //Connect to cell\n\n      vverts[i] = -1;\n      vadj[i] = cell;\n      cellAdj[i] = ncell; //Flip facet\n\n      ncell.flip(); //Add to glue list\n\n      for (var j = 0; j <= d; ++j) {\n        var uu = vverts[j];\n\n        if (uu < 0 || uu === n) {\n          continue;\n        }\n\n        var nface = new Array(d - 1);\n        var nptr = 0;\n\n        for (var k = 0; k <= d; ++k) {\n          var vv = vverts[k];\n\n          if (vv < 0 || k === j) {\n            continue;\n          }\n\n          nface[nptr++] = vv;\n        }\n\n        glueFacets.push(new GlueFacet(nface, ncell, j));\n      }\n    }\n  } //Glue boundary facets together\n\n\n  glueFacets.sort(compareGlue);\n\n  for (var i = 0; i + 1 < glueFacets.length; i += 2) {\n    var a = glueFacets[i];\n    var b = glueFacets[i + 1];\n    var ai = a.index;\n    var bi = b.index;\n\n    if (ai < 0 || bi < 0) {\n      continue;\n    }\n\n    a.cell.adjacent[a.index] = b.cell;\n    b.cell.adjacent[b.index] = a.cell;\n  }\n};\n\nproto.insert = function (point, random) {\n  //Add point\n  var verts = this.vertices;\n  verts.push(point);\n  var cell = this.walk(point, random);\n\n  if (!cell) {\n    return;\n  } //Alias local properties\n\n\n  var d = this.dimension;\n  var tuple = this.tuple; //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n\n  for (var i = 0; i <= d; ++i) {\n    var vv = cell.vertices[i];\n\n    if (vv < 0) {\n      tuple[i] = point;\n    } else {\n      tuple[i] = verts[vv];\n    }\n  }\n\n  var o = this.orient(tuple);\n\n  if (o < 0) {\n    return;\n  } else if (o === 0) {\n    cell = this.handleBoundaryDegeneracy(cell, point);\n\n    if (!cell) {\n      return;\n    }\n  } //Add peaks\n\n\n  this.addPeaks(point, cell);\n}; //Extract all boundary cells\n\n\nproto.boundary = function () {\n  var d = this.dimension;\n  var boundary = [];\n  var cells = this.simplices;\n  var nc = cells.length;\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    if (c.boundary) {\n      var bcell = new Array(d);\n      var cv = c.vertices;\n      var ptr = 0;\n      var parity = 0;\n\n      for (var j = 0; j <= d; ++j) {\n        if (cv[j] >= 0) {\n          bcell[ptr++] = cv[j];\n        } else {\n          parity = j & 1;\n        }\n      }\n\n      if (parity === (d & 1)) {\n        var t = bcell[0];\n        bcell[0] = bcell[1];\n        bcell[1] = t;\n      }\n\n      boundary.push(bcell);\n    }\n  }\n\n  return boundary;\n};\n\nfunction incrementalConvexHull(points, randomSearch) {\n  var n = points.length;\n\n  if (n === 0) {\n    throw new Error(\"Must have at least d+1 points\");\n  }\n\n  var d = points[0].length;\n\n  if (n <= d) {\n    throw new Error(\"Must input at least d+1 points\");\n  } //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n\n\n  var initialSimplex = points.slice(0, d + 1); //Make sure initial simplex is positively oriented\n\n  var o = orient.apply(void 0, initialSimplex);\n\n  if (o === 0) {\n    throw new Error(\"Input not in general position\");\n  }\n\n  var initialCoords = new Array(d + 1);\n\n  for (var i = 0; i <= d; ++i) {\n    initialCoords[i] = i;\n  }\n\n  if (o < 0) {\n    initialCoords[0] = 1;\n    initialCoords[1] = 0;\n  } //Create initial topological index, glue pointers together (kind of messy)\n\n\n  var initialCell = new Simplex(initialCoords, new Array(d + 1), false);\n  var boundary = initialCell.adjacent;\n  var list = new Array(d + 2);\n\n  for (var i = 0; i <= d; ++i) {\n    var verts = initialCoords.slice();\n\n    for (var j = 0; j <= d; ++j) {\n      if (j === i) {\n        verts[j] = -1;\n      }\n    }\n\n    var t = verts[0];\n    verts[0] = verts[1];\n    verts[1] = t;\n    var cell = new Simplex(verts, new Array(d + 1), true);\n    boundary[i] = cell;\n    list[i] = cell;\n  }\n\n  list[d + 1] = initialCell;\n\n  for (var i = 0; i <= d; ++i) {\n    var verts = boundary[i].vertices;\n    var adj = boundary[i].adjacent;\n\n    for (var j = 0; j <= d; ++j) {\n      var v = verts[j];\n\n      if (v < 0) {\n        adj[j] = initialCell;\n        continue;\n      }\n\n      for (var k = 0; k <= d; ++k) {\n        if (boundary[k].vertices.indexOf(v) < 0) {\n          adj[j] = boundary[k];\n        }\n      }\n    }\n  } //Initialize triangles\n\n\n  var triangles = new Triangulation(d, initialSimplex, list); //Insert remaining points\n\n  var useRandom = !!randomSearch;\n\n  for (var i = d + 1; i < n; ++i) {\n    triangles.insert(points[i], useRandom);\n  } //Extract boundary cells\n\n\n  return triangles.boundary();\n}","map":null,"metadata":{},"sourceType":"script"}