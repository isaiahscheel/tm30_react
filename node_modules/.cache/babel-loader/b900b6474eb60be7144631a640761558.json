{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar carpetAttrs = require('./attributes');\n\nvar addOpacity = require('../../components/color').addOpacity;\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar handleTickValueDefaults = require('../../plots/cartesian/tick_value_defaults');\n\nvar handleTickLabelDefaults = require('../../plots/cartesian/tick_label_defaults');\n\nvar handleCategoryOrderDefaults = require('../../plots/cartesian/category_order_defaults');\n\nvar setConvert = require('../../plots/cartesian/set_convert');\n\nvar autoType = require('../../plots/cartesian/axis_autotype');\n/**\n * options: object containing:\n *\n *  letter: 'a' or 'b'\n *  title: name of the axis (ie 'Colorbar') to go in default title\n *  name: axis object name (ie 'xaxis') if one should be stored\n *  font: the default font to inherit\n *  outerTicks: boolean, should ticks default to outside?\n *  showGrid: boolean, should gridlines be shown by default?\n *  data: the plot data to use in choosing auto type\n *  bgColor: the plot background color, to calculate default gridline colors\n */\n\n\nmodule.exports = function handleAxisDefaults(containerIn, containerOut, options) {\n  var letter = options.letter;\n  var font = options.font || {};\n  var attributes = carpetAttrs[letter + 'axis'];\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);\n  }\n\n  function coerce2(attr, dflt) {\n    return Lib.coerce2(containerIn, containerOut, attributes, attr, dflt);\n  } // set up some private properties\n\n\n  if (options.name) {\n    containerOut._name = options.name;\n    containerOut._id = options.name;\n  } // now figure out type and do some more initialization\n\n\n  var axType = coerce('type');\n\n  if (axType === '-') {\n    if (options.data) setAutoType(containerOut, options.data);\n\n    if (containerOut.type === '-') {\n      containerOut.type = 'linear';\n    } else {\n      // copy autoType back to input axis\n      // note that if this object didn't exist\n      // in the input layout, we have to put it in\n      // this happens in the main supplyDefaults function\n      axType = containerIn.type = containerOut.type;\n    }\n  }\n\n  coerce('smoothing');\n  coerce('cheatertype');\n  coerce('showticklabels');\n  coerce('labelprefix', letter + ' = ');\n  coerce('labelsuffix');\n  coerce('showtickprefix');\n  coerce('showticksuffix');\n  coerce('separatethousands');\n  coerce('tickformat');\n  coerce('exponentformat');\n  coerce('showexponent');\n  coerce('categoryorder');\n  coerce('tickmode');\n  coerce('tickvals');\n  coerce('ticktext');\n  coerce('tick0');\n  coerce('dtick');\n\n  if (containerOut.tickmode === 'array') {\n    coerce('arraytick0');\n    coerce('arraydtick');\n  }\n\n  coerce('labelpadding');\n  containerOut._hovertitle = letter;\n\n  if (axType === 'date') {\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n    handleCalendarDefaults(containerIn, containerOut, 'calendar', options.calendar);\n  } // we need some of the other functions setConvert attaches, but for\n  // path finding, override pixel scaling to simple passthrough (identity)\n\n\n  setConvert(containerOut, options.fullLayout);\n  containerOut.c2p = Lib.identity;\n  var dfltColor = coerce('color', options.dfltColor); // if axis.color was provided, use it for fonts too; otherwise,\n  // inherit from global font color in case that was provided.\n\n  var dfltFontColor = dfltColor === containerIn.color ? dfltColor : font.color;\n  var title = coerce('title.text');\n\n  if (title) {\n    Lib.coerceFont(coerce, 'title.font', {\n      family: font.family,\n      size: Math.round(font.size * 1.2),\n      color: dfltFontColor\n    });\n    coerce('title.offset');\n  }\n\n  coerce('tickangle');\n  var autoRange = coerce('autorange', !containerOut.isValidRange(containerIn.range));\n  if (autoRange) coerce('rangemode');\n  coerce('range');\n  containerOut.cleanRange();\n  coerce('fixedrange');\n  handleTickValueDefaults(containerIn, containerOut, coerce, axType);\n  handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);\n  handleCategoryOrderDefaults(containerIn, containerOut, coerce, {\n    data: options.data,\n    dataAttr: letter\n  });\n  var gridColor = coerce2('gridcolor', addOpacity(dfltColor, 0.3));\n  var gridWidth = coerce2('gridwidth');\n  var showGrid = coerce('showgrid');\n\n  if (!showGrid) {\n    delete containerOut.gridcolor;\n    delete containerOut.gridwidth;\n  }\n\n  var startLineColor = coerce2('startlinecolor', dfltColor);\n  var startLineWidth = coerce2('startlinewidth', gridWidth);\n  var showStartLine = coerce('startline', containerOut.showgrid || !!startLineColor || !!startLineWidth);\n\n  if (!showStartLine) {\n    delete containerOut.startlinecolor;\n    delete containerOut.startlinewidth;\n  }\n\n  var endLineColor = coerce2('endlinecolor', dfltColor);\n  var endLineWidth = coerce2('endlinewidth', gridWidth);\n  var showEndLine = coerce('endline', containerOut.showgrid || !!endLineColor || !!endLineWidth);\n\n  if (!showEndLine) {\n    delete containerOut.endlinecolor;\n    delete containerOut.endlinewidth;\n  }\n\n  if (!showGrid) {\n    delete containerOut.gridcolor;\n    delete containerOut.gridWidth;\n  } else {\n    coerce('minorgridcount');\n    coerce('minorgridwidth', gridWidth);\n    coerce('minorgridcolor', addOpacity(gridColor, 0.06));\n\n    if (!containerOut.minorgridcount) {\n      delete containerOut.minorgridwidth;\n      delete containerOut.minorgridcolor;\n    }\n  }\n\n  if (containerOut.showticklabels === 'none') {\n    delete containerOut.tickfont;\n    delete containerOut.tickangle;\n    delete containerOut.showexponent;\n    delete containerOut.exponentformat;\n    delete containerOut.tickformat;\n    delete containerOut.showticksuffix;\n    delete containerOut.showtickprefix;\n  }\n\n  if (!containerOut.showticksuffix) {\n    delete containerOut.ticksuffix;\n  }\n\n  if (!containerOut.showtickprefix) {\n    delete containerOut.tickprefix;\n  } // It needs to be coerced, then something above overrides this deep in the axis code,\n  // but no, we *actually* want to coerce this.\n\n\n  coerce('tickmode');\n  return containerOut;\n};\n\nfunction setAutoType(ax, data) {\n  // new logic: let people specify any type they want,\n  // only autotype if type is '-'\n  if (ax.type !== '-') return;\n  var id = ax._id;\n  var axLetter = id.charAt(0);\n  var calAttr = axLetter + 'calendar';\n  var calendar = ax[calAttr];\n  ax.type = autoType(data, calendar);\n}","map":null,"metadata":{},"sourceType":"script"}