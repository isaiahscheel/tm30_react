{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar cluster = require('point-cluster');\n\nvar Lib = require('../../lib');\n\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\n\nvar scatterCalc = require('../scatter/calc');\n\nvar calcMarkerSize = scatterCalc.calcMarkerSize;\nvar calcAxisExpansion = scatterCalc.calcAxisExpansion;\nvar setFirstScatter = scatterCalc.setFirstScatter;\n\nvar calcColorscale = require('../scatter/colorscale_calc');\n\nvar convert = require('./convert');\n\nvar sceneUpdate = require('./scene_update');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar TOO_MANY_POINTS = require('./constants').TOO_MANY_POINTS;\n\nmodule.exports = function calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var xa = AxisIDs.getFromId(gd, trace.xaxis);\n  var ya = AxisIDs.getFromId(gd, trace.yaxis);\n  var subplot = fullLayout._plots[trace.xaxis + trace.yaxis];\n  var len = trace._length;\n  var hasTooManyPoints = len >= TOO_MANY_POINTS;\n  var len2 = len * 2;\n  var stash = {};\n  var i, xx, yy;\n  var x = xa.makeCalcdata(trace, 'x');\n  var y = ya.makeCalcdata(trace, 'y'); // we need hi-precision for scatter2d,\n  // regl-scatter2d uses NaNs for bad/missing values\n\n  var positions = new Array(len2);\n\n  for (i = 0; i < len; i++) {\n    xx = x[i];\n    yy = y[i];\n    positions[i * 2] = xx === BADNUM ? NaN : xx;\n    positions[i * 2 + 1] = yy === BADNUM ? NaN : yy;\n  }\n\n  if (xa.type === 'log') {\n    for (i = 0; i < len2; i += 2) {\n      positions[i] = xa.c2l(positions[i]);\n    }\n  }\n\n  if (ya.type === 'log') {\n    for (i = 1; i < len2; i += 2) {\n      positions[i] = ya.c2l(positions[i]);\n    }\n  } // we don't build a tree for log axes since it takes long to convert log2px\n  // and it is also\n\n\n  if (hasTooManyPoints && xa.type !== 'log' && ya.type !== 'log') {\n    // FIXME: delegate this to webworker\n    stash.tree = cluster(positions);\n  } else {\n    var ids = stash.ids = new Array(len);\n\n    for (i = 0; i < len; i++) {\n      ids[i] = i;\n    }\n  } // create scene options and scene\n\n\n  calcColorscale(gd, trace);\n  var opts = sceneOptions(gd, subplot, trace, positions, x, y);\n  var scene = sceneUpdate(gd, subplot); // Reuse SVG scatter axis expansion routine.\n  // For graphs with very large number of points and array marker.size,\n  // use average marker size instead to speed things up.\n\n  setFirstScatter(fullLayout, trace);\n  var ppad;\n\n  if (!hasTooManyPoints) {\n    ppad = calcMarkerSize(trace, len);\n  } else if (opts.marker) {\n    ppad = 2 * (opts.marker.sizeAvg || Math.max(opts.marker.size, 3));\n  }\n\n  calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n  if (opts.errorX) expandForErrorBars(trace, xa, opts.errorX);\n  if (opts.errorY) expandForErrorBars(trace, ya, opts.errorY); // set flags to create scene renderers\n\n  if (opts.fill && !scene.fill2d) scene.fill2d = true;\n  if (opts.marker && !scene.scatter2d) scene.scatter2d = true;\n  if (opts.line && !scene.line2d) scene.line2d = true;\n  if ((opts.errorX || opts.errorY) && !scene.error2d) scene.error2d = true;\n  if (opts.text && !scene.glText) scene.glText = true;\n  if (opts.marker) opts.marker.snap = len;\n  scene.lineOptions.push(opts.line);\n  scene.errorXOptions.push(opts.errorX);\n  scene.errorYOptions.push(opts.errorY);\n  scene.fillOptions.push(opts.fill);\n  scene.markerOptions.push(opts.marker);\n  scene.markerSelectedOptions.push(opts.markerSel);\n  scene.markerUnselectedOptions.push(opts.markerUnsel);\n  scene.textOptions.push(opts.text);\n  scene.textSelectedOptions.push(opts.textSel);\n  scene.textUnselectedOptions.push(opts.textUnsel);\n  scene.selectBatch.push([]);\n  scene.unselectBatch.push([]);\n  stash._scene = scene;\n  stash.index = scene.count;\n  stash.x = x;\n  stash.y = y;\n  stash.positions = positions;\n  scene.count++;\n  return [{\n    x: false,\n    y: false,\n    t: stash,\n    trace: trace\n  }];\n};\n\nfunction expandForErrorBars(trace, ax, opts) {\n  var extremes = trace._extremes[ax._id];\n  var errExt = findExtremes(ax, opts._bnds, {\n    padded: true\n  });\n  extremes.min = extremes.min.concat(errExt.min);\n  extremes.max = extremes.max.concat(errExt.max);\n}\n\nfunction sceneOptions(gd, subplot, trace, positions, x, y) {\n  var opts = convert.style(gd, trace);\n\n  if (opts.marker) {\n    opts.marker.positions = positions;\n  }\n\n  if (opts.line && positions.length > 1) {\n    Lib.extendFlat(opts.line, convert.linePositions(gd, trace, positions));\n  }\n\n  if (opts.errorX || opts.errorY) {\n    var errors = convert.errorBarPositions(gd, trace, positions, x, y);\n\n    if (opts.errorX) {\n      Lib.extendFlat(opts.errorX, errors.x);\n    }\n\n    if (opts.errorY) {\n      Lib.extendFlat(opts.errorY, errors.y);\n    }\n  }\n\n  if (opts.text) {\n    Lib.extendFlat(opts.text, {\n      positions: positions\n    }, convert.textPosition(gd, trace, opts.text, opts.marker));\n    Lib.extendFlat(opts.textSel, {\n      positions: positions\n    }, convert.textPosition(gd, trace, opts.text, opts.markerSel));\n    Lib.extendFlat(opts.textUnsel, {\n      positions: positions\n    }, convert.textPosition(gd, trace, opts.text, opts.markerUnsel));\n  }\n\n  return opts;\n}","map":null,"metadata":{},"sourceType":"script"}