{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict'; // Requirements\n// ============\n\nvar wrap = require('../../lib/gup').wrap;\n\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\n\nvar colorscaleCalc = require('../../components/colorscale/calc');\n\nvar filterUnique = require('../../lib/filter_unique.js');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\n\n\nmodule.exports = function calc(gd, trace) {\n  var visibleDims = Lib.filterVisible(trace.dimensions);\n  if (visibleDims.length === 0) return [];\n  var uniqueInfoDims = visibleDims.map(function (dim) {\n    var categoryValues;\n\n    if (dim.categoryorder === 'trace') {\n      // Use order of first occurrence in trace\n      categoryValues = null;\n    } else if (dim.categoryorder === 'array') {\n      // Use categories specified in `categoryarray` first,\n      // then add extra to the end in trace order\n      categoryValues = dim.categoryarray;\n    } else {\n      // Get all categories up front so we can order them\n      // Should we check for numbers as sort numerically?\n      categoryValues = filterUnique(dim.values).sort();\n\n      if (dim.categoryorder === 'category descending') {\n        categoryValues = categoryValues.reverse();\n      }\n    }\n\n    return getUniqueInfo(dim.values, categoryValues);\n  });\n  var counts, count, totalCount;\n\n  if (Lib.isArrayOrTypedArray(trace.counts)) {\n    counts = trace.counts;\n  } else {\n    counts = [trace.counts];\n  }\n\n  validateDimensionDisplayInds(visibleDims);\n  visibleDims.forEach(function (dim, dimInd) {\n    validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n  }); // Handle path colors\n  // ------------------\n\n  var line = trace.line;\n  var markerColorscale; // Process colorscale\n\n  if (line) {\n    if (hasColorscale(trace, 'line')) {\n      colorscaleCalc(gd, trace, {\n        vals: trace.line.color,\n        containerStr: 'line',\n        cLetter: 'c'\n      });\n    }\n\n    markerColorscale = Drawing.tryColorscale(line);\n  } else {\n    markerColorscale = Lib.identity;\n  } // Build color generation function\n\n\n  function getMarkerColorInfo(index) {\n    var value, rawColor;\n\n    if (Lib.isArrayOrTypedArray(line.color)) {\n      value = line.color[index % line.color.length];\n      rawColor = value;\n    } else {\n      value = line.color;\n    }\n\n    return {\n      color: markerColorscale(value),\n      rawColor: rawColor\n    };\n  } // Number of values and counts\n  // ---------------------------\n\n\n  var numValues = visibleDims[0].values.length; // Build path info\n  // ---------------\n  // Mapping from category inds to PathModel objects\n\n  var pathModels = {}; // Category inds array for each dimension\n\n  var categoryIndsDims = uniqueInfoDims.map(function (di) {\n    return di.inds;\n  }); // Initialize total count\n\n  totalCount = 0;\n  var valueInd;\n  var d;\n\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    // Category inds for this input value across dimensions\n    var categoryIndsPath = [];\n\n    for (d = 0; d < categoryIndsDims.length; d++) {\n      categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n    } // Count\n\n\n    count = counts[valueInd % counts.length]; // Update total count\n\n    totalCount += count; // Path color\n\n    var pathColorInfo = getMarkerColorInfo(valueInd); // path key\n\n    var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor; // Create / Update PathModel\n\n    if (pathModels[pathKey] === undefined) {\n      pathModels[pathKey] = createPathModel(categoryIndsPath, pathColorInfo.color, pathColorInfo.rawColor);\n    }\n\n    updatePathModel(pathModels[pathKey], valueInd, count);\n  }\n\n  var dimensionModels = visibleDims.map(function (di, i) {\n    return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n  });\n\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    count = counts[valueInd % counts.length];\n\n    for (d = 0; d < dimensionModels.length; d++) {\n      var containerInd = dimensionModels[d].containerInd;\n      var catInd = uniqueInfoDims[d].inds[valueInd];\n      var cats = dimensionModels[d].categories;\n\n      if (cats[catInd] === undefined) {\n        var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n        var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n        cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n      }\n\n      updateCategoryModel(cats[catInd], valueInd, count);\n    }\n  } // Compute unique\n\n\n  return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n}; // Models\n// ======\n// Parcats Model\n// -------------\n\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\n\n\nfunction createParcatsModel(dimensions, paths, count) {\n  var maxCats = dimensions.map(function (d) {\n    return d.categories.length;\n  }).reduce(function (v1, v2) {\n    return Math.max(v1, v2);\n  });\n  return {\n    dimensions: dimensions,\n    paths: paths,\n    trace: undefined,\n    maxCats: maxCats,\n    count: count\n  };\n} // Dimension Model\n// ---------------\n\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\n\n\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n  return {\n    dimensionInd: dimensionInd,\n    containerInd: containerInd,\n    displayInd: displayInd,\n    dimensionLabel: dimensionLabel,\n    count: count,\n    categories: [],\n    dragX: null\n  };\n} // Category Model\n// --------------\n\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\n\n\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n  return {\n    dimensionInd: dimensionInd,\n    categoryInd: categoryInd,\n    categoryValue: categoryValue,\n    displayInd: categoryInd,\n    categoryLabel: categoryLabel,\n    valueInds: [],\n    count: 0,\n    dragY: null\n  };\n}\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\n\n\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n  categoryModel.valueInds.push(valueInd);\n  categoryModel.count += count;\n} // Path Model\n// ----------\n\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\n\n\nfunction createPathModel(categoryInds, color, rawColor) {\n  return {\n    categoryInds: categoryInds,\n    color: color,\n    rawColor: rawColor,\n    valueInds: [],\n    count: 0\n  };\n}\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\n\n\nfunction updatePathModel(pathModel, valueInd, count) {\n  pathModel.valueInds.push(valueInd);\n  pathModel.count += count;\n} // Unique calculations\n// ===================\n\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\n\n\nfunction getUniqueInfo(values, uniqueValues) {\n  // Initialize uniqueValues if not specified\n  if (uniqueValues === undefined || uniqueValues === null) {\n    uniqueValues = [];\n  } else {\n    // Shallow copy so append below doesn't alter input array\n    uniqueValues = uniqueValues.map(function (e) {\n      return e;\n    });\n  } // Initialize Variables\n\n\n  var uniqueValueCounts = {};\n  var uniqueValueInds = {};\n  var inds = []; // Initialize uniqueValueCounts and\n\n  uniqueValues.forEach(function (uniqueVal, valInd) {\n    uniqueValueCounts[uniqueVal] = 0;\n    uniqueValueInds[uniqueVal] = valInd;\n  }); // Compute the necessary unique info in a single pass\n\n  for (var i = 0; i < values.length; i++) {\n    var item = values[i];\n    var itemInd;\n\n    if (uniqueValueCounts[item] === undefined) {\n      // This item has a previously unseen value\n      uniqueValueCounts[item] = 1;\n      itemInd = uniqueValues.push(item) - 1;\n      uniqueValueInds[item] = itemInd;\n    } else {\n      // Increment count for this item\n      uniqueValueCounts[item]++;\n      itemInd = uniqueValueInds[item];\n    }\n\n    inds.push(itemInd);\n  } // Build UniqueInfo\n\n\n  var uniqueCounts = uniqueValues.map(function (v) {\n    return uniqueValueCounts[v];\n  });\n  return {\n    uniqueValues: uniqueValues,\n    uniqueCounts: uniqueCounts,\n    inds: inds\n  };\n}\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\n\n\nfunction validateDimensionDisplayInds(visibleDims) {\n  var displayInds = visibleDims.map(function (d) {\n    return d.displayindex;\n  });\n  var i;\n\n  if (isRangePermutation(displayInds)) {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = visibleDims[i].displayindex;\n    }\n  } else {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = i;\n    }\n  }\n}\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\n\n\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n  // Update categoryarray\n  dim._categoryarray = uniqueInfoDim.uniqueValues; // Handle ticktext\n\n  if (dim.ticktext === null || dim.ticktext === undefined) {\n    dim._ticktext = [];\n  } else {\n    // Shallow copy to avoid modifying input array\n    dim._ticktext = dim.ticktext.slice();\n  } // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n\n\n  for (var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n    dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n  }\n}\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\n\n\nfunction isRangePermutation(inds) {\n  var indsSpecified = new Array(inds.length);\n\n  for (var i = 0; i < inds.length; i++) {\n    // Check for out of bounds\n    if (inds[i] < 0 || inds[i] >= inds.length) {\n      return false;\n    } // Check for collisions with already specified index\n\n\n    if (indsSpecified[inds[i]] !== undefined) {\n      return false;\n    }\n\n    indsSpecified[inds[i]] = true;\n  } // Nothing out of bounds and no collisions. We have a permutation\n\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"script"}