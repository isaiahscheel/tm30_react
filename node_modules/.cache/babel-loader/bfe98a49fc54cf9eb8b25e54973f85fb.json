{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar cluster = require('point-cluster');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar scatterglPlot = require('../scattergl/plot');\n\nvar sceneUpdate = require('../scattergl/scene_update');\n\nvar convert = require('../scattergl/convert');\n\nvar Lib = require('../../lib');\n\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\n\nmodule.exports = function plot(gd, subplot, cdata) {\n  if (!cdata.length) return;\n  var radialAxis = subplot.radialAxis;\n  var angularAxis = subplot.angularAxis;\n  var scene = sceneUpdate(gd, subplot);\n  cdata.forEach(function (cdscatter) {\n    if (!cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n    var cd = cdscatter[0];\n    var trace = cd.trace;\n    var stash = cd.t;\n    var len = trace._length;\n    var rArray = stash.r;\n    var thetaArray = stash.theta;\n    var opts = stash.opts;\n    var i;\n    var subRArray = rArray.slice();\n    var subThetaArray = thetaArray.slice(); // filter out by range\n\n    for (i = 0; i < rArray.length; i++) {\n      if (!subplot.isPtInside({\n        r: rArray[i],\n        theta: thetaArray[i]\n      })) {\n        subRArray[i] = NaN;\n        subThetaArray[i] = NaN;\n      }\n    }\n\n    var positions = new Array(len * 2);\n    var x = Array(len);\n    var y = Array(len);\n\n    for (i = 0; i < len; i++) {\n      var r = subRArray[i];\n      var xx, yy;\n\n      if (isNumeric(r)) {\n        var rg = radialAxis.c2g(r);\n        var thetag = angularAxis.c2g(subThetaArray[i], trace.thetaunit);\n        xx = rg * Math.cos(thetag);\n        yy = rg * Math.sin(thetag);\n      } else {\n        xx = yy = NaN;\n      }\n\n      x[i] = positions[i * 2] = xx;\n      y[i] = positions[i * 2 + 1] = yy;\n    }\n\n    stash.tree = cluster(positions); // FIXME: see scattergl.js#109\n\n    if (opts.marker && len >= TOO_MANY_POINTS) {\n      opts.marker.cluster = stash.tree;\n    }\n\n    if (opts.marker) {\n      opts.markerSel.positions = opts.markerUnsel.positions = opts.marker.positions = positions;\n    }\n\n    if (opts.line && positions.length > 1) {\n      Lib.extendFlat(opts.line, convert.linePositions(gd, trace, positions));\n    }\n\n    if (opts.text) {\n      Lib.extendFlat(opts.text, {\n        positions: positions\n      }, convert.textPosition(gd, trace, opts.text, opts.marker));\n      Lib.extendFlat(opts.textSel, {\n        positions: positions\n      }, convert.textPosition(gd, trace, opts.text, opts.markerSel));\n      Lib.extendFlat(opts.textUnsel, {\n        positions: positions\n      }, convert.textPosition(gd, trace, opts.text, opts.markerUnsel));\n    }\n\n    if (opts.fill && !scene.fill2d) scene.fill2d = true;\n    if (opts.marker && !scene.scatter2d) scene.scatter2d = true;\n    if (opts.line && !scene.line2d) scene.line2d = true;\n    if (opts.text && !scene.glText) scene.glText = true;\n    scene.lineOptions.push(opts.line);\n    scene.fillOptions.push(opts.fill);\n    scene.markerOptions.push(opts.marker);\n    scene.markerSelectedOptions.push(opts.markerSel);\n    scene.markerUnselectedOptions.push(opts.markerUnsel);\n    scene.textOptions.push(opts.text);\n    scene.textSelectedOptions.push(opts.textSel);\n    scene.textUnselectedOptions.push(opts.textUnsel);\n    scene.selectBatch.push([]);\n    scene.unselectBatch.push([]);\n    stash.x = x;\n    stash.y = y;\n    stash.rawx = x;\n    stash.rawy = y;\n    stash.r = rArray;\n    stash.theta = thetaArray;\n    stash.positions = positions;\n    stash._scene = scene;\n    stash.index = scene.count;\n    scene.count++;\n  });\n  return scatterglPlot(gd, subplot, cdata);\n};","map":null,"metadata":{},"sourceType":"script"}