{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar parcoords = require('./parcoords');\n\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar isVisible = require('./helpers').isVisible;\n\nfunction newIndex(visibleIndices, orig, dim) {\n  var origIndex = orig.indexOf(dim);\n  var currentIndex = visibleIndices.indexOf(origIndex);\n\n  if (currentIndex === -1) {\n    // invisible dimensions initially go to the end\n    currentIndex += orig.length;\n  }\n\n  return currentIndex;\n}\n\nfunction sorter(visibleIndices, orig) {\n  return function sorter(d1, d2) {\n    return newIndex(visibleIndices, orig, d1) - newIndex(visibleIndices, orig, d2);\n  };\n}\n\nmodule.exports = function plot(gd, cdModule) {\n  var fullLayout = gd._fullLayout;\n  var success = prepareRegl(gd);\n  if (!success) return;\n  var currentDims = {};\n  var initialDims = {};\n  var fullIndices = {};\n  var inputIndices = {};\n  var size = fullLayout._size;\n  cdModule.forEach(function (d, i) {\n    var trace = d[0].trace;\n    fullIndices[i] = trace.index;\n    var iIn = inputIndices[i] = trace._fullInput.index;\n    currentDims[i] = gd.data[iIn].dimensions;\n    initialDims[i] = gd.data[iIn].dimensions.slice();\n  });\n\n  var filterChanged = function (i, initialDimIndex, newRanges) {\n    // Have updated `constraintrange` data on `gd.data` and raise `Plotly.restyle` event\n    // without having to incur heavy UI blocking due to an actual `Plotly.restyle` call\n    var dim = initialDims[i][initialDimIndex];\n    var newConstraints = newRanges.map(function (r) {\n      return r.slice();\n    }); // Store constraint range in preGUI\n    // This one doesn't work if it's stored in pieces in _storeDirectGUIEdit\n    // because it's an array of variable dimensionality. So store the whole\n    // thing at once manually.\n\n    var aStr = 'dimensions[' + initialDimIndex + '].constraintrange';\n    var preGUI = fullLayout._tracePreGUI[gd._fullData[fullIndices[i]]._fullInput.uid];\n\n    if (preGUI[aStr] === undefined) {\n      var initialVal = dim.constraintrange;\n      preGUI[aStr] = initialVal || null;\n    }\n\n    var fullDimension = gd._fullData[fullIndices[i]].dimensions[initialDimIndex];\n\n    if (!newConstraints.length) {\n      delete dim.constraintrange;\n      delete fullDimension.constraintrange;\n      newConstraints = null;\n    } else {\n      if (newConstraints.length === 1) newConstraints = newConstraints[0];\n      dim.constraintrange = newConstraints;\n      fullDimension.constraintrange = newConstraints.slice(); // wrap in another array for restyle event data\n\n      newConstraints = [newConstraints];\n    }\n\n    var restyleData = {};\n    restyleData[aStr] = newConstraints;\n    gd.emit('plotly_restyle', [restyleData, [inputIndices[i]]]);\n  };\n\n  var hover = function (eventData) {\n    gd.emit('plotly_hover', eventData);\n  };\n\n  var unhover = function (eventData) {\n    gd.emit('plotly_unhover', eventData);\n  };\n\n  var axesMoved = function (i, visibleIndices) {\n    // Have updated order data on `gd.data` and raise `Plotly.restyle` event\n    // without having to incur heavy UI blocking due to an actual `Plotly.restyle` call\n    // drag&drop sorting of the visible dimensions\n    var orig = sorter(visibleIndices, initialDims[i].filter(isVisible));\n    currentDims[i].sort(orig); // invisible dimensions are not interpreted in the context of drag&drop sorting as an invisible dimension\n    // cannot be dragged; they're interspersed into their original positions by this subsequent merging step\n\n    initialDims[i].filter(function (d) {\n      return !isVisible(d);\n    }).sort(function (d) {\n      // subsequent splicing to be done left to right, otherwise indices may be incorrect\n      return initialDims[i].indexOf(d);\n    }).forEach(function (d) {\n      currentDims[i].splice(currentDims[i].indexOf(d), 1); // remove from the end\n\n      currentDims[i].splice(initialDims[i].indexOf(d), 0, d); // insert at original index\n    }); // TODO: we can't really store this part of the interaction state\n    // directly as below, since it incudes data arrays. If we want to\n    // persist column order we may have to do something special for this\n    // case to just store the order itself.\n    // Registry.call('_storeDirectGUIEdit',\n    //     gd.data[inputIndices[i]],\n    //     fullLayout._tracePreGUI[gd._fullData[fullIndices[i]]._fullInput.uid],\n    //     {dimensions: currentDims[i]}\n    // );\n\n    gd.emit('plotly_restyle', [{\n      dimensions: [currentDims[i]]\n    }, [inputIndices[i]]]);\n  };\n\n  parcoords(gd, cdModule, {\n    // layout\n    width: size.w,\n    height: size.h,\n    margin: {\n      t: size.t,\n      r: size.r,\n      b: size.b,\n      l: size.l\n    }\n  }, {\n    // callbacks\n    filterChanged: filterChanged,\n    hover: hover,\n    unhover: unhover,\n    axesMoved: axesMoved\n  });\n};","map":null,"metadata":{},"sourceType":"script"}