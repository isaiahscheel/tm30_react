{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar conePlot = require('gl-cone3d');\n\nvar createConeMesh = require('gl-cone3d').createConeMesh;\n\nvar simpleMap = require('../../lib').simpleMap;\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nvar zip3 = require('../../plots/gl3d/zip3');\n\nfunction Cone(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = null;\n  this.data = null;\n}\n\nvar proto = Cone.prototype;\n\nproto.handlePick = function (selection) {\n  if (selection.object === this.mesh) {\n    var selectIndex = selection.index = selection.data.index;\n    var xx = this.data.x[selectIndex];\n    var yy = this.data.y[selectIndex];\n    var zz = this.data.z[selectIndex];\n    var uu = this.data.u[selectIndex];\n    var vv = this.data.v[selectIndex];\n    var ww = this.data.w[selectIndex];\n    selection.traceCoordinate = [xx, yy, zz, uu, vv, ww, Math.sqrt(uu * uu + vv * vv + ww * ww)];\n    var text = this.data.hovertext || this.data.text;\n\n    if (Array.isArray(text) && text[selectIndex] !== undefined) {\n      selection.textLabel = text[selectIndex];\n    } else if (text) {\n      selection.textLabel = text;\n    }\n\n    return true;\n  }\n};\n\nvar axisName2scaleIndex = {\n  xaxis: 0,\n  yaxis: 1,\n  zaxis: 2\n};\nvar anchor2coneOffset = {\n  tip: 1,\n  tail: 0,\n  cm: 0.25,\n  center: 0.5\n};\nvar anchor2coneSpan = {\n  tip: 1,\n  tail: 1,\n  cm: 0.75,\n  center: 0.5\n};\n\nfunction convert(scene, trace) {\n  var sceneLayout = scene.fullSceneLayout;\n  var dataScale = scene.dataScale;\n  var coneOpts = {};\n\n  function toDataCoords(arr, axisName) {\n    var ax = sceneLayout[axisName];\n    var scale = dataScale[axisName2scaleIndex[axisName]];\n    return simpleMap(arr, function (v) {\n      return ax.d2l(v) * scale;\n    });\n  }\n\n  coneOpts.vectors = zip3(toDataCoords(trace.u, 'xaxis'), toDataCoords(trace.v, 'yaxis'), toDataCoords(trace.w, 'zaxis'), trace._len);\n  coneOpts.positions = zip3(toDataCoords(trace.x, 'xaxis'), toDataCoords(trace.y, 'yaxis'), toDataCoords(trace.z, 'zaxis'), trace._len);\n  var cOpts = extractOpts(trace);\n  coneOpts.colormap = parseColorScale(trace);\n  coneOpts.vertexIntensityBounds = [cOpts.min / trace._normMax, cOpts.max / trace._normMax];\n  coneOpts.coneOffset = anchor2coneOffset[trace.anchor];\n\n  if (trace.sizemode === 'scaled') {\n    // unitless sizeref\n    coneOpts.coneSize = trace.sizeref || 0.5;\n  } else {\n    // sizeref here has unit of velocity\n    coneOpts.coneSize = trace.sizeref && trace._normMax ? trace.sizeref / trace._normMax : 0.5;\n  }\n\n  var meshData = conePlot(coneOpts); // pass gl-mesh3d lighting attributes\n\n  var lp = trace.lightposition;\n  meshData.lightPosition = [lp.x, lp.y, lp.z];\n  meshData.ambient = trace.lighting.ambient;\n  meshData.diffuse = trace.lighting.diffuse;\n  meshData.specular = trace.lighting.specular;\n  meshData.roughness = trace.lighting.roughness;\n  meshData.fresnel = trace.lighting.fresnel;\n  meshData.opacity = trace.opacity; // stash autorange pad value\n\n  trace._pad = anchor2coneSpan[trace.anchor] * meshData.vectorScale * meshData.coneScale * trace._normMax;\n  return meshData;\n}\n\nproto.update = function (data) {\n  this.data = data;\n  var meshData = convert(this.scene, data);\n  this.mesh.update(meshData);\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\n\nfunction createConeTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var meshData = convert(scene, data);\n  var mesh = createConeMesh(gl, meshData);\n  var cone = new Cone(scene, data.uid);\n  cone.mesh = mesh;\n  cone.data = data;\n  mesh._trace = cone;\n  scene.glplot.add(mesh);\n  return cone;\n}\n\nmodule.exports = createConeTrace;","map":null,"metadata":{},"sourceType":"script"}