{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plots = require('../../plots/plots');\n\nvar Fx = require('../../components/fx');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar helpers = require('./helpers');\n\nvar eventData = require('./event_data');\n\nvar isValidTextValue = require('../../lib').isValidTextValue;\n\nfunction plot(gd, cdModule) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  prerenderTitles(cdModule, gd);\n  layoutAreas(cdModule, gs);\n  var plotGroups = Lib.makeTraceGroups(fullLayout._pielayer, cdModule, 'trace').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    setCoords(cd); // TODO: miter might look better but can sometimes cause problems\n    // maybe miter with a small-ish stroke-miterlimit?\n\n    plotGroup.attr('stroke-linejoin', 'round');\n    plotGroup.each(function () {\n      var slices = d3.select(this).selectAll('g.slice').data(cd);\n      slices.enter().append('g').classed('slice', true);\n      slices.exit().remove();\n      var quadrants = [[[], []], // y<0: x<0, x>=0\n      [[], []] // y>=0: x<0, x>=0\n      ];\n      var hasOutsideText = false;\n      slices.each(function (pt) {\n        if (pt.hidden) {\n          d3.select(this).selectAll('path,g').remove();\n          return;\n        } // to have consistent event data compared to other traces\n\n\n        pt.pointNumber = pt.i;\n        pt.curveNumber = trace.index;\n        quadrants[pt.pxmid[1] < 0 ? 0 : 1][pt.pxmid[0] < 0 ? 0 : 1].push(pt);\n        var cx = cd0.cx;\n        var cy = cd0.cy;\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.selectAll('path.surface').data([pt]);\n        slicePath.enter().append('path').classed('surface', true).style({\n          'pointer-events': 'all'\n        });\n        sliceTop.call(attachFxHandlers, gd, cd);\n\n        if (trace.pull) {\n          var pull = +helpers.castOption(trace.pull, pt.pts) || 0;\n\n          if (pull > 0) {\n            cx += pull * pt.pxmid[0];\n            cy += pull * pt.pxmid[1];\n          }\n        }\n\n        pt.cxFinal = cx;\n        pt.cyFinal = cy;\n\n        function arc(start, finish, cw, scale) {\n          var dx = scale * (finish[0] - start[0]);\n          var dy = scale * (finish[1] - start[1]);\n          return 'a' + scale * cd0.r + ',' + scale * cd0.r + ' 0 ' + pt.largeArc + (cw ? ' 1 ' : ' 0 ') + dx + ',' + dy;\n        }\n\n        var hole = trace.hole;\n\n        if (pt.v === cd0.vTotal) {\n          // 100% fails bcs arc start and end are identical\n          var outerCircle = 'M' + (cx + pt.px0[0]) + ',' + (cy + pt.px0[1]) + arc(pt.px0, pt.pxmid, true, 1) + arc(pt.pxmid, pt.px0, true, 1) + 'Z';\n\n          if (hole) {\n            slicePath.attr('d', 'M' + (cx + hole * pt.px0[0]) + ',' + (cy + hole * pt.px0[1]) + arc(pt.px0, pt.pxmid, false, hole) + arc(pt.pxmid, pt.px0, false, hole) + 'Z' + outerCircle);\n          } else slicePath.attr('d', outerCircle);\n        } else {\n          var outerArc = arc(pt.px0, pt.px1, true, 1);\n\n          if (hole) {\n            var rim = 1 - hole;\n            slicePath.attr('d', 'M' + (cx + hole * pt.px1[0]) + ',' + (cy + hole * pt.px1[1]) + arc(pt.px1, pt.px0, false, hole) + 'l' + rim * pt.px0[0] + ',' + rim * pt.px0[1] + outerArc + 'Z');\n          } else {\n            slicePath.attr('d', 'M' + cx + ',' + cy + 'l' + pt.px0[0] + ',' + pt.px0[1] + outerArc + 'Z');\n          }\n        } // add text\n\n\n        formatSliceLabel(gd, pt, cd0);\n        var textPosition = helpers.castOption(trace.textposition, pt.pts);\n        var sliceTextGroup = sliceTop.selectAll('g.slicetext').data(pt.text && textPosition !== 'none' ? [0] : []);\n        sliceTextGroup.enter().append('g').classed('slicetext', true);\n        sliceTextGroup.exit().remove();\n        sliceTextGroup.each(function () {\n          var sliceText = Lib.ensureSingle(d3.select(this), 'text', '', function (s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n          });\n          sliceText.text(pt.text).attr({\n            'class': 'slicetext',\n            transform: '',\n            'text-anchor': 'middle'\n          }).call(Drawing.font, textPosition === 'outside' ? determineOutsideTextFont(trace, pt, gd._fullLayout.font) : determineInsideTextFont(trace, pt, gd._fullLayout.font)).call(svgTextUtils.convertToTspans, gd); // position the text relative to the slice\n\n          var textBB = Drawing.bBox(sliceText.node());\n          var transform;\n\n          if (textPosition === 'outside') {\n            transform = transformOutsideText(textBB, pt);\n          } else {\n            transform = transformInsideText(textBB, pt, cd0);\n\n            if (textPosition === 'auto' && transform.scale < 1) {\n              sliceText.call(Drawing.font, trace.outsidetextfont);\n\n              if (trace.outsidetextfont.family !== trace.insidetextfont.family || trace.outsidetextfont.size !== trace.insidetextfont.size) {\n                textBB = Drawing.bBox(sliceText.node());\n              }\n\n              transform = transformOutsideText(textBB, pt);\n            }\n          }\n\n          var translateX = cx + pt.pxmid[0] * transform.rCenter + (transform.x || 0);\n          var translateY = cy + pt.pxmid[1] * transform.rCenter + (transform.y || 0); // save some stuff to use later ensure no labels overlap\n\n          if (transform.outside) {\n            pt.yLabelMin = translateY - textBB.height / 2;\n            pt.yLabelMid = translateY;\n            pt.yLabelMax = translateY + textBB.height / 2;\n            pt.labelExtraX = 0;\n            pt.labelExtraY = 0;\n            hasOutsideText = true;\n          }\n\n          sliceText.attr('transform', 'translate(' + translateX + ',' + translateY + ')' + (transform.scale < 1 ? 'scale(' + transform.scale + ')' : '') + (transform.rotate ? 'rotate(' + transform.rotate + ')' : '') + 'translate(' + -(textBB.left + textBB.right) / 2 + ',' + -(textBB.top + textBB.bottom) / 2 + ')');\n        });\n      }); // add the title\n\n      var titleTextGroup = d3.select(this).selectAll('g.titletext').data(trace.title.text ? [0] : []);\n      titleTextGroup.enter().append('g').classed('titletext', true);\n      titleTextGroup.exit().remove();\n      titleTextGroup.each(function () {\n        var titleText = Lib.ensureSingle(d3.select(this), 'text', '', function (s) {\n          // prohibit tex interpretation as above\n          s.attr('data-notex', 1);\n        });\n        var txt = trace.title.text;\n\n        if (trace._meta) {\n          txt = Lib.templateString(txt, trace._meta);\n        }\n\n        titleText.text(txt).attr({\n          'class': 'titletext',\n          transform: '',\n          'text-anchor': 'middle'\n        }).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);\n        var transform;\n\n        if (trace.title.position === 'middle center') {\n          transform = positionTitleInside(cd0);\n        } else {\n          transform = positionTitleOutside(cd0, gs);\n        }\n\n        titleText.attr('transform', 'translate(' + transform.x + ',' + transform.y + ')' + (transform.scale < 1 ? 'scale(' + transform.scale + ')' : '') + 'translate(' + transform.tx + ',' + transform.ty + ')');\n      }); // now make sure no labels overlap (at least within one pie)\n\n      if (hasOutsideText) scootLabels(quadrants, trace);\n      plotTextLines(slices, trace);\n\n      if (hasOutsideText && trace.automargin) {\n        // TODO if we ever want to improve perf,\n        // we could reuse the textBB computed above together\n        // with the sliceText transform info\n        var traceBbox = Drawing.bBox(plotGroup.node());\n        var domain = trace.domain;\n        var vpw = gs.w * (domain.x[1] - domain.x[0]);\n        var vph = gs.h * (domain.y[1] - domain.y[0]);\n        var xgap = (0.5 * vpw - cd0.r) / gs.w;\n        var ygap = (0.5 * vph - cd0.r) / gs.h;\n        Plots.autoMargin(gd, 'pie.' + trace.uid + '.automargin', {\n          xl: domain.x[0] - xgap,\n          xr: domain.x[1] + xgap,\n          yb: domain.y[0] - ygap,\n          yt: domain.y[1] + ygap,\n          l: Math.max(cd0.cx - cd0.r - traceBbox.left, 0),\n          r: Math.max(traceBbox.right - (cd0.cx + cd0.r), 0),\n          b: Math.max(traceBbox.bottom - (cd0.cy + cd0.r), 0),\n          t: Math.max(cd0.cy - cd0.r - traceBbox.top, 0),\n          pad: 5\n        });\n      }\n    });\n  }); // This is for a bug in Chrome (as of 2015-07-22, and does not affect FF)\n  // if insidetextfont and outsidetextfont are different sizes, sometimes the size\n  // of an \"em\" gets taken from the wrong element at first so lines are\n  // spaced wrong. You just have to tell it to try again later and it gets fixed.\n  // I have no idea why we haven't seen this in other contexts. Also, sometimes\n  // it gets the initial draw correct but on redraw it gets confused.\n\n  setTimeout(function () {\n    plotGroups.selectAll('tspan').each(function () {\n      var s = d3.select(this);\n      if (s.attr('dy')) s.attr('dy', s.attr('dy'));\n    });\n  }, 0);\n} // TODO add support for transition\n\n\nfunction plotTextLines(slices, trace) {\n  slices.each(function (pt) {\n    var sliceTop = d3.select(this);\n\n    if (!pt.labelExtraX && !pt.labelExtraY) {\n      sliceTop.select('path.textline').remove();\n      return;\n    } // first move the text to its new location\n\n\n    var sliceText = sliceTop.select('g.slicetext text');\n    sliceText.attr('transform', 'translate(' + pt.labelExtraX + ',' + pt.labelExtraY + ')' + sliceText.attr('transform')); // then add a line to the new location\n\n    var lineStartX = pt.cxFinal + pt.pxmid[0];\n    var lineStartY = pt.cyFinal + pt.pxmid[1];\n    var textLinePath = 'M' + lineStartX + ',' + lineStartY;\n    var finalX = (pt.yLabelMax - pt.yLabelMin) * (pt.pxmid[0] < 0 ? -1 : 1) / 4;\n\n    if (pt.labelExtraX) {\n      var yFromX = pt.labelExtraX * pt.pxmid[1] / pt.pxmid[0];\n      var yNet = pt.yLabelMid + pt.labelExtraY - (pt.cyFinal + pt.pxmid[1]);\n\n      if (Math.abs(yFromX) > Math.abs(yNet)) {\n        textLinePath += 'l' + yNet * pt.pxmid[0] / pt.pxmid[1] + ',' + yNet + 'H' + (lineStartX + pt.labelExtraX + finalX);\n      } else {\n        textLinePath += 'l' + pt.labelExtraX + ',' + yFromX + 'v' + (yNet - yFromX) + 'h' + finalX;\n      }\n    } else {\n      textLinePath += 'V' + (pt.yLabelMid + pt.labelExtraY) + 'h' + finalX;\n    }\n\n    Lib.ensureSingle(sliceTop, 'path', 'textline').call(Color.stroke, trace.outsidetextfont.color).attr({\n      'stroke-width': Math.min(2, trace.outsidetextfont.size / 8),\n      d: textLinePath,\n      fill: 'none'\n    });\n  });\n}\n\nfunction attachFxHandlers(sliceTop, gd, cd) {\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var cx = cd0.cx;\n  var cy = cd0.cy; // hover state vars\n  // have we drawn a hover label, so it should be cleared later\n\n  if (!('_hasHoverLabel' in trace)) trace._hasHoverLabel = false; // have we emitted a hover event, so later an unhover event should be emitted\n  // note that click events do not depend on this - you can still get them\n  // with hovermode: false or if you were earlier dragging, then clicked\n  // in the same slice that you moused up in\n\n  if (!('_hasHoverEvent' in trace)) trace._hasHoverEvent = false;\n  sliceTop.on('mouseover', function (pt) {\n    // in case fullLayout or fullData has changed without a replot\n    var fullLayout2 = gd._fullLayout;\n    var trace2 = gd._fullData[trace.index];\n    if (gd._dragging || fullLayout2.hovermode === false) return;\n    var hoverinfo = trace2.hoverinfo;\n\n    if (Array.isArray(hoverinfo)) {\n      // super hacky: we need to pull out the *first* hoverinfo from\n      // pt.pts, then put it back into an array in a dummy trace\n      // and call castHoverinfo on that.\n      // TODO: do we want to have Fx.castHoverinfo somehow handle this?\n      // it already takes an array for index, for 2D, so this seems tricky.\n      hoverinfo = Fx.castHoverinfo({\n        hoverinfo: [helpers.castOption(hoverinfo, pt.pts)],\n        _module: trace._module\n      }, fullLayout2, 0);\n    }\n\n    if (hoverinfo === 'all') hoverinfo = 'label+text+value+percent+name'; // in case we dragged over the pie from another subplot,\n    // or if hover is turned off\n\n    if (trace2.hovertemplate || hoverinfo !== 'none' && hoverinfo !== 'skip' && hoverinfo) {\n      var rInscribed = pt.rInscribed || 0;\n      var hoverCenterX = cx + pt.pxmid[0] * (1 - rInscribed);\n      var hoverCenterY = cy + pt.pxmid[1] * (1 - rInscribed);\n      var separators = fullLayout2.separators;\n      var text = [];\n      if (hoverinfo && hoverinfo.indexOf('label') !== -1) text.push(pt.label);\n      pt.text = helpers.castOption(trace2.hovertext || trace2.text, pt.pts);\n\n      if (hoverinfo && hoverinfo.indexOf('text') !== -1) {\n        var tx = pt.text;\n        if (Lib.isValidTextValue(tx)) text.push(tx);\n      }\n\n      pt.value = pt.v;\n      pt.valueLabel = helpers.formatPieValue(pt.v, separators);\n      if (hoverinfo && hoverinfo.indexOf('value') !== -1) text.push(pt.valueLabel);\n      pt.percent = pt.v / cd0.vTotal;\n      pt.percentLabel = helpers.formatPiePercent(pt.percent, separators);\n      if (hoverinfo && hoverinfo.indexOf('percent') !== -1) text.push(pt.percentLabel);\n      var hoverLabel = trace2.hoverlabel;\n      var hoverFont = hoverLabel.font;\n      Fx.loneHover({\n        trace: trace,\n        x0: hoverCenterX - rInscribed * cd0.r,\n        x1: hoverCenterX + rInscribed * cd0.r,\n        y: hoverCenterY,\n        text: text.join('<br>'),\n        name: trace2.hovertemplate || hoverinfo.indexOf('name') !== -1 ? trace2.name : undefined,\n        idealAlign: pt.pxmid[0] < 0 ? 'left' : 'right',\n        color: helpers.castOption(hoverLabel.bgcolor, pt.pts) || pt.color,\n        borderColor: helpers.castOption(hoverLabel.bordercolor, pt.pts),\n        fontFamily: helpers.castOption(hoverFont.family, pt.pts),\n        fontSize: helpers.castOption(hoverFont.size, pt.pts),\n        fontColor: helpers.castOption(hoverFont.color, pt.pts),\n        nameLength: helpers.castOption(hoverLabel.namelength, pt.pts),\n        textAlign: helpers.castOption(hoverLabel.align, pt.pts),\n        hovertemplate: helpers.castOption(trace2.hovertemplate, pt.pts),\n        hovertemplateLabels: pt,\n        eventData: [eventData(pt, trace2)]\n      }, {\n        container: fullLayout2._hoverlayer.node(),\n        outerContainer: fullLayout2._paper.node(),\n        gd: gd\n      });\n      trace._hasHoverLabel = true;\n    }\n\n    trace._hasHoverEvent = true;\n    gd.emit('plotly_hover', {\n      points: [eventData(pt, trace2)],\n      event: d3.event\n    });\n  });\n  sliceTop.on('mouseout', function (evt) {\n    var fullLayout2 = gd._fullLayout;\n    var trace2 = gd._fullData[trace.index];\n    var pt = d3.select(this).datum();\n\n    if (trace._hasHoverEvent) {\n      evt.originalEvent = d3.event;\n      gd.emit('plotly_unhover', {\n        points: [eventData(pt, trace2)],\n        event: d3.event\n      });\n      trace._hasHoverEvent = false;\n    }\n\n    if (trace._hasHoverLabel) {\n      Fx.loneUnhover(fullLayout2._hoverlayer.node());\n      trace._hasHoverLabel = false;\n    }\n  });\n  sliceTop.on('click', function (pt) {\n    // TODO: this does not support right-click. If we want to support it, we\n    // would likely need to change pie to use dragElement instead of straight\n    // mapbox event binding. Or perhaps better, make a simple wrapper with the\n    // right mousedown, mousemove, and mouseup handlers just for a left/right click\n    // mapbox would use this too.\n    var fullLayout2 = gd._fullLayout;\n    var trace2 = gd._fullData[trace.index];\n    if (gd._dragging || fullLayout2.hovermode === false) return;\n    gd._hoverdata = [eventData(pt, trace2)];\n    Fx.click(gd, d3.event);\n  });\n}\n\nfunction determineOutsideTextFont(trace, pt, layoutFont) {\n  var color = helpers.castOption(trace.outsidetextfont.color, pt.pts) || helpers.castOption(trace.textfont.color, pt.pts) || layoutFont.color;\n  var family = helpers.castOption(trace.outsidetextfont.family, pt.pts) || helpers.castOption(trace.textfont.family, pt.pts) || layoutFont.family;\n  var size = helpers.castOption(trace.outsidetextfont.size, pt.pts) || helpers.castOption(trace.textfont.size, pt.pts) || layoutFont.size;\n  return {\n    color: color,\n    family: family,\n    size: size\n  };\n}\n\nfunction determineInsideTextFont(trace, pt, layoutFont) {\n  var customColor = helpers.castOption(trace.insidetextfont.color, pt.pts);\n\n  if (!customColor && trace._input.textfont) {\n    // Why not simply using trace.textfont? Because if not set, it\n    // defaults to layout.font which has a default color. But if\n    // textfont.color and insidetextfont.color don't supply a value,\n    // a contrasting color shall be used.\n    customColor = helpers.castOption(trace._input.textfont.color, pt.pts);\n  }\n\n  var family = helpers.castOption(trace.insidetextfont.family, pt.pts) || helpers.castOption(trace.textfont.family, pt.pts) || layoutFont.family;\n  var size = helpers.castOption(trace.insidetextfont.size, pt.pts) || helpers.castOption(trace.textfont.size, pt.pts) || layoutFont.size;\n  return {\n    color: customColor || Color.contrast(pt.color),\n    family: family,\n    size: size\n  };\n}\n\nfunction prerenderTitles(cdModule, gd) {\n  var cd0, trace; // Determine the width and height of the title for each pie.\n\n  for (var i = 0; i < cdModule.length; i++) {\n    cd0 = cdModule[i][0];\n    trace = cd0.trace;\n\n    if (trace.title.text) {\n      var txt = trace.title.text;\n\n      if (trace._meta) {\n        txt = Lib.templateString(txt, trace._meta);\n      }\n\n      var dummyTitle = Drawing.tester.append('text').attr('data-notex', 1).text(txt).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);\n      var bBox = Drawing.bBox(dummyTitle.node(), true);\n      cd0.titleBox = {\n        width: bBox.width,\n        height: bBox.height\n      };\n      dummyTitle.remove();\n    }\n  }\n}\n\nfunction transformInsideText(textBB, pt, cd0) {\n  var textDiameter = Math.sqrt(textBB.width * textBB.width + textBB.height * textBB.height);\n  var textAspect = textBB.width / textBB.height;\n  var halfAngle = pt.halfangle;\n  var ring = pt.ring;\n  var rInscribed = pt.rInscribed;\n  var r = cd0.r || pt.rpx1; // max size text can be inserted inside without rotating it\n  // this inscribes the text rectangle in a circle, which is then inscribed\n  // in the slice, so it will be an underestimate, which some day we may want\n  // to improve so this case can get more use\n\n  var transform = {\n    scale: rInscribed * r * 2 / textDiameter,\n    // and the center position and rotation in this case\n    rCenter: 1 - rInscribed,\n    rotate: 0\n  };\n  if (transform.scale >= 1) return transform; // max size if text is rotated radially\n\n  var Qr = textAspect + 1 / (2 * Math.tan(halfAngle));\n  var maxHalfHeightRotRadial = r * Math.min(1 / (Math.sqrt(Qr * Qr + 0.5) + Qr), ring / (Math.sqrt(textAspect * textAspect + ring / 2) + textAspect));\n  var radialTransform = {\n    scale: maxHalfHeightRotRadial * 2 / textBB.height,\n    rCenter: Math.cos(maxHalfHeightRotRadial / r) - maxHalfHeightRotRadial * textAspect / r,\n    rotate: (180 / Math.PI * pt.midangle + 720) % 180 - 90\n  }; // max size if text is rotated tangentially\n\n  var aspectInv = 1 / textAspect;\n  var Qt = aspectInv + 1 / (2 * Math.tan(halfAngle));\n  var maxHalfWidthTangential = r * Math.min(1 / (Math.sqrt(Qt * Qt + 0.5) + Qt), ring / (Math.sqrt(aspectInv * aspectInv + ring / 2) + aspectInv));\n  var tangentialTransform = {\n    scale: maxHalfWidthTangential * 2 / textBB.width,\n    rCenter: Math.cos(maxHalfWidthTangential / r) - maxHalfWidthTangential / textAspect / r,\n    rotate: (180 / Math.PI * pt.midangle + 810) % 180 - 90\n  }; // if we need a rotated transform, pick the biggest one\n  // even if both are bigger than 1\n\n  var rotatedTransform = tangentialTransform.scale > radialTransform.scale ? tangentialTransform : radialTransform;\n  if (transform.scale < 1 && rotatedTransform.scale > transform.scale) return rotatedTransform;\n  return transform;\n}\n\nfunction getInscribedRadiusFraction(pt, cd0) {\n  if (pt.v === cd0.vTotal && !cd0.trace.hole) return 1; // special case of 100% with no hole\n\n  return Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2);\n}\n\nfunction transformOutsideText(textBB, pt) {\n  var x = pt.pxmid[0];\n  var y = pt.pxmid[1];\n  var dx = textBB.width / 2;\n  var dy = textBB.height / 2;\n  if (x < 0) dx *= -1;\n  if (y < 0) dy *= -1;\n  return {\n    scale: 1,\n    rCenter: 1,\n    rotate: 0,\n    x: dx + Math.abs(dy) * (dx > 0 ? 1 : -1) / 2,\n    y: dy / (1 + x * x / (y * y)),\n    outside: true\n  };\n}\n\nfunction positionTitleInside(cd0) {\n  var textDiameter = Math.sqrt(cd0.titleBox.width * cd0.titleBox.width + cd0.titleBox.height * cd0.titleBox.height);\n  return {\n    x: cd0.cx,\n    y: cd0.cy,\n    scale: cd0.trace.hole * cd0.r * 2 / textDiameter,\n    tx: 0,\n    ty: -cd0.titleBox.height / 2 + cd0.trace.title.font.size\n  };\n}\n\nfunction positionTitleOutside(cd0, plotSize) {\n  var scaleX = 1;\n  var scaleY = 1;\n  var maxPull;\n  var trace = cd0.trace; // position of the baseline point of the text box in the plot, before scaling.\n  // we anchored the text in the middle, so the baseline is on the bottom middle\n  // of the first line of text.\n\n  var topMiddle = {\n    x: cd0.cx,\n    y: cd0.cy\n  }; // relative translation of the text box after scaling\n\n  var translate = {\n    tx: 0,\n    ty: 0\n  }; // we reason below as if the baseline is the top middle point of the text box.\n  // so we must add the font size to approximate the y-coord. of the top.\n  // note that this correction must happen after scaling.\n\n  translate.ty += trace.title.font.size;\n  maxPull = getMaxPull(trace);\n\n  if (trace.title.position.indexOf('top') !== -1) {\n    topMiddle.y -= (1 + maxPull) * cd0.r;\n    translate.ty -= cd0.titleBox.height;\n  } else if (trace.title.position.indexOf('bottom') !== -1) {\n    topMiddle.y += (1 + maxPull) * cd0.r;\n  }\n\n  var rx = applyAspectRatio(cd0.r, cd0.trace.aspectratio);\n  var maxWidth = plotSize.w * (trace.domain.x[1] - trace.domain.x[0]) / 2;\n\n  if (trace.title.position.indexOf('left') !== -1) {\n    // we start the text at the left edge of the pie\n    maxWidth = maxWidth + rx;\n    topMiddle.x -= (1 + maxPull) * rx;\n    translate.tx += cd0.titleBox.width / 2;\n  } else if (trace.title.position.indexOf('center') !== -1) {\n    maxWidth *= 2;\n  } else if (trace.title.position.indexOf('right') !== -1) {\n    maxWidth = maxWidth + rx;\n    topMiddle.x += (1 + maxPull) * rx;\n    translate.tx -= cd0.titleBox.width / 2;\n  }\n\n  scaleX = maxWidth / cd0.titleBox.width;\n  scaleY = getTitleSpace(cd0, plotSize) / cd0.titleBox.height;\n  return {\n    x: topMiddle.x,\n    y: topMiddle.y,\n    scale: Math.min(scaleX, scaleY),\n    tx: translate.tx,\n    ty: translate.ty\n  };\n}\n\nfunction applyAspectRatio(x, aspectratio) {\n  return x / (aspectratio === undefined ? 1 : aspectratio);\n}\n\nfunction getTitleSpace(cd0, plotSize) {\n  var trace = cd0.trace;\n  var pieBoxHeight = plotSize.h * (trace.domain.y[1] - trace.domain.y[0]); // use at most half of the plot for the title\n\n  return Math.min(cd0.titleBox.height, pieBoxHeight / 2);\n}\n\nfunction getMaxPull(trace) {\n  var maxPull = trace.pull;\n  if (!maxPull) return 0;\n  var j;\n\n  if (Array.isArray(maxPull)) {\n    maxPull = 0;\n\n    for (j = 0; j < trace.pull.length; j++) {\n      if (trace.pull[j] > maxPull) maxPull = trace.pull[j];\n    }\n  }\n\n  return maxPull;\n}\n\nfunction scootLabels(quadrants, trace) {\n  var xHalf, yHalf, equatorFirst, farthestX, farthestY, xDiffSign, yDiffSign, thisQuad, oppositeQuad, wholeSide, i, thisQuadOutside, firstOppositeOutsidePt;\n\n  function topFirst(a, b) {\n    return a.pxmid[1] - b.pxmid[1];\n  }\n\n  function bottomFirst(a, b) {\n    return b.pxmid[1] - a.pxmid[1];\n  }\n\n  function scootOneLabel(thisPt, prevPt) {\n    if (!prevPt) prevPt = {};\n    var prevOuterY = prevPt.labelExtraY + (yHalf ? prevPt.yLabelMax : prevPt.yLabelMin);\n    var thisInnerY = yHalf ? thisPt.yLabelMin : thisPt.yLabelMax;\n    var thisOuterY = yHalf ? thisPt.yLabelMax : thisPt.yLabelMin;\n    var thisSliceOuterY = thisPt.cyFinal + farthestY(thisPt.px0[1], thisPt.px1[1]);\n    var newExtraY = prevOuterY - thisInnerY;\n    var xBuffer, i, otherPt, otherOuterY, otherOuterX, newExtraX; // make sure this label doesn't overlap other labels\n    // this *only* has us move these labels vertically\n\n    if (newExtraY * yDiffSign > 0) thisPt.labelExtraY = newExtraY; // make sure this label doesn't overlap any slices\n\n    if (!Array.isArray(trace.pull)) return; // this can only happen with array pulls\n\n    for (i = 0; i < wholeSide.length; i++) {\n      otherPt = wholeSide[i]; // overlap can only happen if the other point is pulled more than this one\n\n      if (otherPt === thisPt || (helpers.castOption(trace.pull, thisPt.pts) || 0) >= (helpers.castOption(trace.pull, otherPt.pts) || 0)) {\n        continue;\n      }\n\n      if ((thisPt.pxmid[1] - otherPt.pxmid[1]) * yDiffSign > 0) {\n        // closer to the equator - by construction all of these happen first\n        // move the text vertically to get away from these slices\n        otherOuterY = otherPt.cyFinal + farthestY(otherPt.px0[1], otherPt.px1[1]);\n        newExtraY = otherOuterY - thisInnerY - thisPt.labelExtraY;\n        if (newExtraY * yDiffSign > 0) thisPt.labelExtraY += newExtraY;\n      } else if ((thisOuterY + thisPt.labelExtraY - thisSliceOuterY) * yDiffSign > 0) {\n        // farther from the equator - happens after we've done all the\n        // vertical moving we're going to do\n        // move horizontally to get away from these more polar slices\n        // if we're moving horz. based on a slice that's several slices away from this one\n        // then we need some extra space for the lines to labels between them\n        xBuffer = 3 * xDiffSign * Math.abs(i - wholeSide.indexOf(thisPt));\n        otherOuterX = otherPt.cxFinal + farthestX(otherPt.px0[0], otherPt.px1[0]);\n        newExtraX = otherOuterX + xBuffer - (thisPt.cxFinal + thisPt.pxmid[0]) - thisPt.labelExtraX;\n        if (newExtraX * xDiffSign > 0) thisPt.labelExtraX += newExtraX;\n      }\n    }\n  }\n\n  for (yHalf = 0; yHalf < 2; yHalf++) {\n    equatorFirst = yHalf ? topFirst : bottomFirst;\n    farthestY = yHalf ? Math.max : Math.min;\n    yDiffSign = yHalf ? 1 : -1;\n\n    for (xHalf = 0; xHalf < 2; xHalf++) {\n      farthestX = xHalf ? Math.max : Math.min;\n      xDiffSign = xHalf ? 1 : -1; // first sort the array\n      // note this is a copy of cd, so cd itself doesn't get sorted\n      // but we can still modify points in place.\n\n      thisQuad = quadrants[yHalf][xHalf];\n      thisQuad.sort(equatorFirst);\n      oppositeQuad = quadrants[1 - yHalf][xHalf];\n      wholeSide = oppositeQuad.concat(thisQuad);\n      thisQuadOutside = [];\n\n      for (i = 0; i < thisQuad.length; i++) {\n        if (thisQuad[i].yLabelMid !== undefined) thisQuadOutside.push(thisQuad[i]);\n      }\n\n      firstOppositeOutsidePt = false;\n\n      for (i = 0; yHalf && i < oppositeQuad.length; i++) {\n        if (oppositeQuad[i].yLabelMid !== undefined) {\n          firstOppositeOutsidePt = oppositeQuad[i];\n          break;\n        }\n      } // each needs to avoid the previous\n\n\n      for (i = 0; i < thisQuadOutside.length; i++) {\n        var prevPt = i && thisQuadOutside[i - 1]; // bottom half needs to avoid the first label of the top half\n        // top half we still need to call scootOneLabel on the first slice\n        // so we can avoid other slices, but we don't pass a prevPt\n\n        if (firstOppositeOutsidePt && !i) prevPt = firstOppositeOutsidePt;\n        scootOneLabel(thisQuadOutside[i], prevPt);\n      }\n    }\n  }\n}\n\nfunction layoutAreas(cdModule, plotSize) {\n  var scaleGroups = []; // figure out the center and maximum radius\n\n  for (var i = 0; i < cdModule.length; i++) {\n    var cd0 = cdModule[i][0];\n    var trace = cd0.trace;\n    var domain = trace.domain;\n    var width = plotSize.w * (domain.x[1] - domain.x[0]);\n    var height = plotSize.h * (domain.y[1] - domain.y[0]); // leave some space for the title, if it will be displayed outside\n\n    if (trace.title.text && trace.title.position !== 'middle center') {\n      height -= getTitleSpace(cd0, plotSize);\n    }\n\n    var rx = width / 2;\n    var ry = height / 2;\n\n    if (trace.type === 'funnelarea' && !trace.scalegroup) {\n      ry /= trace.aspectratio;\n    }\n\n    cd0.r = Math.min(rx, ry) / (1 + getMaxPull(trace));\n    cd0.cx = plotSize.l + plotSize.w * (trace.domain.x[1] + trace.domain.x[0]) / 2;\n    cd0.cy = plotSize.t + plotSize.h * (1 - trace.domain.y[0]) - height / 2;\n\n    if (trace.title.text && trace.title.position.indexOf('bottom') !== -1) {\n      cd0.cy -= getTitleSpace(cd0, plotSize);\n    }\n\n    if (trace.scalegroup && scaleGroups.indexOf(trace.scalegroup) === -1) {\n      scaleGroups.push(trace.scalegroup);\n    }\n  }\n\n  groupScale(cdModule, scaleGroups);\n}\n\nfunction groupScale(cdModule, scaleGroups) {\n  var cd0, i, trace; // scale those that are grouped\n\n  for (var k = 0; k < scaleGroups.length; k++) {\n    var min = Infinity;\n    var g = scaleGroups[k];\n\n    for (i = 0; i < cdModule.length; i++) {\n      cd0 = cdModule[i][0];\n      trace = cd0.trace;\n\n      if (trace.scalegroup === g) {\n        var area;\n\n        if (trace.type === 'pie') {\n          area = cd0.r * cd0.r;\n        } else if (trace.type === 'funnelarea') {\n          var rx, ry;\n\n          if (trace.aspectratio > 1) {\n            rx = cd0.r;\n            ry = rx / trace.aspectratio;\n          } else {\n            ry = cd0.r;\n            rx = ry * trace.aspectratio;\n          }\n\n          rx *= (1 + trace.baseratio) / 2;\n          area = rx * ry;\n        }\n\n        min = Math.min(min, area / cd0.vTotal);\n      }\n    }\n\n    for (i = 0; i < cdModule.length; i++) {\n      cd0 = cdModule[i][0];\n      trace = cd0.trace;\n\n      if (trace.scalegroup === g) {\n        var v = min * cd0.vTotal;\n\n        if (trace.type === 'funnelarea') {\n          v /= (1 + trace.baseratio) / 2;\n          v /= trace.aspectratio;\n        }\n\n        cd0.r = Math.sqrt(v);\n      }\n    }\n  }\n}\n\nfunction setCoords(cd) {\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var currentAngle = trace.rotation * Math.PI / 180;\n  var angleFactor = 2 * Math.PI / cd0.vTotal;\n  var firstPt = 'px0';\n  var lastPt = 'px1';\n  var i, cdi, currentCoords;\n\n  if (trace.direction === 'counterclockwise') {\n    for (i = 0; i < cd.length; i++) {\n      if (!cd[i].hidden) break; // find the first non-hidden slice\n    }\n\n    if (i === cd.length) return; // all slices hidden\n\n    currentAngle += angleFactor * cd[i].v;\n    angleFactor *= -1;\n    firstPt = 'px1';\n    lastPt = 'px0';\n  }\n\n  function getCoords(angle) {\n    return [cd0.r * Math.sin(angle), -cd0.r * Math.cos(angle)];\n  }\n\n  currentCoords = getCoords(currentAngle);\n\n  for (i = 0; i < cd.length; i++) {\n    cdi = cd[i];\n    if (cdi.hidden) continue;\n    cdi[firstPt] = currentCoords;\n    currentAngle += angleFactor * cdi.v / 2;\n    cdi.pxmid = getCoords(currentAngle);\n    cdi.midangle = currentAngle;\n    currentAngle += angleFactor * cdi.v / 2;\n    currentCoords = getCoords(currentAngle);\n    cdi[lastPt] = currentCoords;\n    cdi.largeArc = cdi.v > cd0.vTotal / 2 ? 1 : 0;\n    cdi.halfangle = Math.PI * Math.min(cdi.v / cd0.vTotal, 0.5);\n    cdi.ring = 1 - trace.hole;\n    cdi.rInscribed = getInscribedRadiusFraction(cdi, cd0);\n  }\n}\n\nfunction formatSliceLabel(gd, pt, cd0) {\n  var fullLayout = gd._fullLayout;\n  var trace = cd0.trace; // look for textemplate\n\n  var texttemplate = trace.texttemplate; // now insert text\n\n  var textinfo = trace.textinfo;\n\n  if (!texttemplate && textinfo && textinfo !== 'none') {\n    var parts = textinfo.split('+');\n\n    var hasFlag = function (flag) {\n      return parts.indexOf(flag) !== -1;\n    };\n\n    var hasLabel = hasFlag('label');\n    var hasText = hasFlag('text');\n    var hasValue = hasFlag('value');\n    var hasPercent = hasFlag('percent');\n    var separators = fullLayout.separators;\n    var text;\n    text = hasLabel ? [pt.label] : [];\n\n    if (hasText) {\n      var tx = helpers.getFirstFilled(trace.text, pt.pts);\n      if (isValidTextValue(tx)) text.push(tx);\n    }\n\n    if (hasValue) text.push(helpers.formatPieValue(pt.v, separators));\n    if (hasPercent) text.push(helpers.formatPiePercent(pt.v / cd0.vTotal, separators));\n    pt.text = text.join('<br>');\n  }\n\n  function makeTemplateVariables(pt) {\n    return {\n      label: pt.label,\n      value: pt.v,\n      valueLabel: helpers.formatPieValue(pt.v, fullLayout.separators),\n      percent: pt.v / cd0.vTotal,\n      percentLabel: helpers.formatPiePercent(pt.v / cd0.vTotal, fullLayout.separators),\n      color: pt.color,\n      text: pt.text,\n      customdata: Lib.castOption(trace, pt.i, 'customdata')\n    };\n  }\n\n  if (texttemplate) {\n    var txt = Lib.castOption(trace, pt.i, 'texttemplate');\n\n    if (!txt) {\n      pt.text = '';\n    } else {\n      var obj = makeTemplateVariables(pt);\n      var ptTx = helpers.getFirstFilled(trace.text, pt.pts);\n      if (isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n      pt.text = Lib.texttemplateString(txt, obj, gd._fullLayout._d3locale, obj, trace._meta || {});\n    }\n  }\n}\n\nmodule.exports = {\n  plot: plot,\n  formatSliceLabel: formatSliceLabel,\n  transformInsideText: transformInsideText,\n  determineInsideTextFont: determineInsideTextFont,\n  positionTitleOutside: positionTitleOutside,\n  prerenderTitles: prerenderTitles,\n  layoutAreas: layoutAreas,\n  attachFxHandlers: attachFxHandlers\n};","map":null,"metadata":{},"sourceType":"script"}