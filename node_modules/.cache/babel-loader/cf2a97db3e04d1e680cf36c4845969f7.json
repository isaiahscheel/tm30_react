{"ast":null,"code":"'use strict';\n\nvar isAllBlank = require('is-string-blank');\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar pool = require('typedarray-pool');\n\nvar mat4mult = require('gl-mat4/multiply');\n\nvar shaders = require('./lib/shaders');\n\nvar getGlyph = require('./lib/glyphs');\n\nvar getSimpleString = require('./lib/get-simple-string');\n\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nmodule.exports = createPointCloud;\n\nfunction transformMat4(x, m) {\n  var x0 = x[0];\n  var x1 = x[1];\n  var x2 = x[2];\n  var x3 = x[3];\n  x[0] = m[0] * x0 + m[4] * x1 + m[8] * x2 + m[12] * x3;\n  x[1] = m[1] * x0 + m[5] * x1 + m[9] * x2 + m[13] * x3;\n  x[2] = m[2] * x0 + m[6] * x1 + m[10] * x2 + m[14] * x3;\n  x[3] = m[3] * x0 + m[7] * x1 + m[11] * x2 + m[15] * x3;\n  return x;\n}\n\nfunction project(p, v, m, x) {\n  transformMat4(x, x, m);\n  transformMat4(x, x, v);\n  return transformMat4(x, x, p);\n}\n\nfunction ScatterPlotPickResult(index, position) {\n  this.index = index;\n  this.dataCoordinate = this.position = position;\n}\n\nfunction fixOpacity(a) {\n  if (a === true) return 1;\n  if (a > 1) return 1;\n  return a;\n}\n\nfunction PointCloud(gl, shader, orthoShader, projectShader, pointBuffer, colorBuffer, glyphBuffer, idBuffer, vao, pickPerspectiveShader, pickOrthoShader, pickProjectShader) {\n  this.gl = gl;\n  this.pixelRatio = 1;\n  this.shader = shader;\n  this.orthoShader = orthoShader;\n  this.projectShader = projectShader;\n  this.pointBuffer = pointBuffer;\n  this.colorBuffer = colorBuffer;\n  this.glyphBuffer = glyphBuffer;\n  this.idBuffer = idBuffer;\n  this.vao = vao;\n  this.vertexCount = 0;\n  this.lineVertexCount = 0;\n  this.opacity = 1;\n  this.hasAlpha = false;\n  this.lineWidth = 0;\n  this.projectScale = [2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0];\n  this.projectOpacity = [1, 1, 1];\n  this.projectHasAlpha = false;\n  this.pickId = 0;\n  this.pickPerspectiveShader = pickPerspectiveShader;\n  this.pickOrthoShader = pickOrthoShader;\n  this.pickProjectShader = pickProjectShader;\n  this.points = [];\n  this._selectResult = new ScatterPlotPickResult(0, [0, 0, 0]);\n  this.useOrtho = true;\n  this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]]; //Axes projections\n\n  this.axesProject = [true, true, true];\n  this.axesBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.highlightId = [1, 1, 1, 1];\n  this.highlightScale = 2;\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.dirty = true;\n}\n\nvar proto = PointCloud.prototype;\nproto.pickSlots = 1;\n\nproto.setPickBase = function (pickBase) {\n  this.pickId = pickBase;\n};\n\nproto.isTransparent = function () {\n  if (this.hasAlpha) {\n    return true;\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    if (this.axesProject[i] && this.projectHasAlpha) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nproto.isOpaque = function () {\n  if (!this.hasAlpha) {\n    return true;\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    if (this.axesProject[i] && !this.projectHasAlpha) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar VIEW_SHAPE = [0, 0];\nvar U_VEC = [0, 0, 0];\nvar V_VEC = [0, 0, 0];\nvar MU_VEC = [0, 0, 0, 1];\nvar MV_VEC = [0, 0, 0, 1];\nvar SCRATCH_MATRIX = IDENTITY.slice();\nvar SCRATCH_VEC = [0, 0, 0];\nvar CLIP_BOUNDS = [[0, 0, 0], [0, 0, 0]];\n\nfunction zeroVec(a) {\n  a[0] = a[1] = a[2] = 0;\n  return a;\n}\n\nfunction augment(hg, af) {\n  hg[0] = af[0];\n  hg[1] = af[1];\n  hg[2] = af[2];\n  hg[3] = 1;\n  return hg;\n}\n\nfunction setComponent(out, v, i, x) {\n  out[0] = v[0];\n  out[1] = v[1];\n  out[2] = v[2];\n  out[i] = x;\n  return out;\n}\n\nfunction getClipBounds(bounds) {\n  var result = CLIP_BOUNDS;\n\n  for (var i = 0; i < 2; ++i) {\n    for (var j = 0; j < 3; ++j) {\n      result[i][j] = Math.max(Math.min(bounds[i][j], 1e8), -1e8);\n    }\n  }\n\n  return result;\n}\n\nfunction drawProject(shader, points, camera, pixelRatio) {\n  var axesProject = points.axesProject;\n  var gl = points.gl;\n  var uniforms = shader.uniforms;\n  var model = camera.model || IDENTITY;\n  var view = camera.view || IDENTITY;\n  var projection = camera.projection || IDENTITY;\n  var bounds = points.axesBounds;\n  var clipBounds = getClipBounds(points.clipBounds);\n  var cubeAxis;\n\n  if (points.axes && points.axes.lastCubeProps) {\n    cubeAxis = points.axes.lastCubeProps.axis;\n  } else {\n    cubeAxis = [1, 1, 1];\n  }\n\n  VIEW_SHAPE[0] = 2.0 / gl.drawingBufferWidth;\n  VIEW_SHAPE[1] = 2.0 / gl.drawingBufferHeight;\n  shader.bind();\n  uniforms.view = view;\n  uniforms.projection = projection;\n  uniforms.screenSize = VIEW_SHAPE;\n  uniforms.highlightId = points.highlightId;\n  uniforms.highlightScale = points.highlightScale;\n  uniforms.clipBounds = clipBounds;\n  uniforms.pickGroup = points.pickId / 255.0;\n  uniforms.pixelRatio = pixelRatio;\n\n  for (var i = 0; i < 3; ++i) {\n    if (!axesProject[i]) {\n      continue;\n    }\n\n    uniforms.scale = points.projectScale[i];\n    uniforms.opacity = points.projectOpacity[i]; //Project model matrix\n\n    var pmodel = SCRATCH_MATRIX;\n\n    for (var j = 0; j < 16; ++j) {\n      pmodel[j] = 0;\n    }\n\n    for (var j = 0; j < 4; ++j) {\n      pmodel[5 * j] = 1;\n    }\n\n    pmodel[5 * i] = 0;\n\n    if (cubeAxis[i] < 0) {\n      pmodel[12 + i] = bounds[0][i];\n    } else {\n      pmodel[12 + i] = bounds[1][i];\n    }\n\n    mat4mult(pmodel, model, pmodel);\n    uniforms.model = pmodel; //Compute initial axes\n\n    var u = (i + 1) % 3;\n    var v = (i + 2) % 3;\n    var du = zeroVec(U_VEC);\n    var dv = zeroVec(V_VEC);\n    du[u] = 1;\n    dv[v] = 1; //Align orientation relative to viewer\n\n    var mdu = project(projection, view, model, augment(MU_VEC, du));\n    var mdv = project(projection, view, model, augment(MV_VEC, dv));\n\n    if (Math.abs(mdu[1]) > Math.abs(mdv[1])) {\n      var tmp = mdu;\n      mdu = mdv;\n      mdv = tmp;\n      tmp = du;\n      du = dv;\n      dv = tmp;\n      var t = u;\n      u = v;\n      v = t;\n    }\n\n    if (mdu[0] < 0) {\n      du[u] = -1;\n    }\n\n    if (mdv[1] > 0) {\n      dv[v] = -1;\n    }\n\n    var su = 0.0;\n    var sv = 0.0;\n\n    for (var j = 0; j < 4; ++j) {\n      su += Math.pow(model[4 * u + j], 2);\n      sv += Math.pow(model[4 * v + j], 2);\n    }\n\n    du[u] /= Math.sqrt(su);\n    dv[v] /= Math.sqrt(sv);\n    uniforms.axes[0] = du;\n    uniforms.axes[1] = dv; //Update fragment clip bounds\n\n    uniforms.fragClipBounds[0] = setComponent(SCRATCH_VEC, clipBounds[0], i, -1e8);\n    uniforms.fragClipBounds[1] = setComponent(SCRATCH_VEC, clipBounds[1], i, 1e8);\n    points.vao.bind(); //Draw interior\n\n    points.vao.draw(gl.TRIANGLES, points.vertexCount); //Draw edges\n\n    if (points.lineWidth > 0) {\n      gl.lineWidth(points.lineWidth * pixelRatio);\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount);\n    }\n\n    points.vao.unbind();\n  }\n}\n\nvar NEG_INFINITY3 = [-1e8, -1e8, -1e8];\nvar POS_INFINITY3 = [1e8, 1e8, 1e8];\nvar CLIP_GROUP = [NEG_INFINITY3, POS_INFINITY3];\n\nfunction drawFull(shader, pshader, points, camera, pixelRatio, transparent, forceDraw) {\n  var gl = points.gl;\n\n  if (transparent === points.projectHasAlpha || forceDraw) {\n    drawProject(pshader, points, camera, pixelRatio);\n  }\n\n  if (transparent === points.hasAlpha || forceDraw) {\n    shader.bind();\n    var uniforms = shader.uniforms;\n    uniforms.model = camera.model || IDENTITY;\n    uniforms.view = camera.view || IDENTITY;\n    uniforms.projection = camera.projection || IDENTITY;\n    VIEW_SHAPE[0] = 2.0 / gl.drawingBufferWidth;\n    VIEW_SHAPE[1] = 2.0 / gl.drawingBufferHeight;\n    uniforms.screenSize = VIEW_SHAPE;\n    uniforms.highlightId = points.highlightId;\n    uniforms.highlightScale = points.highlightScale;\n    uniforms.fragClipBounds = CLIP_GROUP;\n    uniforms.clipBounds = points.axes.bounds;\n    uniforms.opacity = points.opacity;\n    uniforms.pickGroup = points.pickId / 255.0;\n    uniforms.pixelRatio = pixelRatio;\n    points.vao.bind(); //Draw interior\n\n    points.vao.draw(gl.TRIANGLES, points.vertexCount); //Draw edges\n\n    if (points.lineWidth > 0) {\n      gl.lineWidth(points.lineWidth * pixelRatio);\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount);\n    }\n\n    points.vao.unbind();\n  }\n}\n\nproto.draw = function (camera) {\n  var shader = this.useOrtho ? this.orthoShader : this.shader;\n  drawFull(shader, this.projectShader, this, camera, this.pixelRatio, false, false);\n};\n\nproto.drawTransparent = function (camera) {\n  var shader = this.useOrtho ? this.orthoShader : this.shader;\n  drawFull(shader, this.projectShader, this, camera, this.pixelRatio, true, false);\n};\n\nproto.drawPick = function (camera) {\n  var shader = this.useOrtho ? this.pickOrthoShader : this.pickPerspectiveShader;\n  drawFull(shader, this.pickProjectShader, this, camera, 1, true, true);\n};\n\nproto.pick = function (selected) {\n  if (!selected) {\n    return null;\n  }\n\n  if (selected.id !== this.pickId) {\n    return null;\n  }\n\n  var x = selected.value[2] + (selected.value[1] << 8) + (selected.value[0] << 16);\n\n  if (x >= this.pointCount || x < 0) {\n    return null;\n  } //Unpack result\n\n\n  var coord = this.points[x];\n  var result = this._selectResult;\n  result.index = x;\n\n  for (var i = 0; i < 3; ++i) {\n    result.position[i] = result.dataCoordinate[i] = coord[i];\n  }\n\n  return result;\n};\n\nproto.highlight = function (selection) {\n  if (!selection) {\n    this.highlightId = [1, 1, 1, 1];\n  } else {\n    var pointId = selection.index;\n    var a0 = pointId & 0xff;\n    var a1 = pointId >> 8 & 0xff;\n    var a2 = pointId >> 16 & 0xff;\n    this.highlightId = [a0 / 255.0, a1 / 255.0, a2 / 255.0, 0];\n  }\n};\n\nfunction get_glyphData(glyphs, index, font, pixelRatio) {\n  var str; // use the data if presented in an array\n\n  if (Array.isArray(glyphs)) {\n    if (index < glyphs.length) {\n      str = glyphs[index];\n    } else {\n      str = undefined;\n    }\n  } else {\n    str = glyphs;\n  }\n\n  str = getSimpleString(str); // this would handle undefined cases\n\n  var visible = true;\n\n  if (isAllBlank(str)) {\n    str = 'â–¼'; // Note: this special character may have minimum number of surfaces\n\n    visible = false;\n  }\n\n  var glyph = getGlyph(str, font, pixelRatio);\n  return {\n    mesh: glyph[0],\n    lines: glyph[1],\n    bounds: glyph[2],\n    visible: visible\n  };\n}\n\nproto.update = function (options) {\n  options = options || {};\n\n  if ('perspective' in options) {\n    this.useOrtho = !options.perspective;\n  }\n\n  if ('orthographic' in options) {\n    this.useOrtho = !!options.orthographic;\n  }\n\n  if ('lineWidth' in options) {\n    this.lineWidth = options.lineWidth;\n  }\n\n  if ('project' in options) {\n    if (Array.isArray(options.project)) {\n      this.axesProject = options.project;\n    } else {\n      var v = !!options.project;\n      this.axesProject = [v, v, v];\n    }\n  }\n\n  if ('projectScale' in options) {\n    if (Array.isArray(options.projectScale)) {\n      this.projectScale = options.projectScale.slice();\n    } else {\n      var s = +options.projectScale;\n      this.projectScale = [s, s, s];\n    }\n  }\n\n  this.projectHasAlpha = false; // default to no transparent draw\n\n  if ('projectOpacity' in options) {\n    if (Array.isArray(options.projectOpacity)) {\n      this.projectOpacity = options.projectOpacity.slice();\n    } else {\n      var s = +options.projectOpacity;\n      this.projectOpacity = [s, s, s];\n    }\n\n    for (var i = 0; i < 3; ++i) {\n      this.projectOpacity[i] = fixOpacity(this.projectOpacity[i]);\n\n      if (this.projectOpacity[i] < 1) {\n        this.projectHasAlpha = true;\n      }\n    }\n  }\n\n  this.hasAlpha = false; // default to no transparent draw\n\n  if ('opacity' in options) {\n    this.opacity = fixOpacity(options.opacity);\n\n    if (this.opacity < 1) {\n      this.hasAlpha = true;\n    }\n  } //Set dirty flag\n\n\n  this.dirty = true; //Create new buffers\n\n  var points = options.position; //Text font\n\n  var font = options.font || 'normal';\n  var alignment = options.alignment || [0, 0];\n  var alignmentX;\n  var alignmentY;\n\n  if (alignment.length === 2) {\n    alignmentX = alignment[0];\n    alignmentY = alignment[1];\n  } else {\n    alignmentX = [];\n    alignmentY = [];\n\n    for (var i = 0; i < alignment.length; ++i) {\n      alignmentX[i] = alignment[i][0];\n      alignmentY[i] = alignment[i][1];\n    }\n  } //Bounds\n\n\n  var lowerBound = [Infinity, Infinity, Infinity];\n  var upperBound = [-Infinity, -Infinity, -Infinity]; //Unpack options\n\n  var glyphs = options.glyph;\n  var colors = options.color;\n  var sizes = options.size;\n  var angles = options.angle;\n  var lineColors = options.lineColor; //Picking geometry\n\n  var pickCounter = -1; //First do pass to compute buffer sizes\n\n  var triVertexCount = 0;\n  var lineVertexCount = 0;\n  var numPoints = 0;\n\n  if (points.length) {\n    //Count number of points and buffer size\n    numPoints = points.length;\n\n    count_loop: for (var i = 0; i < numPoints; ++i) {\n      var x = points[i];\n\n      for (var j = 0; j < 3; ++j) {\n        if (isNaN(x[j]) || !isFinite(x[j])) {\n          continue count_loop;\n        }\n      }\n\n      var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);\n      var glyphMesh = glyphData.mesh;\n      var glyphLines = glyphData.lines;\n      var glyphBounds = glyphData.bounds;\n      triVertexCount += glyphMesh.cells.length * 3;\n      lineVertexCount += glyphLines.edges.length * 2;\n    }\n  }\n\n  var vertexCount = triVertexCount + lineVertexCount; //Preallocate data\n\n  var positionArray = pool.mallocFloat(3 * vertexCount);\n  var colorArray = pool.mallocFloat(4 * vertexCount);\n  var glyphArray = pool.mallocFloat(2 * vertexCount);\n  var idArray = pool.mallocUint32(vertexCount);\n\n  if (vertexCount > 0) {\n    var triOffset = 0;\n    var lineOffset = triVertexCount;\n    var color = [0, 0, 0, 1];\n    var lineColor = [0, 0, 0, 1];\n    var isColorArray = Array.isArray(colors) && Array.isArray(colors[0]);\n    var isLineColorArray = Array.isArray(lineColors) && Array.isArray(lineColors[0]);\n\n    fill_loop: for (var i = 0; i < numPoints; ++i) {\n      //Increment pickCounter\n      pickCounter += 1;\n      var x = points[i];\n\n      for (var j = 0; j < 3; ++j) {\n        if (isNaN(x[j]) || !isFinite(x[j])) {\n          continue fill_loop;\n        }\n\n        upperBound[j] = Math.max(upperBound[j], x[j]);\n        lowerBound[j] = Math.min(lowerBound[j], x[j]);\n      }\n\n      var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);\n      var glyphMesh = glyphData.mesh;\n      var glyphLines = glyphData.lines;\n      var glyphBounds = glyphData.bounds;\n      var glyphVisible = glyphData.visible; //Get color\n\n      if (!glyphVisible) color = [1, 1, 1, 0];else if (Array.isArray(colors)) {\n        var c;\n\n        if (isColorArray) {\n          if (i < colors.length) {\n            c = colors[i];\n          } else {\n            c = [0, 0, 0, 0];\n          }\n        } else {\n          c = colors;\n        }\n\n        if (c.length === 3) {\n          for (var j = 0; j < 3; ++j) {\n            color[j] = c[j];\n          }\n\n          color[3] = 1;\n        } else if (c.length === 4) {\n          for (var j = 0; j < 4; ++j) {\n            color[j] = c[j];\n          }\n\n          if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n        }\n      } else {\n        color[0] = color[1] = color[2] = 0;\n        color[3] = 1;\n      } //Get lineColor\n\n      if (!glyphVisible) lineColor = [1, 1, 1, 0];else if (Array.isArray(lineColors)) {\n        var c;\n\n        if (isLineColorArray) {\n          if (i < lineColors.length) {\n            c = lineColors[i];\n          } else {\n            c = [0, 0, 0, 0];\n          }\n        } else {\n          c = lineColors;\n        }\n\n        if (c.length === 3) {\n          for (var j = 0; j < 3; ++j) {\n            lineColor[j] = c[j];\n          }\n\n          lineColor[j] = 1;\n        } else if (c.length === 4) {\n          for (var j = 0; j < 4; ++j) {\n            lineColor[j] = c[j];\n          }\n\n          if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n        }\n      } else {\n        lineColor[0] = lineColor[1] = lineColor[2] = 0;\n        lineColor[3] = 1;\n      }\n      var size = 0.5;\n      if (!glyphVisible) size = 0.0;else if (Array.isArray(sizes)) {\n        if (i < sizes.length) {\n          size = +sizes[i];\n        } else {\n          size = 12;\n        }\n      } else if (sizes) {\n        size = +sizes;\n      } else if (this.useOrtho) {\n        size = 12;\n      }\n      var angle = 0;\n\n      if (Array.isArray(angles)) {\n        if (i < angles.length) {\n          angle = +angles[i];\n        } else {\n          angle = 0;\n        }\n      } else if (angles) {\n        angle = +angles;\n      } //Loop through markers and append to buffers\n\n\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      var x = points[i];\n\n      for (var j = 0; j < 3; ++j) {\n        upperBound[j] = Math.max(upperBound[j], x[j]);\n        lowerBound[j] = Math.min(lowerBound[j], x[j]);\n      } //Calculate text offset\n\n\n      var textOffsetX = alignmentX;\n      var textOffsetY = alignmentY;\n      var textOffsetX = 0;\n\n      if (Array.isArray(alignmentX)) {\n        if (i < alignmentX.length) {\n          textOffsetX = alignmentX[i];\n        } else {\n          textOffsetX = 0;\n        }\n      } else if (alignmentX) {\n        textOffsetX = alignmentX;\n      }\n\n      var textOffsetY = 0;\n\n      if (Array.isArray(alignmentY)) {\n        if (i < alignmentY.length) {\n          textOffsetY = alignmentY[i];\n        } else {\n          textOffsetY = 0;\n        }\n      } else if (alignmentY) {\n        textOffsetY = alignmentY;\n      }\n\n      textOffsetX *= textOffsetX > 0 ? 1 - glyphBounds[0][0] : textOffsetX < 0 ? 1 + glyphBounds[1][0] : 1;\n      textOffsetY *= textOffsetY > 0 ? 1 - glyphBounds[0][1] : textOffsetY < 0 ? 1 + glyphBounds[1][1] : 1;\n      var textOffset = [textOffsetX, textOffsetY]; //Write out inner marker\n\n      var cells = glyphMesh.cells || [];\n      var verts = glyphMesh.positions || [];\n\n      for (var j = 0; j < cells.length; ++j) {\n        var cell = cells[j];\n\n        for (var k = 0; k < 3; ++k) {\n          for (var l = 0; l < 3; ++l) {\n            positionArray[3 * triOffset + l] = x[l];\n          }\n\n          for (var l = 0; l < 4; ++l) {\n            colorArray[4 * triOffset + l] = color[l];\n          }\n\n          idArray[triOffset] = pickCounter;\n          var p = verts[cell[k]];\n          glyphArray[2 * triOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);\n          glyphArray[2 * triOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);\n          triOffset += 1;\n        }\n      }\n\n      var cells = glyphLines.edges;\n      var verts = glyphLines.positions;\n\n      for (var j = 0; j < cells.length; ++j) {\n        var cell = cells[j];\n\n        for (var k = 0; k < 2; ++k) {\n          for (var l = 0; l < 3; ++l) {\n            positionArray[3 * lineOffset + l] = x[l];\n          }\n\n          for (var l = 0; l < 4; ++l) {\n            colorArray[4 * lineOffset + l] = lineColor[l];\n          }\n\n          idArray[lineOffset] = pickCounter;\n          var p = verts[cell[k]];\n          glyphArray[2 * lineOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);\n          glyphArray[2 * lineOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);\n          lineOffset += 1;\n        }\n      }\n    }\n  } //Update bounds\n\n\n  this.bounds = [lowerBound, upperBound]; //Save points\n\n  this.points = points; //Save number of points\n\n  this.pointCount = points.length; //Update vertex counts\n\n  this.vertexCount = triVertexCount;\n  this.lineVertexCount = lineVertexCount;\n  this.pointBuffer.update(positionArray);\n  this.colorBuffer.update(colorArray);\n  this.glyphBuffer.update(glyphArray); //this.idBuffer.update(new Uint32Array(idArray))\n\n  this.idBuffer.update(idArray);\n  pool.free(positionArray);\n  pool.free(colorArray);\n  pool.free(glyphArray);\n  pool.free(idArray);\n};\n\nproto.dispose = function () {\n  //Shaders\n  this.shader.dispose();\n  this.orthoShader.dispose();\n  this.pickPerspectiveShader.dispose();\n  this.pickOrthoShader.dispose(); //Vertex array\n\n  this.vao.dispose(); //Buffers\n\n  this.pointBuffer.dispose();\n  this.colorBuffer.dispose();\n  this.glyphBuffer.dispose();\n  this.idBuffer.dispose();\n};\n\nfunction createPointCloud(options) {\n  var gl = options.gl;\n  var shader = shaders.createPerspective(gl);\n  var orthoShader = shaders.createOrtho(gl);\n  var projectShader = shaders.createProject(gl);\n  var pickPerspectiveShader = shaders.createPickPerspective(gl);\n  var pickOrthoShader = shaders.createPickOrtho(gl);\n  var pickProjectShader = shaders.createPickProject(gl);\n  var pointBuffer = createBuffer(gl);\n  var colorBuffer = createBuffer(gl);\n  var glyphBuffer = createBuffer(gl);\n  var idBuffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    buffer: pointBuffer,\n    size: 3,\n    type: gl.FLOAT\n  }, {\n    buffer: colorBuffer,\n    size: 4,\n    type: gl.FLOAT\n  }, {\n    buffer: glyphBuffer,\n    size: 2,\n    type: gl.FLOAT\n  }, {\n    buffer: idBuffer,\n    size: 4,\n    type: gl.UNSIGNED_BYTE,\n    normalized: true\n  }]);\n  var pointCloud = new PointCloud(gl, shader, orthoShader, projectShader, pointBuffer, colorBuffer, glyphBuffer, idBuffer, vao, pickPerspectiveShader, pickOrthoShader, pickProjectShader);\n  pointCloud.update(options);\n  return pointCloud;\n}","map":null,"metadata":{},"sourceType":"script"}