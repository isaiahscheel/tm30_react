{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar c = require('./constants');\n\nvar d3 = require('d3');\n\nvar keyFun = require('../../lib/gup').keyFun;\n\nvar repeat = require('../../lib/gup').repeat;\n\nvar sortAsc = require('../../lib').sorterAsc;\n\nvar snapRatio = c.bar.snapRatio;\n\nfunction snapOvershoot(v, vAdjacent) {\n  return v * (1 - snapRatio) + vAdjacent * snapRatio;\n}\n\nvar snapClose = c.bar.snapClose;\n\nfunction closeToCovering(v, vAdjacent) {\n  return v * (1 - snapClose) + vAdjacent * snapClose;\n} // snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\n\n\nfunction ordinalScaleSnap(isHigh, a, v, existingRanges) {\n  if (overlappingExisting(v, existingRanges)) return v;\n  var dir = isHigh ? -1 : 1;\n  var first = 0;\n  var last = a.length - 1;\n\n  if (dir < 0) {\n    var tmp = first;\n    first = last;\n    last = tmp;\n  }\n\n  var aHere = a[first];\n  var aPrev = aHere;\n\n  for (var i = first; dir * i < dir * last; i += dir) {\n    var nextI = i + dir;\n    var aNext = a[nextI]; // very close to the previous - snap down to it\n\n    if (dir * v < dir * closeToCovering(aHere, aNext)) return snapOvershoot(aHere, aPrev);\n    if (dir * v < dir * aNext || nextI === last) return snapOvershoot(aNext, aHere);\n    aPrev = aHere;\n    aHere = aNext;\n  }\n}\n\nfunction overlappingExisting(v, existingRanges) {\n  for (var i = 0; i < existingRanges.length; i++) {\n    if (v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n  }\n\n  return false;\n}\n\nfunction barHorizontalSetup(selection) {\n  selection.attr('x', -c.bar.captureWidth / 2).attr('width', c.bar.captureWidth);\n}\n\nfunction backgroundBarHorizontalSetup(selection) {\n  selection.attr('visibility', 'visible').style('visibility', 'visible').attr('fill', 'yellow').attr('opacity', 0);\n}\n\nfunction setHighlight(d) {\n  if (!d.brush.filterSpecified) {\n    return '0,' + d.height;\n  }\n\n  var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n  var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n\n  var p, sectionHeight, iNext;\n  var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n\n  for (var i = 0; i < pixelRanges.length; i++) {\n    p = pixelRanges[i];\n    sectionHeight = p[1] - p[0];\n    dashArray.push(currentGap);\n    dashArray.push(sectionHeight);\n    iNext = i + 1;\n\n    if (iNext < pixelRanges.length) {\n      currentGap = pixelRanges[iNext][0] - p[1];\n    }\n  }\n\n  dashArray.push(d.height); // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n  // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n  // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n  // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n\n  return dashArray;\n}\n\nfunction unitToPx(unitRanges, height) {\n  return unitRanges.map(function (pr) {\n    return pr.map(function (v) {\n      return Math.max(0, v * height);\n    }).sort(sortAsc);\n  });\n} // is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\n\n\nfunction getRegion(fPix, y) {\n  var pad = c.bar.handleHeight;\n  if (y > fPix[1] + pad || y < fPix[0] - pad) return;\n  if (y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n  if (y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n  return 'ns';\n}\n\nfunction clearCursor() {\n  d3.select(document.body).style('cursor', null);\n}\n\nfunction styleHighlight(selection) {\n  // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n  // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n  // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n  // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n  selection.attr('stroke-dasharray', setHighlight);\n}\n\nfunction renderHighlight(root, tweenCallback) {\n  var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n  var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n  styleHighlight(barToStyle);\n}\n\nfunction getInterval(d, y) {\n  var b = d.brush;\n  var active = b.filterSpecified;\n  var closestInterval = NaN;\n  var out = {};\n  var i;\n\n  if (active) {\n    var height = d.height;\n    var intervals = b.filter.getConsolidated();\n    var pixIntervals = unitToPx(intervals, height);\n    var hoveredInterval = NaN;\n    var previousInterval = NaN;\n    var nextInterval = NaN;\n\n    for (i = 0; i <= pixIntervals.length; i++) {\n      var p = pixIntervals[i];\n\n      if (p && p[0] <= y && y <= p[1]) {\n        // over a bar\n        hoveredInterval = i;\n        break;\n      } else {\n        // between bars, or before/after the first/last bar\n        previousInterval = i ? i - 1 : NaN;\n\n        if (p && p[0] > y) {\n          nextInterval = i;\n          break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n        }\n      }\n    }\n\n    closestInterval = hoveredInterval;\n\n    if (isNaN(closestInterval)) {\n      if (isNaN(previousInterval) || isNaN(nextInterval)) {\n        closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n      } else {\n        closestInterval = y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y ? previousInterval : nextInterval;\n      }\n    }\n\n    if (!isNaN(closestInterval)) {\n      var fPix = pixIntervals[closestInterval];\n      var region = getRegion(fPix, y);\n\n      if (region) {\n        out.interval = intervals[closestInterval];\n        out.intervalPix = fPix;\n        out.region = region;\n      }\n    }\n  }\n\n  if (d.ordinal && !out.region) {\n    var a = d.unitTickvals;\n    var unitLocation = d.unitToPaddedPx.invert(y);\n\n    for (i = 0; i < a.length; i++) {\n      var rangei = [a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75, a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75];\n\n      if (unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n        out.clickableOrdinalRange = rangei;\n        break;\n      }\n    }\n  }\n\n  return out;\n}\n\nfunction dragstart(lThis, d) {\n  d3.event.sourceEvent.stopPropagation();\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var unitLocation = d.unitToPaddedPx.invert(y);\n  var b = d.brush;\n  var interval = getInterval(d, y);\n  var unitRange = interval.interval;\n  var s = b.svgBrush;\n  s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n\n  s.grabbingBar = interval.region === 'ns';\n\n  if (s.grabbingBar) {\n    var pixelRange = unitRange.map(d.unitToPaddedPx);\n    s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n    s.barLength = pixelRange[1] - pixelRange[0];\n  }\n\n  s.clickableOrdinalRange = interval.clickableOrdinalRange;\n  s.stayingIntervals = d.multiselect && b.filterSpecified ? b.filter.getConsolidated() : [];\n\n  if (unitRange) {\n    s.stayingIntervals = s.stayingIntervals.filter(function (int2) {\n      return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n    });\n  }\n\n  s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n  d.parent.inBrushDrag = true;\n  s.brushStartCallback();\n}\n\nfunction drag(lThis, d) {\n  d3.event.sourceEvent.stopPropagation();\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var s = d.brush.svgBrush;\n  s.wasDragged = true;\n  s._dragging = true;\n\n  if (s.grabbingBar) {\n    // moving the bar\n    s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n  } else {\n    // south/north drag or new bar creation\n    s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n  }\n\n  d.brush.filterSpecified = true;\n  s.extent = s.stayingIntervals.concat([s.newExtent]);\n  s.brushCallback(d);\n  renderHighlight(lThis.parentNode);\n}\n\nfunction dragend(lThis, d) {\n  var brush = d.brush;\n  var filter = brush.filter;\n  var s = brush.svgBrush;\n\n  if (!s._dragging) {\n    // i.e. click\n    // mock zero drag\n    mousemove(lThis, d);\n    drag(lThis, d); // remember it is a click not a drag\n\n    d.brush.svgBrush.wasDragged = false;\n  }\n\n  s._dragging = false;\n  var e = d3.event;\n  e.sourceEvent.stopPropagation();\n  var grabbingBar = s.grabbingBar;\n  s.grabbingBar = false;\n  s.grabLocation = undefined;\n  d.parent.inBrushDrag = false;\n  clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n\n  if (!s.wasDragged) {\n    // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n    s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n\n    if (s.clickableOrdinalRange) {\n      if (brush.filterSpecified && d.multiselect) {\n        s.extent.push(s.clickableOrdinalRange);\n      } else {\n        s.extent = [s.clickableOrdinalRange];\n        brush.filterSpecified = true;\n      }\n    } else if (grabbingBar) {\n      s.extent = s.stayingIntervals;\n\n      if (s.extent.length === 0) {\n        brushClear(brush);\n      }\n    } else {\n      brushClear(brush);\n    }\n\n    s.brushCallback(d);\n    renderHighlight(lThis.parentNode);\n    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n    return; // no need to fuse intervals or snap to ordinals, so we can bail early\n  }\n\n  var mergeIntervals = function () {\n    // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n    // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n    filter.set(filter.getConsolidated());\n  };\n\n  if (d.ordinal) {\n    var a = d.unitTickvals;\n    if (a[a.length - 1] < a[0]) a.reverse();\n    s.newExtent = [ordinalScaleSnap(0, a, s.newExtent[0], s.stayingIntervals), ordinalScaleSnap(1, a, s.newExtent[1], s.stayingIntervals)];\n    var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n    s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n\n    if (!s.extent.length) {\n      brushClear(brush);\n    }\n\n    s.brushCallback(d);\n\n    if (hasNewExtent) {\n      // merging intervals post the snap tween\n      renderHighlight(lThis.parentNode, mergeIntervals);\n    } else {\n      // if no new interval, don't animate, just redraw the highlight immediately\n      mergeIntervals();\n      renderHighlight(lThis.parentNode);\n    }\n  } else {\n    mergeIntervals(); // merging intervals immediately\n  }\n\n  s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n}\n\nfunction mousemove(lThis, d) {\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var interval = getInterval(d, y);\n  var cursor = 'crosshair';\n  if (interval.clickableOrdinalRange) cursor = 'pointer';else if (interval.region) cursor = interval.region + '-resize';\n  d3.select(document.body).style('cursor', cursor);\n}\n\nfunction attachDragBehavior(selection) {\n  // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n  // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n  // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n  selection.on('mousemove', function (d) {\n    d3.event.preventDefault();\n    if (!d.parent.inBrushDrag) mousemove(this, d);\n  }).on('mouseleave', function (d) {\n    if (!d.parent.inBrushDrag) clearCursor();\n  }).call(d3.behavior.drag().on('dragstart', function (d) {\n    dragstart(this, d);\n  }).on('drag', function (d) {\n    drag(this, d);\n  }).on('dragend', function (d) {\n    dragend(this, d);\n  }));\n}\n\nfunction startAsc(a, b) {\n  return a[0] - b[0];\n}\n\nfunction renderAxisBrush(axisBrush) {\n  var background = axisBrush.selectAll('.background').data(repeat);\n  background.enter().append('rect').classed('background', true).call(barHorizontalSetup).call(backgroundBarHorizontalSetup).style('pointer-events', 'auto') // parent pointer events are disabled; we must have it to register events\n  .attr('transform', 'translate(0 ' + c.verticalPadding + ')');\n  background.call(attachDragBehavior).attr('height', function (d) {\n    return d.height - c.verticalPadding;\n  });\n  var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n  highlightShadow.enter().append('line').classed('highlight-shadow', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width + c.bar.strokeWidth).attr('stroke', c.bar.strokeColor).attr('opacity', c.bar.strokeOpacity).attr('stroke-linecap', 'butt');\n  highlightShadow.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n  var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n  highlight.enter().append('line').classed('highlight', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width - c.bar.strokeWidth).attr('stroke', c.bar.fillColor).attr('opacity', c.bar.fillOpacity).attr('stroke-linecap', 'butt');\n  highlight.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n}\n\nfunction ensureAxisBrush(axisOverlays) {\n  var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush).data(repeat, keyFun);\n  axisBrush.enter().append('g').classed(c.cn.axisBrush, true);\n  renderAxisBrush(axisBrush);\n}\n\nfunction getBrushExtent(brush) {\n  return brush.svgBrush.extent.map(function (e) {\n    return e.slice();\n  });\n}\n\nfunction brushClear(brush) {\n  brush.filterSpecified = false;\n  brush.svgBrush.extent = [[-Infinity, Infinity]];\n}\n\nfunction axisBrushMoved(callback) {\n  return function axisBrushMoved(dimension) {\n    var brush = dimension.brush;\n    var extent = getBrushExtent(brush);\n    var newExtent = extent.slice();\n    brush.filter.set(newExtent);\n    callback();\n  };\n}\n\nfunction dedupeRealRanges(intervals) {\n  // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n  // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n  var queue = intervals.slice();\n  var result = [];\n  var currentInterval;\n  var current = queue.shift();\n\n  while (current) {\n    // [].shift === undefined, so we don't descend into an empty array\n    currentInterval = current.slice();\n\n    while ((current = queue.shift()) && current[0] <=\n    /* right-open interval would need `<` */\n    currentInterval[1]) {\n      currentInterval[1] = Math.max(currentInterval[1], current[1]);\n    }\n\n    result.push(currentInterval);\n  }\n\n  return result;\n}\n\nfunction makeFilter() {\n  var filter = [];\n  var consolidated;\n  var bounds;\n  return {\n    set: function (a) {\n      filter = a.map(function (d) {\n        return d.slice().sort(sortAsc);\n      }).sort(startAsc); // handle unselected case\n\n      if (filter.length === 1 && filter[0][0] === -Infinity && filter[0][1] === Infinity) {\n        filter = [[0, -1]];\n      }\n\n      consolidated = dedupeRealRanges(filter);\n      bounds = filter.reduce(function (p, n) {\n        return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n      }, [Infinity, -Infinity]);\n    },\n    get: function () {\n      return filter.slice();\n    },\n    getConsolidated: function () {\n      return consolidated;\n    },\n    getBounds: function () {\n      return bounds;\n    }\n  };\n}\n\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n  var filter = makeFilter();\n  filter.set(initialRange);\n  return {\n    filter: filter,\n    filterSpecified: rangeSpecified,\n    // there's a difference between not filtering and filtering a non-proper subset\n    svgBrush: {\n      extent: [],\n      // this is where the svgBrush writes contents into\n      brushStartCallback: brushStartCallback,\n      brushCallback: axisBrushMoved(brushCallback),\n      brushEndCallback: brushEndCallback\n    }\n  };\n} // for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\n\n\nfunction cleanRanges(ranges, dimension) {\n  if (Array.isArray(ranges[0])) {\n    ranges = ranges.map(function (ri) {\n      return ri.sort(sortAsc);\n    });\n    if (!dimension.multiselect) ranges = [ranges[0]];else ranges = dedupeRealRanges(ranges.sort(startAsc));\n  } else ranges = [ranges.sort(sortAsc)]; // ordinal snapping\n\n\n  if (dimension.tickvals) {\n    var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n    ranges = ranges.map(function (ri) {\n      var rSnapped = [ordinalScaleSnap(0, sortedTickVals, ri[0], []), ordinalScaleSnap(1, sortedTickVals, ri[1], [])];\n      if (rSnapped[1] > rSnapped[0]) return rSnapped;\n    }).filter(function (ri) {\n      return ri;\n    });\n    if (!ranges.length) return;\n  }\n\n  return ranges.length > 1 ? ranges : ranges[0];\n}\n\nmodule.exports = {\n  makeBrush: makeBrush,\n  ensureAxisBrush: ensureAxisBrush,\n  cleanRanges: cleanRanges\n};","map":null,"metadata":{},"sourceType":"script"}