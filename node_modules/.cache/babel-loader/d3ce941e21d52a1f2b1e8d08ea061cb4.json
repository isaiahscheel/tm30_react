{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n/* eslint block-scoped-var: 0*/\n\n/* eslint no-redeclare: 0*/\n'use strict';\n\nmodule.exports = computeTickMarks;\n\nvar Axes = require('../../cartesian/axes');\n\nvar Lib = require('../../../lib');\n\nvar AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];\nvar centerPoint = [0, 0, 0];\n\nfunction contourLevelsFromTicks(ticks) {\n  var result = new Array(3);\n\n  for (var i = 0; i < 3; ++i) {\n    var tlevel = ticks[i];\n    var clevel = new Array(tlevel.length);\n\n    for (var j = 0; j < tlevel.length; ++j) {\n      clevel[j] = tlevel[j].x;\n    }\n\n    result[i] = clevel;\n  }\n\n  return result;\n}\n\nfunction computeTickMarks(scene) {\n  var axesOptions = scene.axesOptions;\n  var glRange = scene.glplot.axesPixels;\n  var sceneLayout = scene.fullSceneLayout;\n  var ticks = [[], [], []];\n\n  for (var i = 0; i < 3; ++i) {\n    var axes = sceneLayout[AXES_NAMES[i]];\n    axes._length = (glRange[i].hi - glRange[i].lo) * glRange[i].pixelsPerDataUnit / scene.dataScale[i];\n\n    if (Math.abs(axes._length) === Infinity || isNaN(axes._length)) {\n      ticks[i] = [];\n    } else {\n      axes._input_range = axes.range.slice();\n      axes.range[0] = glRange[i].lo / scene.dataScale[i];\n      axes.range[1] = glRange[i].hi / scene.dataScale[i];\n      axes._m = 1.0 / (scene.dataScale[i] * glRange[i].pixelsPerDataUnit);\n\n      if (axes.range[0] === axes.range[1]) {\n        axes.range[0] -= 1;\n        axes.range[1] += 1;\n      } // this is necessary to short-circuit the 'y' handling\n      // in autotick part of calcTicks... Treating all axes as 'y' in this case\n      // running the autoticks here, then setting\n      // autoticks to false to get around the 2D handling in calcTicks.\n\n\n      var tickModeCached = axes.tickmode;\n\n      if (axes.tickmode === 'auto') {\n        axes.tickmode = 'linear';\n        var nticks = axes.nticks || Lib.constrain(axes._length / 40, 4, 9);\n        Axes.autoTicks(axes, Math.abs(axes.range[1] - axes.range[0]) / nticks);\n      }\n\n      var dataTicks = Axes.calcTicks(axes);\n\n      for (var j = 0; j < dataTicks.length; ++j) {\n        dataTicks[j].x = dataTicks[j].x * scene.dataScale[i];\n\n        if (axes.type === 'date') {\n          dataTicks[j].text = dataTicks[j].text.replace(/\\<br\\>/g, ' ');\n        }\n      }\n\n      ticks[i] = dataTicks;\n      axes.tickmode = tickModeCached;\n    }\n  }\n\n  axesOptions.ticks = ticks; // Calculate tick lengths dynamically\n\n  for (var i = 0; i < 3; ++i) {\n    centerPoint[i] = 0.5 * (scene.glplot.bounds[0][i] + scene.glplot.bounds[1][i]);\n\n    for (var j = 0; j < 2; ++j) {\n      axesOptions.bounds[j][i] = scene.glplot.bounds[j][i];\n    }\n  }\n\n  scene.contourLevels = contourLevelsFromTicks(ticks);\n}","map":null,"metadata":{},"sourceType":"script"}