{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar getTraceColor = require('../scatter/get_trace_color');\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var stash = cd[0].t;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var x = stash.x;\n  var y = stash.y;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var maxDistance = pointData.distance;\n  var ids; // FIXME: make sure this is a proper way to calc search radius\n\n  if (stash.tree) {\n    var xl = xa.p2c(xpx - maxDistance);\n    var xr = xa.p2c(xpx + maxDistance);\n    var yl = ya.p2c(ypx - maxDistance);\n    var yr = ya.p2c(ypx + maxDistance);\n\n    if (hovermode === 'x') {\n      ids = stash.tree.range(Math.min(xl, xr), Math.min(ya._rl[0], ya._rl[1]), Math.max(xl, xr), Math.max(ya._rl[0], ya._rl[1]));\n    } else {\n      ids = stash.tree.range(Math.min(xl, xr), Math.min(yl, yr), Math.max(xl, xr), Math.max(yl, yr));\n    }\n  } else {\n    ids = stash.ids;\n  } // pick the id closest to the point\n  // note that point possibly may not be found\n\n\n  var id, ptx, pty, i, dx, dy, dist, dxy;\n  var minDist = maxDistance;\n\n  if (hovermode === 'x') {\n    for (i = 0; i < ids.length; i++) {\n      ptx = x[ids[i]];\n      dx = Math.abs(xa.c2p(ptx) - xpx);\n\n      if (dx < minDist) {\n        minDist = dx;\n        dy = ya.c2p(y[ids[i]]) - ypx;\n        dxy = Math.sqrt(dx * dx + dy * dy);\n        id = ids[i];\n      }\n    }\n  } else {\n    for (i = ids.length - 1; i > -1; i--) {\n      ptx = x[ids[i]];\n      pty = y[ids[i]];\n      dx = xa.c2p(ptx) - xpx;\n      dy = ya.c2p(pty) - ypx;\n      dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist < minDist) {\n        minDist = dxy = dist;\n        id = ids[i];\n      }\n    }\n  }\n\n  pointData.index = id;\n  pointData.distance = minDist;\n  pointData.dxy = dxy;\n  if (id === undefined) return [pointData];\n  return [calcHover(pointData, x, y, trace)];\n}\n\nfunction calcHover(pointData, x, y, trace) {\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var minDist = pointData.distance;\n  var dxy = pointData.dxy;\n  var id = pointData.index; // the closest data point\n\n  var di = {\n    pointNumber: id,\n    x: x[id],\n    y: y[id]\n  }; // that is single-item arrays_to_calcdata excerpt, since we are doing it for a single point and we don't have to do it beforehead for 1e6 points\n\n  di.tx = Array.isArray(trace.text) ? trace.text[id] : trace.text;\n  di.htx = Array.isArray(trace.hovertext) ? trace.hovertext[id] : trace.hovertext;\n  di.data = Array.isArray(trace.customdata) ? trace.customdata[id] : trace.customdata;\n  di.tp = Array.isArray(trace.textposition) ? trace.textposition[id] : trace.textposition;\n  var font = trace.textfont;\n\n  if (font) {\n    di.ts = Array.isArray(font.size) ? font.size[id] : font.size;\n    di.tc = Array.isArray(font.color) ? font.color[id] : font.color;\n    di.tf = Array.isArray(font.family) ? font.family[id] : font.family;\n  }\n\n  var marker = trace.marker;\n\n  if (marker) {\n    di.ms = Lib.isArrayOrTypedArray(marker.size) ? marker.size[id] : marker.size;\n    di.mo = Lib.isArrayOrTypedArray(marker.opacity) ? marker.opacity[id] : marker.opacity;\n    di.mx = Array.isArray(marker.symbol) ? marker.symbol[id] : marker.symbol;\n    di.mc = Lib.isArrayOrTypedArray(marker.color) ? marker.color[id] : marker.color;\n  }\n\n  var line = marker && marker.line;\n\n  if (line) {\n    di.mlc = Array.isArray(line.color) ? line.color[id] : line.color;\n    di.mlw = Lib.isArrayOrTypedArray(line.width) ? line.width[id] : line.width;\n  }\n\n  var grad = marker && marker.gradient;\n\n  if (grad && grad.type !== 'none') {\n    di.mgt = Array.isArray(grad.type) ? grad.type[id] : grad.type;\n    di.mgc = Array.isArray(grad.color) ? grad.color[id] : grad.color;\n  }\n\n  var xp = xa.c2p(di.x, true);\n  var yp = ya.c2p(di.y, true);\n  var rad = di.mrc || 1;\n  var hoverlabel = trace.hoverlabel;\n\n  if (hoverlabel) {\n    di.hbg = Array.isArray(hoverlabel.bgcolor) ? hoverlabel.bgcolor[id] : hoverlabel.bgcolor;\n    di.hbc = Array.isArray(hoverlabel.bordercolor) ? hoverlabel.bordercolor[id] : hoverlabel.bordercolor;\n    di.hts = Array.isArray(hoverlabel.font.size) ? hoverlabel.font.size[id] : hoverlabel.font.size;\n    di.htc = Array.isArray(hoverlabel.font.color) ? hoverlabel.font.color[id] : hoverlabel.font.color;\n    di.htf = Array.isArray(hoverlabel.font.family) ? hoverlabel.font.family[id] : hoverlabel.font.family;\n    di.hnl = Array.isArray(hoverlabel.namelength) ? hoverlabel.namelength[id] : hoverlabel.namelength;\n  }\n\n  var hoverinfo = trace.hoverinfo;\n\n  if (hoverinfo) {\n    di.hi = Array.isArray(hoverinfo) ? hoverinfo[id] : hoverinfo;\n  }\n\n  var hovertemplate = trace.hovertemplate;\n\n  if (hovertemplate) {\n    di.ht = Array.isArray(hovertemplate) ? hovertemplate[id] : hovertemplate;\n  }\n\n  var fakeCd = {};\n  fakeCd[pointData.index] = di;\n  var pointData2 = Lib.extendFlat({}, pointData, {\n    color: getTraceColor(trace, di),\n    x0: xp - rad,\n    x1: xp + rad,\n    xLabelVal: di.x,\n    y0: yp - rad,\n    y1: yp + rad,\n    yLabelVal: di.y,\n    cd: fakeCd,\n    distance: minDist,\n    spikeDistance: dxy,\n    hovertemplate: di.ht\n  });\n  if (di.htx) pointData2.text = di.htx;else if (di.tx) pointData2.text = di.tx;else if (trace.text) pointData2.text = trace.text;\n  Lib.fillText(di, trace, pointData2);\n  Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData2);\n  return pointData2;\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  calcHover: calcHover\n};","map":null,"metadata":{},"sourceType":"script"}