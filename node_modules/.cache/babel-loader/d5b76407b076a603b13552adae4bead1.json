{"ast":null,"code":"'use strict';\n\nvar Font = require('css-font');\n\nvar pick = require('pick-by-alias');\n\nvar createRegl = require('regl');\n\nvar createGl = require('gl-util/context');\n\nvar WeakMap = require('es6-weak-map');\n\nvar rgba = require('color-normalize');\n\nvar fontAtlas = require('font-atlas');\n\nvar pool = require('typedarray-pool');\n\nvar parseRect = require('parse-rect');\n\nvar isObj = require('is-plain-obj');\n\nvar parseUnit = require('parse-unit');\n\nvar px = require('to-px');\n\nvar kerning = require('detect-kerning');\n\nvar extend = require('object-assign');\n\nvar metrics = require('font-measure');\n\nvar flatten = require('flatten-vertex-data');\n\nvar ref = require('bit-twiddle');\n\nvar nextPow2 = ref.nextPow2;\nvar shaderCache = new WeakMap(); // Safari does not support font-stretch\n\nvar isStretchSupported = false;\n\nif (document.body) {\n  var el = document.body.appendChild(document.createElement('div'));\n  el.style.font = 'italic small-caps bold condensed 16px/2 cursive';\n\n  if (getComputedStyle(el).fontStretch) {\n    isStretchSupported = true;\n  }\n\n  document.body.removeChild(el);\n}\n\nvar GlText = function GlText(o) {\n  if (isRegl(o)) {\n    o = {\n      regl: o\n    };\n    this.gl = o.regl._gl;\n  } else {\n    this.gl = createGl(o);\n  }\n\n  this.shader = shaderCache.get(this.gl);\n\n  if (!this.shader) {\n    this.regl = o.regl || createRegl({\n      gl: this.gl\n    });\n  } else {\n    this.regl = this.shader.regl;\n  }\n\n  this.charBuffer = this.regl.buffer({\n    type: 'uint8',\n    usage: 'stream'\n  });\n  this.sizeBuffer = this.regl.buffer({\n    type: 'float',\n    usage: 'stream'\n  });\n\n  if (!this.shader) {\n    this.shader = this.createShader();\n    shaderCache.set(this.gl, this.shader);\n  }\n\n  this.batch = []; // multiple options initial state\n\n  this.fontSize = [];\n  this.font = [];\n  this.fontAtlas = [];\n  this.draw = this.shader.draw.bind(this);\n\n  this.render = function () {\n    // FIXME: add Safari regl report here:\n    // charBuffer and width just do not trigger\n    this.regl._refresh();\n\n    this.draw(this.batch);\n  };\n\n  this.canvas = this.gl.canvas;\n  this.update(isObj(o) ? o : {});\n};\n\nGlText.prototype.createShader = function createShader() {\n  var regl = this.regl; // FIXME: store 2 shader versions: with normal viewport and without\n  // draw texture method\n\n  var draw = regl({\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 1],\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    stencil: {\n      enable: false\n    },\n    depth: {\n      enable: false\n    },\n    count: regl.prop('count'),\n    offset: regl.prop('offset'),\n    attributes: {\n      charOffset: {\n        offset: 4,\n        stride: 8,\n        buffer: regl.this('sizeBuffer')\n      },\n      width: {\n        offset: 0,\n        stride: 8,\n        buffer: regl.this('sizeBuffer')\n      },\n      char: regl.this('charBuffer'),\n      position: regl.this('position')\n    },\n    uniforms: {\n      atlasSize: function (c, p) {\n        return [p.atlas.width, p.atlas.height];\n      },\n      atlasDim: function (c, p) {\n        return [p.atlas.cols, p.atlas.rows];\n      },\n      atlas: function (c, p) {\n        return p.atlas.texture;\n      },\n      charStep: function (c, p) {\n        return p.atlas.step;\n      },\n      em: function (c, p) {\n        return p.atlas.em;\n      },\n      color: regl.prop('color'),\n      opacity: regl.prop('opacity'),\n      viewport: regl.this('viewportArray'),\n      scale: regl.this('scale'),\n      align: regl.prop('align'),\n      baseline: regl.prop('baseline'),\n      translate: regl.this('translate'),\n      positionOffset: regl.prop('positionOffset')\n    },\n    primitive: 'points',\n    viewport: regl.this('viewport'),\n    vert: \"\\n\\t\\t\\tprecision highp float;\\n\\t\\t\\tattribute float width, charOffset, char;\\n\\t\\t\\tattribute vec2 position;\\n\\t\\t\\tuniform float fontSize, charStep, em, align, baseline;\\n\\t\\t\\tuniform vec4 viewport;\\n\\t\\t\\tuniform vec4 color;\\n\\t\\t\\tuniform vec2 atlasSize, atlasDim, scale, translate, positionOffset;\\n\\t\\t\\tvarying vec2 charCoord, charId;\\n\\t\\t\\tvarying float charWidth;\\n\\t\\t\\tvarying vec4 fontColor;\\n\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\" + (!GlText.normalViewport ? 'vec2 positionOffset = vec2(positionOffset.x,- positionOffset.y);' : '') + \"\\n\\n\\t\\t\\t\\tvec2 offset = floor(em * (vec2(align + charOffset, baseline)\\n\\t\\t\\t\\t\\t+ positionOffset))\\n\\t\\t\\t\\t\\t/ (viewport.zw * scale.xy);\\n\\n\\t\\t\\t\\tvec2 position = (position + translate) * scale;\\n\\t\\t\\t\\tposition += offset * scale;\\n\\n\\t\\t\\t\\t\" + (GlText.normalViewport ? 'position.y = 1. - position.y;' : '') + \"\\n\\n\\t\\t\\t\\tcharCoord = position * viewport.zw + viewport.xy;\\n\\n\\t\\t\\t\\tgl_Position = vec4(position * 2. - 1., 0, 1);\\n\\n\\t\\t\\t\\tgl_PointSize = charStep;\\n\\n\\t\\t\\t\\tcharId.x = mod(char, atlasDim.x);\\n\\t\\t\\t\\tcharId.y = floor(char / atlasDim.x);\\n\\n\\t\\t\\t\\tcharWidth = width * em;\\n\\n\\t\\t\\t\\tfontColor = color / 255.;\\n\\t\\t\\t}\",\n    frag: \"\\n\\t\\t\\tprecision highp float;\\n\\t\\t\\tuniform sampler2D atlas;\\n\\t\\t\\tuniform float fontSize, charStep, opacity;\\n\\t\\t\\tuniform vec2 atlasSize;\\n\\t\\t\\tuniform vec4 viewport;\\n\\t\\t\\tvarying vec4 fontColor;\\n\\t\\t\\tvarying vec2 charCoord, charId;\\n\\t\\t\\tvarying float charWidth;\\n\\n\\t\\t\\tfloat lightness(vec4 color) {\\n\\t\\t\\t\\treturn color.r * 0.299 + color.g * 0.587 + color.b * 0.114;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main () {\\n\\t\\t\\t\\tvec2 uv = gl_FragCoord.xy - charCoord + charStep * .5;\\n\\t\\t\\t\\tfloat halfCharStep = floor(charStep * .5 + .5);\\n\\n\\t\\t\\t\\t// invert y and shift by 1px (FF expecially needs that)\\n\\t\\t\\t\\tuv.y = charStep - uv.y;\\n\\n\\t\\t\\t\\t// ignore points outside of character bounding box\\n\\t\\t\\t\\tfloat halfCharWidth = ceil(charWidth * .5);\\n\\t\\t\\t\\tif (floor(uv.x) > halfCharStep + halfCharWidth ||\\n\\t\\t\\t\\t\\tfloor(uv.x) < halfCharStep - halfCharWidth) return;\\n\\n\\t\\t\\t\\tuv += charId * charStep;\\n\\t\\t\\t\\tuv = uv / atlasSize;\\n\\n\\t\\t\\t\\tvec4 color = fontColor;\\n\\t\\t\\t\\tvec4 mask = texture2D(atlas, uv);\\n\\n\\t\\t\\t\\tfloat maskY = lightness(mask);\\n\\t\\t\\t\\t// float colorY = lightness(color);\\n\\t\\t\\t\\tcolor.a *= maskY;\\n\\t\\t\\t\\tcolor.a *= opacity;\\n\\n\\t\\t\\t\\t// color.a += .1;\\n\\n\\t\\t\\t\\t// antialiasing, see yiq color space y-channel formula\\n\\t\\t\\t\\t// color.rgb += (1. - color.rgb) * (1. - mask.rgb);\\n\\n\\t\\t\\t\\tgl_FragColor = color;\\n\\t\\t\\t}\"\n  }); // per font-size atlas\n\n  var atlas = {};\n  return {\n    regl: regl,\n    draw: draw,\n    atlas: atlas\n  };\n};\n\nGlText.prototype.update = function update(o) {\n  var this$1 = this;\n\n  if (typeof o === 'string') {\n    o = {\n      text: o\n    };\n  } else if (!o) {\n    return;\n  } // FIXME: make this a static transform or more general approact\n\n\n  o = pick(o, {\n    position: 'position positions coord coords coordinates',\n    font: 'font fontFace fontface typeface cssFont css-font family fontFamily',\n    fontSize: 'fontSize fontsize size font-size',\n    text: 'text texts chars characters value values symbols',\n    align: 'align alignment textAlign textbaseline',\n    baseline: 'baseline textBaseline textbaseline',\n    direction: 'dir direction textDirection',\n    color: 'color colour fill fill-color fillColor textColor textcolor',\n    kerning: 'kerning kern',\n    range: 'range dataBox',\n    viewport: 'vp viewport viewBox viewbox viewPort',\n    opacity: 'opacity alpha transparency visible visibility opaque',\n    offset: 'offset positionOffset padding shift indent indentation'\n  }, true);\n\n  if (o.opacity != null) {\n    if (Array.isArray(o.opacity)) {\n      this.opacity = o.opacity.map(function (o) {\n        return parseFloat(o);\n      });\n    } else {\n      this.opacity = parseFloat(o.opacity);\n    }\n  }\n\n  if (o.viewport != null) {\n    this.viewport = parseRect(o.viewport);\n\n    if (GlText.normalViewport) {\n      this.viewport.y = this.canvas.height - this.viewport.y - this.viewport.height;\n    }\n\n    this.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height];\n  }\n\n  if (this.viewport == null) {\n    this.viewport = {\n      x: 0,\n      y: 0,\n      width: this.gl.drawingBufferWidth,\n      height: this.gl.drawingBufferHeight\n    };\n    this.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height];\n  }\n\n  if (o.kerning != null) {\n    this.kerning = o.kerning;\n  }\n\n  if (o.offset != null) {\n    if (typeof o.offset === 'number') {\n      o.offset = [o.offset, 0];\n    }\n\n    this.positionOffset = flatten(o.offset);\n  }\n\n  if (o.direction) {\n    this.direction = o.direction;\n  }\n\n  if (o.range) {\n    this.range = o.range;\n    this.scale = [1 / (o.range[2] - o.range[0]), 1 / (o.range[3] - o.range[1])];\n    this.translate = [-o.range[0], -o.range[1]];\n  }\n\n  if (o.scale) {\n    this.scale = o.scale;\n  }\n\n  if (o.translate) {\n    this.translate = o.translate;\n  } // default scale corresponds to viewport\n\n\n  if (!this.scale) {\n    this.scale = [1 / this.viewport.width, 1 / this.viewport.height];\n  }\n\n  if (!this.translate) {\n    this.translate = [0, 0];\n  }\n\n  if (!this.font.length && !o.font) {\n    o.font = GlText.baseFontSize + 'px sans-serif';\n  } // normalize font caching string\n\n\n  var newFont = false,\n      newFontSize = false; // obtain new font data\n\n  if (o.font) {\n    (Array.isArray(o.font) ? o.font : [o.font]).forEach(function (font, i) {\n      // normalize font\n      if (typeof font === 'string') {\n        try {\n          font = Font.parse(font);\n        } catch (e) {\n          font = Font.parse(GlText.baseFontSize + 'px ' + font);\n        }\n      } else {\n        font = Font.parse(Font.stringify(font));\n      }\n\n      var baseString = Font.stringify({\n        size: GlText.baseFontSize,\n        family: font.family,\n        stretch: isStretchSupported ? font.stretch : undefined,\n        variant: font.variant,\n        weight: font.weight,\n        style: font.style\n      });\n      var unit = parseUnit(font.size);\n      var fs = Math.round(unit[0] * px(unit[1]));\n\n      if (fs !== this$1.fontSize[i]) {\n        newFontSize = true;\n        this$1.fontSize[i] = fs;\n      } // calc new font metrics/atlas\n\n\n      if (!this$1.font[i] || baseString != this$1.font[i].baseString) {\n        newFont = true; // obtain font cache or create one\n\n        this$1.font[i] = GlText.fonts[baseString];\n\n        if (!this$1.font[i]) {\n          var family = font.family.join(', ');\n          var style = [font.style];\n\n          if (font.style != font.variant) {\n            style.push(font.variant);\n          }\n\n          if (font.variant != font.weight) {\n            style.push(font.weight);\n          }\n\n          if (isStretchSupported && font.weight != font.stretch) {\n            style.push(font.stretch);\n          }\n\n          this$1.font[i] = {\n            baseString: baseString,\n            // typeface\n            family: family,\n            weight: font.weight,\n            stretch: font.stretch,\n            style: font.style,\n            variant: font.variant,\n            // widths of characters\n            width: {},\n            // kernin pairs offsets\n            kerning: {},\n            metrics: metrics(family, {\n              origin: 'top',\n              fontSize: GlText.baseFontSize,\n              fontStyle: style.join(' ')\n            })\n          };\n          GlText.fonts[baseString] = this$1.font[i];\n        }\n      }\n    });\n  } // FIXME: make independend font-size\n  // if (o.fontSize) {\n  // let unit = parseUnit(o.fontSize)\n  // let fs = Math.round(unit[0] * px(unit[1]))\n  // if (fs != this.fontSize) {\n  // \tnewFontSize = true\n  // \tthis.fontSize = fs\n  // }\n  // }\n\n\n  if (newFont || newFontSize) {\n    this.font.forEach(function (font, i) {\n      var fontString = Font.stringify({\n        size: this$1.fontSize[i],\n        family: font.family,\n        stretch: isStretchSupported ? font.stretch : undefined,\n        variant: font.variant,\n        weight: font.weight,\n        style: font.style\n      }); // calc new font size atlas\n\n      this$1.fontAtlas[i] = this$1.shader.atlas[fontString];\n\n      if (!this$1.fontAtlas[i]) {\n        var metrics = font.metrics;\n        this$1.shader.atlas[fontString] = this$1.fontAtlas[i] = {\n          fontString: fontString,\n          // even step is better for rendered characters\n          step: Math.ceil(this$1.fontSize[i] * metrics.bottom * .5) * 2,\n          em: this$1.fontSize[i],\n          cols: 0,\n          rows: 0,\n          height: 0,\n          width: 0,\n          chars: [],\n          ids: {},\n          texture: this$1.regl.texture()\n        };\n      } // bump atlas characters\n\n\n      if (o.text == null) {\n        o.text = this$1.text;\n      }\n    });\n  } // if multiple positions - duplicate text arguments\n  // FIXME: this possibly can be done better to avoid array spawn\n\n\n  if (typeof o.text === 'string' && o.position && o.position.length > 2) {\n    var textArray = Array(o.position.length * .5);\n\n    for (var i = 0; i < textArray.length; i++) {\n      textArray[i] = o.text;\n    }\n\n    o.text = textArray;\n  } // calculate offsets for the new font/text\n\n\n  var newAtlasChars;\n\n  if (o.text != null || newFont) {\n    // FIXME: ignore spaces\n    // text offsets within the text buffer\n    this.textOffsets = [0];\n\n    if (Array.isArray(o.text)) {\n      this.count = o.text[0].length;\n      this.counts = [this.count];\n\n      for (var i$1 = 1; i$1 < o.text.length; i$1++) {\n        this.textOffsets[i$1] = this.textOffsets[i$1 - 1] + o.text[i$1 - 1].length;\n        this.count += o.text[i$1].length;\n        this.counts.push(o.text[i$1].length);\n      }\n\n      this.text = o.text.join('');\n    } else {\n      this.text = o.text;\n      this.count = this.text.length;\n      this.counts = [this.count];\n    }\n\n    newAtlasChars = []; // detect & measure new characters\n\n    this.font.forEach(function (font, idx) {\n      GlText.atlasContext.font = font.baseString;\n      var atlas = this$1.fontAtlas[idx];\n\n      for (var i = 0; i < this$1.text.length; i++) {\n        var char = this$1.text.charAt(i);\n\n        if (atlas.ids[char] == null) {\n          atlas.ids[char] = atlas.chars.length;\n          atlas.chars.push(char);\n          newAtlasChars.push(char);\n        }\n\n        if (font.width[char] == null) {\n          font.width[char] = GlText.atlasContext.measureText(char).width / GlText.baseFontSize; // measure kerning pairs for the new character\n\n          if (this$1.kerning) {\n            var pairs = [];\n\n            for (var baseChar in font.width) {\n              pairs.push(baseChar + char, char + baseChar);\n            }\n\n            extend(font.kerning, kerning(font.family, {\n              pairs: pairs\n            }));\n          }\n        }\n      }\n    });\n  } // create single position buffer (faster than batch or multiple separate instances)\n\n\n  if (o.position) {\n    if (o.position.length > 2) {\n      var flat = !o.position[0].length;\n      var positionData = pool.mallocFloat(this.count * 2);\n\n      for (var i$2 = 0, ptr = 0; i$2 < this.counts.length; i$2++) {\n        var count = this.counts[i$2];\n\n        if (flat) {\n          for (var j = 0; j < count; j++) {\n            positionData[ptr++] = o.position[i$2 * 2];\n            positionData[ptr++] = o.position[i$2 * 2 + 1];\n          }\n        } else {\n          for (var j$1 = 0; j$1 < count; j$1++) {\n            positionData[ptr++] = o.position[i$2][0];\n            positionData[ptr++] = o.position[i$2][1];\n          }\n        }\n      }\n\n      if (this.position.call) {\n        this.position({\n          type: 'float',\n          data: positionData\n        });\n      } else {\n        this.position = this.regl.buffer({\n          type: 'float',\n          data: positionData\n        });\n      }\n\n      pool.freeFloat(positionData);\n    } else {\n      if (this.position.destroy) {\n        this.position.destroy();\n      }\n\n      this.position = {\n        constant: o.position\n      };\n    }\n  } // populate text/offset buffers if font/text has changed\n  // as [charWidth, offset, charWidth, offset...]\n  // that is in em units since font-size can change often\n\n\n  if (o.text || newFont) {\n    var charIds = pool.mallocUint8(this.count);\n    var sizeData = pool.mallocFloat(this.count * 2);\n    this.textWidth = [];\n\n    for (var i$3 = 0, ptr$1 = 0; i$3 < this.counts.length; i$3++) {\n      var count$1 = this.counts[i$3];\n      var font = this.font[i$3] || this.font[0];\n      var atlas = this.fontAtlas[i$3] || this.fontAtlas[0];\n\n      for (var j$2 = 0; j$2 < count$1; j$2++) {\n        var char = this.text.charAt(ptr$1);\n        var prevChar = this.text.charAt(ptr$1 - 1);\n        charIds[ptr$1] = atlas.ids[char];\n        sizeData[ptr$1 * 2] = font.width[char];\n\n        if (j$2) {\n          var prevWidth = sizeData[ptr$1 * 2 - 2];\n          var currWidth = sizeData[ptr$1 * 2];\n          var prevOffset = sizeData[ptr$1 * 2 - 1];\n          var offset = prevOffset + prevWidth * .5 + currWidth * .5;\n\n          if (this.kerning) {\n            var kerning$1 = font.kerning[prevChar + char];\n\n            if (kerning$1) {\n              offset += kerning$1 * 1e-3;\n            }\n          }\n\n          sizeData[ptr$1 * 2 + 1] = offset;\n        } else {\n          sizeData[ptr$1 * 2 + 1] = sizeData[ptr$1 * 2] * .5;\n        }\n\n        ptr$1++;\n      }\n\n      this.textWidth.push(!sizeData.length ? 0 : // last offset + half last width\n      sizeData[ptr$1 * 2 - 2] * .5 + sizeData[ptr$1 * 2 - 1]);\n    } // bump recalc align offset\n\n\n    if (!o.align) {\n      o.align = this.align;\n    }\n\n    this.charBuffer({\n      data: charIds,\n      type: 'uint8',\n      usage: 'stream'\n    });\n    this.sizeBuffer({\n      data: sizeData,\n      type: 'float',\n      usage: 'stream'\n    });\n    pool.freeUint8(charIds);\n    pool.freeFloat(sizeData); // udpate font atlas and texture\n\n    if (newAtlasChars.length) {\n      this.font.forEach(function (font, i) {\n        var atlas = this$1.fontAtlas[i]; // FIXME: insert metrics-based ratio here\n\n        var step = atlas.step;\n        var maxCols = Math.floor(GlText.maxAtlasSize / step);\n        var cols = Math.min(maxCols, atlas.chars.length);\n        var rows = Math.ceil(atlas.chars.length / cols);\n        var atlasWidth = nextPow2(cols * step); // let atlasHeight = Math.min(rows * step + step * .5, GlText.maxAtlasSize);\n\n        var atlasHeight = nextPow2(rows * step);\n        atlas.width = atlasWidth;\n        atlas.height = atlasHeight;\n        atlas.rows = rows;\n        atlas.cols = cols;\n\n        if (!atlas.em) {\n          return;\n        }\n\n        atlas.texture({\n          data: fontAtlas({\n            canvas: GlText.atlasCanvas,\n            font: atlas.fontString,\n            chars: atlas.chars,\n            shape: [atlasWidth, atlasHeight],\n            step: [step, step]\n          })\n        });\n      });\n    }\n  }\n\n  if (o.align) {\n    this.align = o.align;\n    this.alignOffset = this.textWidth.map(function (textWidth, i) {\n      var align = !Array.isArray(this$1.align) ? this$1.align : this$1.align.length > 1 ? this$1.align[i] : this$1.align[0];\n\n      if (typeof align === 'number') {\n        return align;\n      }\n\n      switch (align) {\n        case 'right':\n        case 'end':\n          return -textWidth;\n\n        case 'center':\n        case 'centre':\n        case 'middle':\n          return -textWidth * .5;\n      }\n\n      return 0;\n    });\n  }\n\n  if (this.baseline == null && o.baseline == null) {\n    o.baseline = 0;\n  }\n\n  if (o.baseline != null) {\n    this.baseline = o.baseline;\n\n    if (!Array.isArray(this.baseline)) {\n      this.baseline = [this.baseline];\n    }\n\n    this.baselineOffset = this.baseline.map(function (baseline, i) {\n      var m = (this$1.font[i] || this$1.font[0]).metrics;\n      var base = 0;\n      base += m.bottom * .5;\n\n      if (typeof baseline === 'number') {\n        base += baseline - m.baseline;\n      } else {\n        base += -m[baseline];\n      }\n\n      if (!GlText.normalViewport) {\n        base *= -1;\n      }\n\n      return base;\n    });\n  } // flatten colors to a single uint8 array\n\n\n  if (o.color != null) {\n    if (!o.color) {\n      o.color = 'transparent';\n    } // single color\n\n\n    if (typeof o.color === 'string' || !isNaN(o.color)) {\n      this.color = rgba(o.color, 'uint8');\n    } // array\n    else {\n        var colorData; // flat array\n\n        if (typeof o.color[0] === 'number' && o.color.length > this.counts.length) {\n          var l = o.color.length;\n          colorData = pool.mallocUint8(l);\n          var sub = (o.color.subarray || o.color.slice).bind(o.color);\n\n          for (var i$4 = 0; i$4 < l; i$4 += 4) {\n            colorData.set(rgba(sub(i$4, i$4 + 4), 'uint8'), i$4);\n          }\n        } // nested array\n        else {\n            var l$1 = o.color.length;\n            colorData = pool.mallocUint8(l$1 * 4);\n\n            for (var i$5 = 0; i$5 < l$1; i$5++) {\n              colorData.set(rgba(o.color[i$5] || 0, 'uint8'), i$5 * 4);\n            }\n          }\n\n        this.color = colorData;\n      }\n  } // update render batch\n\n\n  if (o.position || o.text || o.color || o.baseline || o.align || o.font || o.offset || o.opacity) {\n    var isBatch = this.color.length > 4 || this.baselineOffset.length > 1 || this.align && this.align.length > 1 || this.fontAtlas.length > 1 || this.positionOffset.length > 2;\n\n    if (isBatch) {\n      var length = Math.max(this.position.length * .5 || 0, this.color.length * .25 || 0, this.baselineOffset.length || 0, this.alignOffset.length || 0, this.font.length || 0, this.opacity.length || 0, this.positionOffset.length * .5 || 0);\n      this.batch = Array(length);\n\n      for (var i$6 = 0; i$6 < this.batch.length; i$6++) {\n        this.batch[i$6] = {\n          count: this.counts.length > 1 ? this.counts[i$6] : this.counts[0],\n          offset: this.textOffsets.length > 1 ? this.textOffsets[i$6] : this.textOffsets[0],\n          color: !this.color ? [0, 0, 0, 255] : this.color.length <= 4 ? this.color : this.color.subarray(i$6 * 4, i$6 * 4 + 4),\n          opacity: Array.isArray(this.opacity) ? this.opacity[i$6] : this.opacity,\n          baseline: this.baselineOffset[i$6] != null ? this.baselineOffset[i$6] : this.baselineOffset[0],\n          align: !this.align ? 0 : this.alignOffset[i$6] != null ? this.alignOffset[i$6] : this.alignOffset[0],\n          atlas: this.fontAtlas[i$6] || this.fontAtlas[0],\n          positionOffset: this.positionOffset.length > 2 ? this.positionOffset.subarray(i$6 * 2, i$6 * 2 + 2) : this.positionOffset\n        };\n      }\n    } // single-color, single-baseline, single-align batch is faster to render\n    else {\n        if (this.count) {\n          this.batch = [{\n            count: this.count,\n            offset: 0,\n            color: this.color || [0, 0, 0, 255],\n            opacity: Array.isArray(this.opacity) ? this.opacity[0] : this.opacity,\n            baseline: this.baselineOffset[0],\n            align: this.alignOffset ? this.alignOffset[0] : 0,\n            atlas: this.fontAtlas[0],\n            positionOffset: this.positionOffset\n          }];\n        } else {\n          this.batch = [];\n        }\n      }\n  }\n};\n\nGlText.prototype.destroy = function destroy() {// TODO: count instances of atlases and destroy all on null\n}; // defaults\n\n\nGlText.prototype.kerning = true;\nGlText.prototype.position = {\n  constant: new Float32Array(2)\n};\nGlText.prototype.translate = null;\nGlText.prototype.scale = null;\nGlText.prototype.font = null;\nGlText.prototype.text = '';\nGlText.prototype.positionOffset = [0, 0];\nGlText.prototype.opacity = 1;\nGlText.prototype.color = new Uint8Array([0, 0, 0, 255]);\nGlText.prototype.alignOffset = [0, 0]; // whether viewport should be topâ†“bottom 2d one (true) or webgl one (false)\n\nGlText.normalViewport = false; // size of an atlas\n\nGlText.maxAtlasSize = 1024; // font atlas canvas is singleton\n\nGlText.atlasCanvas = document.createElement('canvas');\nGlText.atlasContext = GlText.atlasCanvas.getContext('2d', {\n  alpha: false\n}); // font-size used for metrics, atlas step calculation\n\nGlText.baseFontSize = 64; // fonts storage\n\nGlText.fonts = {}; // max number of different font atlases/textures cached\n// FIXME: enable atlas size limitation via LRU\n// GlText.atlasCacheSize = 64\n\nfunction isRegl(o) {\n  return typeof o === 'function' && o._gl && o.prop && o.texture && o.buffer;\n}\n\nmodule.exports = GlText;","map":null,"metadata":{},"sourceType":"script"}