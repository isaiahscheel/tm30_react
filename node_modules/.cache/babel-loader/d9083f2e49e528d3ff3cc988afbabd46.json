{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n/* This function retrns a set of control points that define a curve aligned along\n * either the a or b axis. Exactly one of a or b must be an array defining the range\n * spanned.\n *\n * Honestly this is the most complicated function I've implemente here so far because\n * of the way it handles knot insertion and direction/axis-agnostic slices.\n */\n\n\nmodule.exports = function (carpet, carpetcd, a, b) {\n  var idx, tangent, tanIsoIdx, tanIsoPar, segment, refidx;\n  var p0, p1, v0, v1, start, end, range;\n  var axis = isArrayOrTypedArray(a) ? 'a' : 'b';\n  var ax = axis === 'a' ? carpet.aaxis : carpet.baxis;\n  var smoothing = ax.smoothing;\n  var toIdx = axis === 'a' ? carpet.a2i : carpet.b2j;\n  var pt = axis === 'a' ? a : b;\n  var iso = axis === 'a' ? b : a;\n  var n = axis === 'a' ? carpetcd.a.length : carpetcd.b.length;\n  var m = axis === 'a' ? carpetcd.b.length : carpetcd.a.length;\n  var isoIdx = Math.floor(axis === 'a' ? carpet.b2j(iso) : carpet.a2i(iso));\n  var xy = axis === 'a' ? function (value) {\n    return carpet.evalxy([], value, isoIdx);\n  } : function (value) {\n    return carpet.evalxy([], isoIdx, value);\n  };\n\n  if (smoothing) {\n    tanIsoIdx = Math.max(0, Math.min(m - 2, isoIdx));\n    tanIsoPar = isoIdx - tanIsoIdx;\n    tangent = axis === 'a' ? function (i, ti) {\n      return carpet.dxydi([], i, tanIsoIdx, ti, tanIsoPar);\n    } : function (j, tj) {\n      return carpet.dxydj([], tanIsoIdx, j, tanIsoPar, tj);\n    };\n  }\n\n  var vstart = toIdx(pt[0]);\n  var vend = toIdx(pt[1]); // So that we can make this work in two directions, flip all of the\n  // math functions if the direction is from higher to lower indices:\n  //\n  // Note that the tolerance is directional!\n\n  var dir = vstart < vend ? 1 : -1;\n  var tol = (vend - vstart) * 1e-8;\n  var dirfloor = dir > 0 ? Math.floor : Math.ceil;\n  var dirceil = dir > 0 ? Math.ceil : Math.floor;\n  var dirmin = dir > 0 ? Math.min : Math.max;\n  var dirmax = dir > 0 ? Math.max : Math.min;\n  var idx0 = dirfloor(vstart + tol);\n  var idx1 = dirceil(vend - tol);\n  p0 = xy(vstart);\n  var segments = [[p0]];\n\n  for (idx = idx0; idx * dir < idx1 * dir; idx += dir) {\n    segment = [];\n    start = dirmax(vstart, idx);\n    end = dirmin(vend, idx + dir);\n    range = end - start; // In order to figure out which cell we're in for the derivative (remember,\n    // the derivatives are *not* constant across grid lines), let's just average\n    // the start and end points. This cuts out just a tiny bit of logic and\n    // there's really no computational difference:\n\n    refidx = Math.max(0, Math.min(n - 2, Math.floor(0.5 * (start + end))));\n    p1 = xy(end);\n\n    if (smoothing) {\n      v0 = tangent(refidx, start - refidx);\n      v1 = tangent(refidx, end - refidx);\n      segment.push([p0[0] + v0[0] / 3 * range, p0[1] + v0[1] / 3 * range]);\n      segment.push([p1[0] - v1[0] / 3 * range, p1[1] - v1[1] / 3 * range]);\n    }\n\n    segment.push(p1);\n    segments.push(segment);\n    p0 = p1;\n  }\n\n  return segments;\n};","map":null,"metadata":{},"sourceType":"script"}