{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Loggers = require('./lib/loggers');\n\nvar noop = require('./lib/noop');\n\nvar pushUnique = require('./lib/push_unique');\n\nvar isPlainObject = require('./lib/is_plain_object');\n\nvar addStyleRule = require('./lib/dom').addStyleRule;\n\nvar ExtendModule = require('./lib/extend');\n\nvar basePlotAttributes = require('./plots/attributes');\n\nvar baseLayoutAttributes = require('./plots/layout_attributes');\n\nvar extendFlat = ExtendModule.extendFlat;\nvar extendDeepAll = ExtendModule.extendDeepAll;\nexports.modules = {};\nexports.allCategories = {};\nexports.allTypes = [];\nexports.subplotsRegistry = {};\nexports.transformsRegistry = {};\nexports.componentsRegistry = {};\nexports.layoutArrayContainers = [];\nexports.layoutArrayRegexes = [];\nexports.traceLayoutAttributes = {};\nexports.localeRegistry = {};\nexports.apiMethodRegistry = {};\nexports.collectableSubplotTypes = null;\n/**\n * Top-level register routine, exported as Plotly.register\n *\n * @param {object array or array of objects} _modules :\n *  module object or list of module object to register.\n *\n *  A valid `moduleType: 'trace'` module has fields:\n *  - name {string} : the trace type\n *  - categories {array} : categories associated with this trace type,\n *                         tested with Register.traceIs()\n *  - meta {object} : meta info (mostly for plot-schema)\n *\n *  A valid `moduleType: 'locale'` module has fields:\n *  - name {string} : the locale name. Should be a 2-digit language string ('en', 'de')\n *                    optionally with a country/region code ('en-GB', 'de-CH'). If a country\n *                    code is used but the base language locale has not yet been supplied,\n *                    we will use this locale for the base as well.\n *  - dictionary {object} : the dictionary mapping input strings to localized strings\n *                          generally the keys should be the literal input strings, but\n *                          if default translations are provided you can use any string as a key.\n *  - format {object} : a `d3.locale` format specifier for this locale\n *                      any omitted keys we'll fall back on en-US.\n *\n *  A valid `moduleType: 'transform'` module has fields:\n *  - name {string} : transform name\n *  - transform {function} : default-level transform function\n *  - calcTransform {function} : calc-level transform function\n *  - attributes {object} : transform attributes declarations\n *  - supplyDefaults {function} : attributes default-supply function\n *\n *  A valid `moduleType: 'component'` module has fields:\n *  - name {string} : the component name, used it with Register.getComponentMethod()\n *                    to employ component method.\n *\n *  A valid `moduleType: 'apiMethod'` module has fields:\n *  - name {string} : the api method name.\n *  - fn {function} : the api method called with Register.call();\n *\n */\n\nexports.register = function register(_modules) {\n  exports.collectableSubplotTypes = null;\n\n  if (!_modules) {\n    throw new Error('No argument passed to Plotly.register.');\n  } else if (_modules && !Array.isArray(_modules)) {\n    _modules = [_modules];\n  }\n\n  for (var i = 0; i < _modules.length; i++) {\n    var newModule = _modules[i];\n\n    if (!newModule) {\n      throw new Error('Invalid module was attempted to be registered!');\n    }\n\n    switch (newModule.moduleType) {\n      case 'trace':\n        registerTraceModule(newModule);\n        break;\n\n      case 'transform':\n        registerTransformModule(newModule);\n        break;\n\n      case 'component':\n        registerComponentModule(newModule);\n        break;\n\n      case 'locale':\n        registerLocale(newModule);\n        break;\n\n      case 'apiMethod':\n        var name = newModule.name;\n        exports.apiMethodRegistry[name] = newModule.fn;\n        break;\n\n      default:\n        throw new Error('Invalid module was attempted to be registered!');\n    }\n  }\n};\n/**\n * Get registered module using trace object or trace type\n *\n * @param {object||string} trace\n *  trace object with prop 'type' or trace type as a string\n * @return {object}\n *  module object corresponding to trace type\n */\n\n\nexports.getModule = function (trace) {\n  var _module = exports.modules[getTraceType(trace)];\n  if (!_module) return false;\n  return _module._module;\n};\n/**\n * Determine if this trace type is in a given category\n *\n * @param {object||string} traceType\n *  a trace (object) or trace type (string)\n * @param {string} category\n *  category in question\n * @return {boolean}\n */\n\n\nexports.traceIs = function (traceType, category) {\n  traceType = getTraceType(traceType); // old plot.ly workspace hack, nothing to see here\n\n  if (traceType === 'various') return false;\n  var _module = exports.modules[traceType];\n\n  if (!_module) {\n    if (traceType && traceType !== 'area') {\n      Loggers.log('Unrecognized trace type ' + traceType + '.');\n    }\n\n    _module = exports.modules[basePlotAttributes.type.dflt];\n  }\n\n  return !!_module.categories[category];\n};\n/**\n * Determine if this trace has a transform of the given type and return\n * array of matching indices.\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {array}\n *  array of matching indices. If none found, returns []\n */\n\n\nexports.getTransformIndices = function (data, type) {\n  var indices = [];\n  var transforms = data.transforms || [];\n\n  for (var i = 0; i < transforms.length; i++) {\n    if (transforms[i].type === type) {\n      indices.push(i);\n    }\n  }\n\n  return indices;\n};\n/**\n * Determine if this trace has a transform of the given type\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {boolean}\n */\n\n\nexports.hasTransform = function (data, type) {\n  var transforms = data.transforms || [];\n\n  for (var i = 0; i < transforms.length; i++) {\n    if (transforms[i].type === type) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Retrieve component module method. Falls back on noop if either the\n * module or the method is missing, so the result can always be safely called\n *\n * @param {string} name\n *  name of component (as declared in component module)\n * @param {string} method\n *  name of component module method\n * @return {function}\n */\n\n\nexports.getComponentMethod = function (name, method) {\n  var _module = exports.componentsRegistry[name];\n  if (!_module) return noop;\n  return _module[method] || noop;\n};\n/**\n * Call registered api method.\n *\n * @param {string} name : api method name\n * @param {...array} args : arguments passed to api method\n * @return {any} : returns api method output\n */\n\n\nexports.call = function () {\n  var name = arguments[0];\n  var args = [].slice.call(arguments, 1);\n  return exports.apiMethodRegistry[name].apply(null, args);\n};\n\nfunction registerTraceModule(_module) {\n  var thisType = _module.name;\n  var categoriesIn = _module.categories;\n  var meta = _module.meta;\n\n  if (exports.modules[thisType]) {\n    Loggers.log('Type ' + thisType + ' already registered');\n    return;\n  }\n\n  if (!exports.subplotsRegistry[_module.basePlotModule.name]) {\n    registerSubplot(_module.basePlotModule);\n  }\n\n  var categoryObj = {};\n\n  for (var i = 0; i < categoriesIn.length; i++) {\n    categoryObj[categoriesIn[i]] = true;\n    exports.allCategories[categoriesIn[i]] = true;\n  }\n\n  exports.modules[thisType] = {\n    _module: _module,\n    categories: categoryObj\n  };\n\n  if (meta && Object.keys(meta).length) {\n    exports.modules[thisType].meta = meta;\n  }\n\n  exports.allTypes.push(thisType);\n\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToTrace(componentName, thisType);\n  }\n  /*\n   * Collect all trace layout attributes in one place for easier lookup later\n   * but don't merge them into the base schema as it would confuse the docs\n   * (at least after https://github.com/plotly/documentation/issues/202 gets done!)\n   */\n\n\n  if (_module.layoutAttributes) {\n    extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);\n  }\n\n  var basePlotModule = _module.basePlotModule;\n  var bpmName = basePlotModule.name; // add mapbox-gl CSS here to avoid console warning on instantiation\n\n  if (bpmName === 'mapbox') {\n    var styleRules = basePlotModule.constants.styleRules;\n\n    for (var k in styleRules) {\n      addStyleRule('.js-plotly-plot .plotly .mapboxgl-' + k, styleRules[k]);\n    }\n  } // if `plotly-geo-assets.js` is not included,\n  // add `PlotlyGeoAssets` global to stash references to all fetched\n  // topojson / geojson data\n\n\n  if ((bpmName === 'geo' || bpmName === 'mapbox') && typeof window !== undefined && window.PlotlyGeoAssets === undefined) {\n    window.PlotlyGeoAssets = {\n      topojson: {}\n    };\n  }\n}\n\nfunction registerSubplot(_module) {\n  var plotType = _module.name;\n\n  if (exports.subplotsRegistry[plotType]) {\n    Loggers.log('Plot type ' + plotType + ' already registered.');\n    return;\n  } // relayout array handling will look for component module methods with this\n  // name and won't find them because this is a subplot module... but that\n  // should be fine, it will just fall back on redrawing the plot.\n\n\n  findArrayRegexps(_module); // not sure what's best for the 'cartesian' type at this point\n\n  exports.subplotsRegistry[plotType] = _module;\n\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToSubplot(componentName, _module.name);\n  }\n}\n\nfunction registerComponentModule(_module) {\n  if (typeof _module.name !== 'string') {\n    throw new Error('Component module *name* must be a string.');\n  }\n\n  var name = _module.name;\n  exports.componentsRegistry[name] = _module;\n\n  if (_module.layoutAttributes) {\n    if (_module.layoutAttributes._isLinkedToArray) {\n      pushUnique(exports.layoutArrayContainers, name);\n    }\n\n    findArrayRegexps(_module);\n  }\n\n  for (var traceType in exports.modules) {\n    mergeComponentAttrsToTrace(name, traceType);\n  }\n\n  for (var subplotName in exports.subplotsRegistry) {\n    mergeComponentAttrsToSubplot(name, subplotName);\n  }\n\n  for (var transformType in exports.transformsRegistry) {\n    mergeComponentAttrsToTransform(name, transformType);\n  }\n\n  if (_module.schema && _module.schema.layout) {\n    extendDeepAll(baseLayoutAttributes, _module.schema.layout);\n  }\n}\n\nfunction registerTransformModule(_module) {\n  if (typeof _module.name !== 'string') {\n    throw new Error('Transform module *name* must be a string.');\n  }\n\n  var prefix = 'Transform module ' + _module.name;\n  var hasTransform = typeof _module.transform === 'function';\n  var hasCalcTransform = typeof _module.calcTransform === 'function';\n\n  if (!hasTransform && !hasCalcTransform) {\n    throw new Error(prefix + ' is missing a *transform* or *calcTransform* method.');\n  }\n\n  if (hasTransform && hasCalcTransform) {\n    Loggers.log([prefix + ' has both a *transform* and *calcTransform* methods.', 'Please note that all *transform* methods are executed', 'before all *calcTransform* methods.'].join(' '));\n  }\n\n  if (!isPlainObject(_module.attributes)) {\n    Loggers.log(prefix + ' registered without an *attributes* object.');\n  }\n\n  if (typeof _module.supplyDefaults !== 'function') {\n    Loggers.log(prefix + ' registered without a *supplyDefaults* method.');\n  }\n\n  exports.transformsRegistry[_module.name] = _module;\n\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToTransform(componentName, _module.name);\n  }\n}\n\nfunction registerLocale(_module) {\n  var locale = _module.name;\n  var baseLocale = locale.split('-')[0];\n  var newDict = _module.dictionary;\n  var newFormat = _module.format;\n  var hasDict = newDict && Object.keys(newDict).length;\n  var hasFormat = newFormat && Object.keys(newFormat).length;\n  var locales = exports.localeRegistry;\n  var localeObj = locales[locale];\n  if (!localeObj) locales[locale] = localeObj = {}; // Should we use this dict for the base locale?\n  // In case we're overwriting a previous dict for this locale, check\n  // whether the base matches the full locale dict now. If we're not\n  // overwriting, locales[locale] is undefined so this just checks if\n  // baseLocale already had a dict or not.\n  // Same logic for dateFormats\n\n  if (baseLocale !== locale) {\n    var baseLocaleObj = locales[baseLocale];\n    if (!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};\n\n    if (hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {\n      baseLocaleObj.dictionary = newDict;\n    }\n\n    if (hasFormat && baseLocaleObj.format === localeObj.format) {\n      baseLocaleObj.format = newFormat;\n    }\n  }\n\n  if (hasDict) localeObj.dictionary = newDict;\n  if (hasFormat) localeObj.format = newFormat;\n}\n\nfunction findArrayRegexps(_module) {\n  if (_module.layoutAttributes) {\n    var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;\n\n    if (arrayAttrRegexps) {\n      for (var i = 0; i < arrayAttrRegexps.length; i++) {\n        pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);\n      }\n    }\n  }\n}\n\nfunction mergeComponentAttrsToTrace(componentName, traceType) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.traces) return;\n  var traceAttrs = componentSchema.traces[traceType];\n\n  if (traceAttrs) {\n    extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);\n  }\n}\n\nfunction mergeComponentAttrsToTransform(componentName, transformType) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.transforms) return;\n  var transformAttrs = componentSchema.transforms[transformType];\n\n  if (transformAttrs) {\n    extendDeepAll(exports.transformsRegistry[transformType].attributes, transformAttrs);\n  }\n}\n\nfunction mergeComponentAttrsToSubplot(componentName, subplotName) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.subplots) return;\n  var subplotModule = exports.subplotsRegistry[subplotName];\n  var subplotAttrs = subplotModule.layoutAttributes;\n  var subplotAttr = subplotModule.attr === 'subplot' ? subplotModule.name : subplotModule.attr;\n  if (Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];\n  var componentLayoutAttrs = componentSchema.subplots[subplotAttr];\n\n  if (subplotAttrs && componentLayoutAttrs) {\n    extendDeepAll(subplotAttrs, componentLayoutAttrs);\n  }\n}\n\nfunction getTraceType(traceType) {\n  if (typeof traceType === 'object') traceType = traceType.type;\n  return traceType;\n}","map":null,"metadata":{},"sourceType":"script"}