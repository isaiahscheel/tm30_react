{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib'); // make sure scene exists on subplot, return it\n\n\nmodule.exports = function sceneUpdate(gd, subplot) {\n  var scene = subplot._scene;\n  var resetOpts = {\n    // number of traces in subplot, since scene:subplot -> 1:1\n    count: 0,\n    // whether scene requires init hook in plot call (dirty plot call)\n    dirty: true,\n    // last used options\n    lineOptions: [],\n    fillOptions: [],\n    markerOptions: [],\n    markerSelectedOptions: [],\n    markerUnselectedOptions: [],\n    errorXOptions: [],\n    errorYOptions: [],\n    textOptions: [],\n    textSelectedOptions: [],\n    textUnselectedOptions: [],\n    // selection batches\n    selectBatch: [],\n    unselectBatch: []\n  }; // regl- component stubs, initialized in dirty plot call\n\n  var initOpts = {\n    fill2d: false,\n    scatter2d: false,\n    error2d: false,\n    line2d: false,\n    glText: false,\n    select2d: false\n  };\n\n  if (!subplot._scene) {\n    scene = subplot._scene = {};\n\n    scene.init = function init() {\n      Lib.extendFlat(scene, initOpts, resetOpts);\n    };\n\n    scene.init(); // apply new option to all regl components (used on drag)\n\n    scene.update = function update(opt) {\n      var opts = Lib.repeat(opt, scene.count);\n      if (scene.fill2d) scene.fill2d.update(opts);\n      if (scene.scatter2d) scene.scatter2d.update(opts);\n      if (scene.line2d) scene.line2d.update(opts);\n      if (scene.error2d) scene.error2d.update(opts.concat(opts));\n      if (scene.select2d) scene.select2d.update(opts);\n\n      if (scene.glText) {\n        for (var i = 0; i < scene.count; i++) {\n          scene.glText[i].update(opt);\n        }\n      }\n    }; // draw traces in proper order\n\n\n    scene.draw = function draw() {\n      var count = scene.count;\n      var fill2d = scene.fill2d;\n      var error2d = scene.error2d;\n      var line2d = scene.line2d;\n      var scatter2d = scene.scatter2d;\n      var glText = scene.glText;\n      var select2d = scene.select2d;\n      var selectBatch = scene.selectBatch;\n      var unselectBatch = scene.unselectBatch;\n\n      for (var i = 0; i < count; i++) {\n        if (fill2d && scene.fillOrder[i]) {\n          fill2d.draw(scene.fillOrder[i]);\n        }\n\n        if (line2d && scene.lineOptions[i]) {\n          line2d.draw(i);\n        }\n\n        if (error2d) {\n          if (scene.errorXOptions[i]) error2d.draw(i);\n          if (scene.errorYOptions[i]) error2d.draw(i + count);\n        }\n\n        if (scatter2d && scene.markerOptions[i]) {\n          if (unselectBatch[i].length) {\n            var arg = Lib.repeat([], scene.count);\n            arg[i] = unselectBatch[i];\n            scatter2d.draw(arg);\n          } else if (!selectBatch[i].length) {\n            scatter2d.draw(i);\n          }\n        }\n\n        if (glText[i] && scene.textOptions[i]) {\n          glText[i].render();\n        }\n      }\n\n      if (select2d) {\n        select2d.draw(selectBatch);\n      }\n\n      scene.dirty = false;\n    }; // remove scene resources\n\n\n    scene.destroy = function destroy() {\n      if (scene.fill2d && scene.fill2d.destroy) scene.fill2d.destroy();\n      if (scene.scatter2d && scene.scatter2d.destroy) scene.scatter2d.destroy();\n      if (scene.error2d && scene.error2d.destroy) scene.error2d.destroy();\n      if (scene.line2d && scene.line2d.destroy) scene.line2d.destroy();\n      if (scene.select2d && scene.select2d.destroy) scene.select2d.destroy();\n\n      if (scene.glText) {\n        scene.glText.forEach(function (text) {\n          if (text.destroy) text.destroy();\n        });\n      }\n\n      scene.lineOptions = null;\n      scene.fillOptions = null;\n      scene.markerOptions = null;\n      scene.markerSelectedOptions = null;\n      scene.markerUnselectedOptions = null;\n      scene.errorXOptions = null;\n      scene.errorYOptions = null;\n      scene.textOptions = null;\n      scene.textSelectedOptions = null;\n      scene.textUnselectedOptions = null;\n      scene.selectBatch = null;\n      scene.unselectBatch = null; // we can't just delete _scene, because `destroy` is called in the\n      // middle of supplyDefaults, before relinkPrivateKeys which will put it back.\n\n      subplot._scene = null;\n    };\n  } // in case if we have scene from the last calc - reset data\n\n\n  if (!scene.dirty) {\n    Lib.extendFlat(scene, resetOpts);\n  }\n\n  return scene;\n};","map":null,"metadata":{},"sourceType":"script"}