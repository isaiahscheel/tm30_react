{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n/* global jQuery:false */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Events = {\n  init: function (plotObj) {\n    /*\n     * If we have already instantiated an emitter for this plot\n     * return early.\n     */\n    if (plotObj._ev instanceof EventEmitter) return plotObj;\n    var ev = new EventEmitter();\n    var internalEv = new EventEmitter();\n    /*\n     * Assign to plot._ev while we still live in a land\n     * where plot is a DOM element with stuff attached to it.\n     * In the future we can make plot the event emitter itself.\n     */\n\n    plotObj._ev = ev;\n    /*\n     * Create a second event handler that will manage events *internally*.\n     * This allows parts of plotly to respond to thing like relayout without\n     * having to use the user-facing event handler. They cannot peacefully\n     * coexist on the same handler because a user invoking\n     * plotObj.removeAllListeners() would detach internal events, breaking\n     * plotly.\n     */\n\n    plotObj._internalEv = internalEv;\n    /*\n     * Assign bound methods from the ev to the plot object. These methods\n     * will reference the 'this' of plot._ev even though they are methods\n     * of plot. This will keep the event machinery away from the plot object\n     * which currently is often a DOM element but presents an API that will\n     * continue to function when plot becomes an emitter. Not all EventEmitter\n     * methods have been bound to `plot` as some do not currently add value to\n     * the Plotly event API.\n     */\n\n    plotObj.on = ev.on.bind(ev);\n    plotObj.once = ev.once.bind(ev);\n    plotObj.removeListener = ev.removeListener.bind(ev);\n    plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\n    /*\n     * Create functions for managing internal events. These are *only* triggered\n     * by the mirroring of external events via the emit function.\n     */\n\n    plotObj._internalOn = internalEv.on.bind(internalEv);\n    plotObj._internalOnce = internalEv.once.bind(internalEv);\n    plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\n    plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\n    /*\n     * We must wrap emit to continue to support JQuery events. The idea\n     * is to check to see if the user is using JQuery events, if they are\n     * we emit JQuery events to trigger user handlers as well as the EventEmitter\n     * events.\n     */\n\n    plotObj.emit = function (event, data) {\n      if (typeof jQuery !== 'undefined') {\n        jQuery(plotObj).trigger(event, data);\n      }\n\n      ev.emit(event, data);\n      internalEv.emit(event, data);\n    };\n\n    return plotObj;\n  },\n\n  /*\n   * This function behaves like jQuery's triggerHandler. It calls\n   * all handlers for a particular event and returns the return value\n   * of the LAST handler. This function also triggers jQuery's\n   * triggerHandler for backwards compatibility.\n   */\n  triggerHandler: function (plotObj, event, data) {\n    var jQueryHandlerValue;\n    var nodeEventHandlerValue;\n    /*\n     * If jQuery exists run all its handlers for this event and\n     * collect the return value of the LAST handler function\n     */\n\n    if (typeof jQuery !== 'undefined') {\n      jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\n    }\n    /*\n     * Now run all the node style event handlers\n     */\n\n\n    var ev = plotObj._ev;\n    if (!ev) return jQueryHandlerValue;\n    var handlers = ev._events[event];\n    if (!handlers) return jQueryHandlerValue; // making sure 'this' is the EventEmitter instance\n\n    function apply(handler) {\n      // The 'once' case, we can't just call handler() as we need\n      // the return value here. So,\n      // - remove handler\n      // - call listener and grab return value!\n      // - stash 'fired' key to not call handler twice\n      if (handler.listener) {\n        ev.removeListener(event, handler.listener);\n\n        if (!handler.fired) {\n          handler.fired = true;\n          return handler.listener.apply(ev, [data]);\n        }\n      } else {\n        return handler.apply(ev, [data]);\n      }\n    } // handlers can be function or an array of functions\n\n\n    handlers = Array.isArray(handlers) ? handlers : [handlers];\n    var i;\n\n    for (i = 0; i < handlers.length - 1; i++) {\n      apply(handlers[i]);\n    } // now call the final handler and collect its value\n\n\n    nodeEventHandlerValue = apply(handlers[i]);\n    /*\n     * Return either the jQuery handler value if it exists or the\n     * nodeEventHandler value. jQuery event value supersedes nodejs\n     * events for backwards compatibility reasons.\n     */\n\n    return jQueryHandlerValue !== undefined ? jQueryHandlerValue : nodeEventHandlerValue;\n  },\n  purge: function (plotObj) {\n    delete plotObj._ev;\n    delete plotObj.on;\n    delete plotObj.once;\n    delete plotObj.removeListener;\n    delete plotObj.removeAllListeners;\n    delete plotObj.emit;\n    delete plotObj._ev;\n    delete plotObj._internalEv;\n    delete plotObj._internalOn;\n    delete plotObj._internalOnce;\n    delete plotObj._removeInternalListener;\n    delete plotObj._removeAllInternalListeners;\n    return plotObj;\n  }\n};\nmodule.exports = Events;","map":null,"metadata":{},"sourceType":"script"}