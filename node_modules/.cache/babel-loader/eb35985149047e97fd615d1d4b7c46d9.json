{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar calendars = require('./calendars');\n\nvar Lib = require('../../lib');\n\nvar constants = require('../../constants/numerical');\n\nvar EPOCHJD = constants.EPOCHJD;\nvar ONEDAY = constants.ONEDAY;\nvar attributes = {\n  valType: 'enumerated',\n  values: Object.keys(calendars.calendars),\n  role: 'info',\n  editType: 'calc',\n  dflt: 'gregorian'\n};\n\nvar handleDefaults = function (contIn, contOut, attr, dflt) {\n  var attrs = {};\n  attrs[attr] = attributes;\n  return Lib.coerce(contIn, contOut, attrs, attr, dflt);\n};\n\nvar handleTraceDefaults = function (traceIn, traceOut, coords, layout) {\n  for (var i = 0; i < coords.length; i++) {\n    handleDefaults(traceIn, traceOut, coords[i] + 'calendar', layout.calendar);\n  }\n}; // each calendar needs its own default canonical tick. I would love to use\n// 2000-01-01 (or even 0000-01-01) for them all but they don't necessarily\n// all support either of those dates. Instead I'll use the most significant\n// number they *do* support, biased toward the present day.\n\n\nvar CANONICAL_TICK = {\n  chinese: '2000-01-01',\n  coptic: '2000-01-01',\n  discworld: '2000-01-01',\n  ethiopian: '2000-01-01',\n  hebrew: '5000-01-01',\n  islamic: '1000-01-01',\n  julian: '2000-01-01',\n  mayan: '5000-01-01',\n  nanakshahi: '1000-01-01',\n  nepali: '2000-01-01',\n  persian: '1000-01-01',\n  jalali: '1000-01-01',\n  taiwan: '1000-01-01',\n  thai: '2000-01-01',\n  ummalqura: '1400-01-01'\n}; // Start on a Sunday - for week ticks\n// Discworld and Mayan calendars don't have 7-day weeks but we're going to give them\n// 7-day week ticks so start on our Sundays.\n// If anyone really cares we can customize the auto tick spacings for these calendars.\n\nvar CANONICAL_SUNDAY = {\n  chinese: '2000-01-02',\n  coptic: '2000-01-03',\n  discworld: '2000-01-03',\n  ethiopian: '2000-01-05',\n  hebrew: '5000-01-01',\n  islamic: '1000-01-02',\n  julian: '2000-01-03',\n  mayan: '5000-01-01',\n  nanakshahi: '1000-01-05',\n  nepali: '2000-01-05',\n  persian: '1000-01-01',\n  jalali: '1000-01-01',\n  taiwan: '1000-01-04',\n  thai: '2000-01-04',\n  ummalqura: '1400-01-06'\n};\nvar DFLTRANGE = {\n  chinese: ['2000-01-01', '2001-01-01'],\n  coptic: ['1700-01-01', '1701-01-01'],\n  discworld: ['1800-01-01', '1801-01-01'],\n  ethiopian: ['2000-01-01', '2001-01-01'],\n  hebrew: ['5700-01-01', '5701-01-01'],\n  islamic: ['1400-01-01', '1401-01-01'],\n  julian: ['2000-01-01', '2001-01-01'],\n  mayan: ['5200-01-01', '5201-01-01'],\n  nanakshahi: ['0500-01-01', '0501-01-01'],\n  nepali: ['2000-01-01', '2001-01-01'],\n  persian: ['1400-01-01', '1401-01-01'],\n  jalali: ['1400-01-01', '1401-01-01'],\n  taiwan: ['0100-01-01', '0101-01-01'],\n  thai: ['2500-01-01', '2501-01-01'],\n  ummalqura: ['1400-01-01', '1401-01-01']\n};\n/*\n * convert d3 templates to world-calendars templates, so our users only need\n * to know d3's specifiers. Map space padding to no padding, and unknown fields\n * to an ugly placeholder\n */\n\nvar UNKNOWN = '##';\nvar d3ToWorldCalendars = {\n  'd': {\n    '0': 'dd',\n    '-': 'd'\n  },\n  // 2-digit or unpadded day of month\n  'e': {\n    '0': 'd',\n    '-': 'd'\n  },\n  // alternate, always unpadded day of month\n  'a': {\n    '0': 'D',\n    '-': 'D'\n  },\n  // short weekday name\n  'A': {\n    '0': 'DD',\n    '-': 'DD'\n  },\n  // full weekday name\n  'j': {\n    '0': 'oo',\n    '-': 'o'\n  },\n  // 3-digit or unpadded day of the year\n  'W': {\n    '0': 'ww',\n    '-': 'w'\n  },\n  // 2-digit or unpadded week of the year (Monday first)\n  'm': {\n    '0': 'mm',\n    '-': 'm'\n  },\n  // 2-digit or unpadded month number\n  'b': {\n    '0': 'M',\n    '-': 'M'\n  },\n  // short month name\n  'B': {\n    '0': 'MM',\n    '-': 'MM'\n  },\n  // full month name\n  'y': {\n    '0': 'yy',\n    '-': 'yy'\n  },\n  // 2-digit year (map unpadded to zero-padded)\n  'Y': {\n    '0': 'yyyy',\n    '-': 'yyyy'\n  },\n  // 4-digit year (map unpadded to zero-padded)\n  'U': UNKNOWN,\n  // Sunday-first week of the year\n  'w': UNKNOWN,\n  // day of the week [0(sunday),6]\n  // combined format, we replace the date part with the world-calendar version\n  // and the %X stays there for d3 to handle with time parts\n  'c': {\n    '0': 'D M d %X yyyy',\n    '-': 'D M d %X yyyy'\n  },\n  'x': {\n    '0': 'mm/dd/yyyy',\n    '-': 'mm/dd/yyyy'\n  }\n};\n\nfunction worldCalFmt(fmt, x, calendar) {\n  var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD;\n  var cDate = getCal(calendar).fromJD(dateJD);\n  var i = 0;\n  var modifier, directive, directiveLen, directiveObj, replacementPart;\n\n  while ((i = fmt.indexOf('%', i)) !== -1) {\n    modifier = fmt.charAt(i + 1);\n\n    if (modifier === '0' || modifier === '-' || modifier === '_') {\n      directiveLen = 3;\n      directive = fmt.charAt(i + 2);\n      if (modifier === '_') modifier = '-';\n    } else {\n      directive = modifier;\n      modifier = '0';\n      directiveLen = 2;\n    }\n\n    directiveObj = d3ToWorldCalendars[directive];\n\n    if (!directiveObj) {\n      i += directiveLen;\n    } else {\n      // code is recognized as a date part but world-calendars doesn't support it\n      if (directiveObj === UNKNOWN) replacementPart = UNKNOWN; // format the cDate according to the translated directive\n      else replacementPart = cDate.formatDate(directiveObj[modifier]);\n      fmt = fmt.substr(0, i) + replacementPart + fmt.substr(i + directiveLen);\n      i += replacementPart.length;\n    }\n  }\n\n  return fmt;\n} // cache world calendars, so we don't have to reinstantiate\n// during each date-time conversion\n\n\nvar allCals = {};\n\nfunction getCal(calendar) {\n  var calendarObj = allCals[calendar];\n  if (calendarObj) return calendarObj;\n  calendarObj = allCals[calendar] = calendars.instance(calendar);\n  return calendarObj;\n}\n\nfunction makeAttrs(description) {\n  return Lib.extendFlat({}, attributes, {\n    description: description\n  });\n}\n\nfunction makeTraceAttrsDescription(coord) {\n  return 'Sets the calendar system to use with `' + coord + '` date data.';\n}\n\nvar xAttrs = {\n  xcalendar: makeAttrs(makeTraceAttrsDescription('x'))\n};\nvar xyAttrs = Lib.extendFlat({}, xAttrs, {\n  ycalendar: makeAttrs(makeTraceAttrsDescription('y'))\n});\nvar xyzAttrs = Lib.extendFlat({}, xyAttrs, {\n  zcalendar: makeAttrs(makeTraceAttrsDescription('z'))\n});\nvar axisAttrs = makeAttrs(['Sets the calendar system to use for `range` and `tick0`', 'if this is a date axis. This does not set the calendar for', 'interpreting data on this axis, that\\'s specified in the trace', 'or via the global `layout.calendar`'].join(' '));\nmodule.exports = {\n  moduleType: 'component',\n  name: 'calendars',\n  schema: {\n    traces: {\n      scatter: xyAttrs,\n      bar: xyAttrs,\n      box: xyAttrs,\n      heatmap: xyAttrs,\n      contour: xyAttrs,\n      histogram: xyAttrs,\n      histogram2d: xyAttrs,\n      histogram2dcontour: xyAttrs,\n      scatter3d: xyzAttrs,\n      surface: xyzAttrs,\n      mesh3d: xyzAttrs,\n      scattergl: xyAttrs,\n      ohlc: xAttrs,\n      candlestick: xAttrs\n    },\n    layout: {\n      calendar: makeAttrs(['Sets the default calendar system to use for interpreting and', 'displaying dates throughout the plot.'].join(' '))\n    },\n    subplots: {\n      xaxis: {\n        calendar: axisAttrs\n      },\n      yaxis: {\n        calendar: axisAttrs\n      },\n      scene: {\n        xaxis: {\n          calendar: axisAttrs\n        },\n        // TODO: it's actually redundant to include yaxis and zaxis here\n        // because in the scene attributes these are the same object so merging\n        // into one merges into them all. However, I left them in for parity with\n        // cartesian, where yaxis is unused until we Plotschema.get() when we\n        // use its presence or absence to determine whether to delete attributes\n        // from yaxis if they only apply to x (rangeselector/rangeslider)\n        yaxis: {\n          calendar: axisAttrs\n        },\n        zaxis: {\n          calendar: axisAttrs\n        }\n      },\n      polar: {\n        radialaxis: {\n          calendar: axisAttrs\n        }\n      }\n    },\n    transforms: {\n      filter: {\n        valuecalendar: makeAttrs(['Sets the calendar system to use for `value`, if it is a date.'].join(' ')),\n        targetcalendar: makeAttrs(['Sets the calendar system to use for `target`, if it is an', 'array of dates. If `target` is a string (eg *x*) we use the', 'corresponding trace attribute (eg `xcalendar`) if it exists,', 'even if `targetcalendar` is provided.'].join(' '))\n      }\n    }\n  },\n  layoutAttributes: attributes,\n  handleDefaults: handleDefaults,\n  handleTraceDefaults: handleTraceDefaults,\n  CANONICAL_SUNDAY: CANONICAL_SUNDAY,\n  CANONICAL_TICK: CANONICAL_TICK,\n  DFLTRANGE: DFLTRANGE,\n  getCal: getCal,\n  worldCalFmt: worldCalFmt\n};","map":null,"metadata":{},"sourceType":"script"}