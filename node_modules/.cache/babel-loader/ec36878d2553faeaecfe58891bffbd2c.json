{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar c = require('./constants');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar isNumeric = require('fast-isnumeric'); // pure functions, don't alter but passes on `gd` and parts of `trace` without deep copying\n\n\nmodule.exports = function calc(gd, trace) {\n  var cellsValues = squareStringMatrix(trace.cells.values);\n\n  var slicer = function (a) {\n    return a.slice(trace.header.values.length, a.length);\n  };\n\n  var headerValuesIn = squareStringMatrix(trace.header.values);\n\n  if (headerValuesIn.length && !headerValuesIn[0].length) {\n    headerValuesIn[0] = [''];\n    headerValuesIn = squareStringMatrix(headerValuesIn);\n  }\n\n  var headerValues = headerValuesIn.concat(slicer(cellsValues).map(function () {\n    return emptyStrings((headerValuesIn[0] || ['']).length);\n  }));\n  var domain = trace.domain;\n  var groupWidth = Math.floor(gd._fullLayout._size.w * (domain.x[1] - domain.x[0]));\n  var groupHeight = Math.floor(gd._fullLayout._size.h * (domain.y[1] - domain.y[0]));\n  var headerRowHeights = trace.header.values.length ? headerValues[0].map(function () {\n    return trace.header.height;\n  }) : [c.emptyHeaderHeight];\n  var rowHeights = cellsValues.length ? cellsValues[0].map(function () {\n    return trace.cells.height;\n  }) : [];\n  var headerHeight = headerRowHeights.reduce(sum, 0);\n  var scrollHeight = groupHeight - headerHeight;\n  var minimumFillHeight = scrollHeight + c.uplift;\n  var anchorToRowBlock = makeAnchorToRowBlock(rowHeights, minimumFillHeight);\n  var anchorToHeaderRowBlock = makeAnchorToRowBlock(headerRowHeights, headerHeight);\n  var headerRowBlocks = makeRowBlock(anchorToHeaderRowBlock, []);\n  var rowBlocks = makeRowBlock(anchorToRowBlock, headerRowBlocks);\n  var uniqueKeys = {};\n\n  var columnOrder = trace._fullInput.columnorder.concat(slicer(cellsValues.map(function (d, i) {\n    return i;\n  })));\n\n  var columnWidths = headerValues.map(function (d, i) {\n    var value = Array.isArray(trace.columnwidth) ? trace.columnwidth[Math.min(i, trace.columnwidth.length - 1)] : trace.columnwidth;\n    return isNumeric(value) ? Number(value) : 1;\n  });\n  var totalColumnWidths = columnWidths.reduce(sum, 0); // fit columns in the available vertical space as there's no vertical scrolling now\n\n  columnWidths = columnWidths.map(function (d) {\n    return d / totalColumnWidths * groupWidth;\n  });\n  var maxLineWidth = Math.max(arrayMax(trace.header.line.width), arrayMax(trace.cells.line.width));\n  var calcdata = {\n    // include staticPlot in the key so if it changes we delete and redraw\n    key: trace.uid + gd._context.staticPlot,\n    translateX: domain.x[0] * gd._fullLayout._size.w,\n    translateY: gd._fullLayout._size.h * (1 - domain.y[1]),\n    size: gd._fullLayout._size,\n    width: groupWidth,\n    maxLineWidth: maxLineWidth,\n    height: groupHeight,\n    columnOrder: columnOrder,\n    // will be mutated on column move, todo use in callback\n    groupHeight: groupHeight,\n    rowBlocks: rowBlocks,\n    headerRowBlocks: headerRowBlocks,\n    scrollY: 0,\n    // will be mutated on scroll\n    cells: extendFlat({}, trace.cells, {\n      values: cellsValues\n    }),\n    headerCells: extendFlat({}, trace.header, {\n      values: headerValues\n    }),\n    gdColumns: headerValues.map(function (d) {\n      return d[0];\n    }),\n    gdColumnsOriginalOrder: headerValues.map(function (d) {\n      return d[0];\n    }),\n    prevPages: [0, 0],\n    scrollbarState: {\n      scrollbarScrollInProgress: false\n    },\n    columns: headerValues.map(function (label, i) {\n      var foundKey = uniqueKeys[label];\n      uniqueKeys[label] = (foundKey || 0) + 1;\n      var key = label + '__' + uniqueKeys[label];\n      return {\n        key: key,\n        label: label,\n        specIndex: i,\n        xIndex: columnOrder[i],\n        xScale: xScale,\n        x: undefined,\n        // initialized below\n        calcdata: undefined,\n        // initialized below\n        columnWidth: columnWidths[i]\n      };\n    })\n  };\n  calcdata.columns.forEach(function (col) {\n    col.calcdata = calcdata;\n    col.x = xScale(col);\n  });\n  return calcdata;\n};\n\nfunction arrayMax(maybeArray) {\n  if (Array.isArray(maybeArray)) {\n    var max = 0;\n\n    for (var i = 0; i < maybeArray.length; i++) {\n      max = Math.max(max, arrayMax(maybeArray[i]));\n    }\n\n    return max;\n  }\n\n  return maybeArray;\n}\n\nfunction sum(a, b) {\n  return a + b;\n} // fill matrix in place to equal lengths\n// and ensure it's uniformly 2D\n\n\nfunction squareStringMatrix(matrixIn) {\n  var matrix = matrixIn.slice();\n  var minLen = Infinity;\n  var maxLen = 0;\n  var i;\n\n  for (i = 0; i < matrix.length; i++) {\n    if (!Array.isArray(matrix[i])) matrix[i] = [matrix[i]];\n    minLen = Math.min(minLen, matrix[i].length);\n    maxLen = Math.max(maxLen, matrix[i].length);\n  }\n\n  if (minLen !== maxLen) {\n    for (i = 0; i < matrix.length; i++) {\n      var padLen = maxLen - matrix[i].length;\n      if (padLen) matrix[i] = matrix[i].concat(emptyStrings(padLen));\n    }\n  }\n\n  return matrix;\n}\n\nfunction emptyStrings(len) {\n  var padArray = new Array(len);\n\n  for (var j = 0; j < len; j++) padArray[j] = '';\n\n  return padArray;\n}\n\nfunction xScale(d) {\n  return d.calcdata.columns.reduce(function (prev, next) {\n    return next.xIndex < d.xIndex ? prev + next.columnWidth : prev;\n  }, 0);\n}\n\nfunction makeRowBlock(anchorToRowBlock, auxiliary) {\n  var blockAnchorKeys = Object.keys(anchorToRowBlock);\n  return blockAnchorKeys.map(function (k) {\n    return extendFlat({}, anchorToRowBlock[k], {\n      auxiliaryBlocks: auxiliary\n    });\n  });\n}\n\nfunction makeAnchorToRowBlock(rowHeights, minimumFillHeight) {\n  var anchorToRowBlock = {};\n  var currentRowHeight;\n  var currentAnchor = 0;\n  var currentBlockHeight = 0;\n  var currentBlock = makeIdentity();\n  var currentFirstRowIndex = 0;\n  var blockCounter = 0;\n\n  for (var i = 0; i < rowHeights.length; i++) {\n    currentRowHeight = rowHeights[i];\n    currentBlock.rows.push({\n      rowIndex: i,\n      rowHeight: currentRowHeight\n    });\n    currentBlockHeight += currentRowHeight;\n\n    if (currentBlockHeight >= minimumFillHeight || i === rowHeights.length - 1) {\n      anchorToRowBlock[currentAnchor] = currentBlock;\n      currentBlock.key = blockCounter++;\n      currentBlock.firstRowIndex = currentFirstRowIndex;\n      currentBlock.lastRowIndex = i;\n      currentBlock = makeIdentity();\n      currentAnchor += currentBlockHeight;\n      currentFirstRowIndex = i + 1;\n      currentBlockHeight = 0;\n    }\n  }\n\n  return anchorToRowBlock;\n}\n\nfunction makeIdentity() {\n  return {\n    firstRowIndex: null,\n    lastRowIndex: null,\n    rows: []\n  };\n}","map":null,"metadata":{},"sourceType":"script"}