{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar attributes = require('./attributes');\n\nvar handleDomainDefaults = require('../../plots/domain').defaults;\n\nvar Template = require('../../plot_api/plot_template');\n\nvar handleArrayContainerDefaults = require('../../plots/array_container_defaults');\n\nvar cn = require('./constants.js');\n\nvar handleTickValueDefaults = require('../../plots/cartesian/tick_value_defaults');\n\nvar handleTickMarkDefaults = require('../../plots/cartesian/tick_mark_defaults');\n\nvar handleTickLabelDefaults = require('../../plots/cartesian/tick_label_defaults');\n\nfunction supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n  }\n\n  handleDomainDefaults(traceOut, layout, coerce); // Mode\n\n  coerce('mode');\n  traceOut._hasNumber = traceOut.mode.indexOf('number') !== -1;\n  traceOut._hasDelta = traceOut.mode.indexOf('delta') !== -1;\n  traceOut._hasGauge = traceOut.mode.indexOf('gauge') !== -1;\n  var value = coerce('value');\n  traceOut._range = [0, typeof value === 'number' ? 1.5 * value : 1]; // Number attributes\n\n  var auto = new Array(2);\n  var bignumberFontSize;\n\n  if (traceOut._hasNumber) {\n    coerce('number.valueformat');\n    coerce('number.font.color', layout.font.color);\n    coerce('number.font.family', layout.font.family);\n    coerce('number.font.size');\n\n    if (traceOut.number.font.size === undefined) {\n      traceOut.number.font.size = cn.defaultNumberFontSize;\n      auto[0] = true;\n    }\n\n    coerce('number.prefix');\n    coerce('number.suffix');\n    bignumberFontSize = traceOut.number.font.size;\n  } // delta attributes\n\n\n  var deltaFontSize;\n\n  if (traceOut._hasDelta) {\n    coerce('delta.font.color', layout.font.color);\n    coerce('delta.font.family', layout.font.family);\n    coerce('delta.font.size');\n\n    if (traceOut.delta.font.size === undefined) {\n      traceOut.delta.font.size = (traceOut._hasNumber ? 0.5 : 1) * (bignumberFontSize || cn.defaultNumberFontSize);\n      auto[1] = true;\n    }\n\n    coerce('delta.reference', traceOut.value);\n    coerce('delta.relative');\n    coerce('delta.valueformat', traceOut.delta.relative ? '2%' : '');\n    coerce('delta.increasing.symbol');\n    coerce('delta.increasing.color');\n    coerce('delta.decreasing.symbol');\n    coerce('delta.decreasing.color');\n    coerce('delta.position');\n    deltaFontSize = traceOut.delta.font.size;\n  }\n\n  traceOut._scaleNumbers = (!traceOut._hasNumber || auto[0]) && (!traceOut._hasDelta || auto[1]) || false; // Title attributes\n\n  coerce('title.font.color', layout.font.color);\n  coerce('title.font.family', layout.font.family);\n  coerce('title.font.size', 0.25 * (bignumberFontSize || deltaFontSize || cn.defaultNumberFontSize));\n  coerce('title.text'); // Gauge attributes\n\n  var gaugeIn, gaugeOut, axisIn, axisOut;\n\n  function coerceGauge(attr, dflt) {\n    return Lib.coerce(gaugeIn, gaugeOut, attributes.gauge, attr, dflt);\n  }\n\n  function coerceGaugeAxis(attr, dflt) {\n    return Lib.coerce(axisIn, axisOut, attributes.gauge.axis, attr, dflt);\n  }\n\n  if (traceOut._hasGauge) {\n    gaugeIn = traceIn.gauge;\n    if (!gaugeIn) gaugeIn = {};\n    gaugeOut = Template.newContainer(traceOut, 'gauge');\n    coerceGauge('shape');\n    var isBullet = traceOut._isBullet = traceOut.gauge.shape === 'bullet';\n\n    if (!isBullet) {\n      coerce('title.align', 'center');\n    }\n\n    var isAngular = traceOut._isAngular = traceOut.gauge.shape === 'angular';\n\n    if (!isAngular) {\n      coerce('align', 'center');\n    } // gauge background\n\n\n    coerceGauge('bgcolor', layout.paper_bgcolor);\n    coerceGauge('borderwidth');\n    coerceGauge('bordercolor'); // gauge bar indicator\n\n    coerceGauge('bar.color');\n    coerceGauge('bar.line.color');\n    coerceGauge('bar.line.width');\n    var defaultBarThickness = cn.valueThickness * (traceOut.gauge.shape === 'bullet' ? 0.5 : 1);\n    coerceGauge('bar.thickness', defaultBarThickness); // Gauge steps\n\n    handleArrayContainerDefaults(gaugeIn, gaugeOut, {\n      name: 'steps',\n      handleItemDefaults: stepDefaults\n    }); // Gauge threshold\n\n    coerceGauge('threshold.value');\n    coerceGauge('threshold.thickness');\n    coerceGauge('threshold.line.width');\n    coerceGauge('threshold.line.color'); // Gauge axis\n\n    axisIn = {};\n    if (gaugeIn) axisIn = gaugeIn.axis || {};\n    axisOut = Template.newContainer(gaugeOut, 'axis');\n    coerceGaugeAxis('visible');\n    traceOut._range = coerceGaugeAxis('range', traceOut._range);\n    var opts = {\n      outerTicks: true\n    };\n    handleTickValueDefaults(axisIn, axisOut, coerceGaugeAxis, 'linear');\n    handleTickLabelDefaults(axisIn, axisOut, coerceGaugeAxis, 'linear', opts);\n    handleTickMarkDefaults(axisIn, axisOut, coerceGaugeAxis, opts);\n  } else {\n    coerce('title.align', 'center');\n    coerce('align', 'center');\n    traceOut._isAngular = traceOut._isBullet = false;\n  } // disable 1D transforms\n\n\n  traceOut._length = null;\n}\n\nfunction stepDefaults(stepIn, stepOut) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(stepIn, stepOut, attributes.gauge.steps, attr, dflt);\n  }\n\n  coerce('color');\n  coerce('line.color');\n  coerce('line.width');\n  coerce('range');\n  coerce('thickness');\n}\n\nmodule.exports = {\n  supplyDefaults: supplyDefaults\n};","map":null,"metadata":{},"sourceType":"script"}