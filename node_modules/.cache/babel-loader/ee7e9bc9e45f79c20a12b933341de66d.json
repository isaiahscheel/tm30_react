{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar d3 = require('d3');\n\nvar Lib = require('../../../lib');\n\nvar extendDeepAll = Lib.extendDeepAll;\n\nvar MID_SHIFT = require('../../../constants/alignment').MID_SHIFT;\n\nvar µ = module.exports = {\n  version: '0.2.2'\n};\n\nµ.Axis = function module() {\n  var config = {\n    data: [],\n    layout: {}\n  },\n      inputConfig = {},\n      liveConfig = {};\n  var svg,\n      container,\n      dispatch = d3.dispatch('hover'),\n      radialScale,\n      angularScale;\n  var exports = {};\n\n  function render(_container) {\n    container = _container || container;\n    var data = config.data;\n    var axisConfig = config.layout;\n    if (typeof container == 'string' || container.nodeName) container = d3.select(container);\n    container.datum(data).each(function (_data, _index) {\n      var dataOriginal = _data.slice();\n\n      liveConfig = {\n        data: µ.util.cloneJson(dataOriginal),\n        layout: µ.util.cloneJson(axisConfig)\n      };\n      var colorIndex = 0;\n      dataOriginal.forEach(function (d, i) {\n        if (!d.color) {\n          d.color = axisConfig.defaultColorRange[colorIndex];\n          colorIndex = (colorIndex + 1) % axisConfig.defaultColorRange.length;\n        }\n\n        if (!d.strokeColor) {\n          d.strokeColor = d.geometry === 'LinePlot' ? d.color : d3.rgb(d.color).darker().toString();\n        }\n\n        liveConfig.data[i].color = d.color;\n        liveConfig.data[i].strokeColor = d.strokeColor;\n        liveConfig.data[i].strokeDash = d.strokeDash;\n        liveConfig.data[i].strokeSize = d.strokeSize;\n      });\n      var data = dataOriginal.filter(function (d, i) {\n        var visible = d.visible;\n        return typeof visible === 'undefined' || visible === true;\n      });\n      var isStacked = false;\n      var dataWithGroupId = data.map(function (d, i) {\n        isStacked = isStacked || typeof d.groupId !== 'undefined';\n        return d;\n      });\n\n      if (isStacked) {\n        var grouped = d3.nest().key(function (d, i) {\n          return typeof d.groupId != 'undefined' ? d.groupId : 'unstacked';\n        }).entries(dataWithGroupId);\n        var dataYStack = [];\n        var stacked = grouped.map(function (d, i) {\n          if (d.key === 'unstacked') return d.values;else {\n            var prevArray = d.values[0].r.map(function (d, i) {\n              return 0;\n            });\n            d.values.forEach(function (d, i, a) {\n              d.yStack = [prevArray];\n              dataYStack.push(prevArray);\n              prevArray = µ.util.sumArrays(d.r, prevArray);\n            });\n            return d.values;\n          }\n        });\n        data = d3.merge(stacked);\n      }\n\n      data.forEach(function (d, i) {\n        d.t = Array.isArray(d.t[0]) ? d.t : [d.t];\n        d.r = Array.isArray(d.r[0]) ? d.r : [d.r];\n      });\n      var radius = Math.min(axisConfig.width - axisConfig.margin.left - axisConfig.margin.right, axisConfig.height - axisConfig.margin.top - axisConfig.margin.bottom) / 2;\n      radius = Math.max(10, radius);\n      var chartCenter = [axisConfig.margin.left + radius, axisConfig.margin.top + radius];\n      var extent;\n\n      if (isStacked) {\n        var highestStackedValue = d3.max(µ.util.sumArrays(µ.util.arrayLast(data).r[0], µ.util.arrayLast(dataYStack)));\n        extent = [0, highestStackedValue];\n      } else extent = d3.extent(µ.util.flattenArray(data.map(function (d, i) {\n        return d.r;\n      })));\n\n      if (axisConfig.radialAxis.domain != µ.DATAEXTENT) extent[0] = 0;\n      radialScale = d3.scale.linear().domain(axisConfig.radialAxis.domain != µ.DATAEXTENT && axisConfig.radialAxis.domain ? axisConfig.radialAxis.domain : extent).range([0, radius]);\n      liveConfig.layout.radialAxis.domain = radialScale.domain();\n      var angularDataMerged = µ.util.flattenArray(data.map(function (d, i) {\n        return d.t;\n      }));\n      var isOrdinal = typeof angularDataMerged[0] === 'string';\n      var ticks;\n\n      if (isOrdinal) {\n        angularDataMerged = µ.util.deduplicate(angularDataMerged);\n        ticks = angularDataMerged.slice();\n        angularDataMerged = d3.range(angularDataMerged.length);\n        data = data.map(function (d, i) {\n          var result = d;\n          d.t = [angularDataMerged];\n          if (isStacked) result.yStack = d.yStack;\n          return result;\n        });\n      }\n\n      var hasOnlyLineOrDotPlot = data.filter(function (d, i) {\n        return d.geometry === 'LinePlot' || d.geometry === 'DotPlot';\n      }).length === data.length;\n      var needsEndSpacing = axisConfig.needsEndSpacing === null ? isOrdinal || !hasOnlyLineOrDotPlot : axisConfig.needsEndSpacing;\n      var useProvidedDomain = axisConfig.angularAxis.domain && axisConfig.angularAxis.domain != µ.DATAEXTENT && !isOrdinal && axisConfig.angularAxis.domain[0] >= 0;\n      var angularDomain = useProvidedDomain ? axisConfig.angularAxis.domain : d3.extent(angularDataMerged);\n      var angularDomainStep = Math.abs(angularDataMerged[1] - angularDataMerged[0]);\n      if (hasOnlyLineOrDotPlot && !isOrdinal) angularDomainStep = 0;\n      var angularDomainWithPadding = angularDomain.slice();\n      if (needsEndSpacing && isOrdinal) angularDomainWithPadding[1] += angularDomainStep;\n      var tickCount = axisConfig.angularAxis.ticksCount || 4;\n      if (tickCount > 8) tickCount = tickCount / (tickCount / 8) + tickCount % 8;\n\n      if (axisConfig.angularAxis.ticksStep) {\n        tickCount = (angularDomainWithPadding[1] - angularDomainWithPadding[0]) / tickCount;\n      }\n\n      var angularTicksStep = axisConfig.angularAxis.ticksStep || (angularDomainWithPadding[1] - angularDomainWithPadding[0]) / (tickCount * (axisConfig.minorTicks + 1));\n      if (ticks) angularTicksStep = Math.max(Math.round(angularTicksStep), 1);\n      if (!angularDomainWithPadding[2]) angularDomainWithPadding[2] = angularTicksStep;\n      var angularAxisRange = d3.range.apply(this, angularDomainWithPadding);\n      angularAxisRange = angularAxisRange.map(function (d, i) {\n        return parseFloat(d.toPrecision(12));\n      });\n      angularScale = d3.scale.linear().domain(angularDomainWithPadding.slice(0, 2)).range(axisConfig.direction === 'clockwise' ? [0, 360] : [360, 0]);\n      liveConfig.layout.angularAxis.domain = angularScale.domain();\n      liveConfig.layout.angularAxis.endPadding = needsEndSpacing ? angularDomainStep : 0;\n      svg = d3.select(this).select('svg.chart-root');\n\n      if (typeof svg === 'undefined' || svg.empty()) {\n        var skeleton = \"<svg xmlns='http://www.w3.org/2000/svg' class='chart-root'>' + '<g class='outer-group'>' + '<g class='chart-group'>' + '<circle class='background-circle'></circle>' + '<g class='geometry-group'></g>' + '<g class='radial axis-group'>' + '<circle class='outside-circle'></circle>' + '</g>' + '<g class='angular axis-group'></g>' + '<g class='guides-group'><line></line><circle r='0'></circle></g>' + '</g>' + '<g class='legend-group'></g>' + '<g class='tooltips-group'></g>' + '<g class='title-group'><text></text></g>' + '</g>' + '</svg>\";\n        var doc = new DOMParser().parseFromString(skeleton, 'application/xml');\n        var newSvg = this.appendChild(this.ownerDocument.importNode(doc.documentElement, true));\n        svg = d3.select(newSvg);\n      }\n\n      svg.select('.guides-group').style({\n        'pointer-events': 'none'\n      });\n      svg.select('.angular.axis-group').style({\n        'pointer-events': 'none'\n      });\n      svg.select('.radial.axis-group').style({\n        'pointer-events': 'none'\n      });\n      var chartGroup = svg.select('.chart-group');\n      var lineStyle = {\n        fill: 'none',\n        stroke: axisConfig.tickColor\n      };\n      var fontStyle = {\n        'font-size': axisConfig.font.size,\n        'font-family': axisConfig.font.family,\n        fill: axisConfig.font.color,\n        'text-shadow': ['-1px 0px', '1px -1px', '-1px 1px', '1px 1px'].map(function (d, i) {\n          return ' ' + d + ' 0 ' + axisConfig.font.outlineColor;\n        }).join(',')\n      };\n      var legendContainer;\n\n      if (axisConfig.showLegend) {\n        legendContainer = svg.select('.legend-group').attr({\n          transform: 'translate(' + [radius, axisConfig.margin.top] + ')'\n        }).style({\n          display: 'block'\n        });\n        var elements = data.map(function (d, i) {\n          var datumClone = µ.util.cloneJson(d);\n          datumClone.symbol = d.geometry === 'DotPlot' ? d.dotType || 'circle' : d.geometry != 'LinePlot' ? 'square' : 'line';\n          datumClone.visibleInLegend = typeof d.visibleInLegend === 'undefined' || d.visibleInLegend;\n          datumClone.color = d.geometry === 'LinePlot' ? d.strokeColor : d.color;\n          return datumClone;\n        });\n        µ.Legend().config({\n          data: data.map(function (d, i) {\n            return d.name || 'Element' + i;\n          }),\n          legendConfig: extendDeepAll({}, µ.Legend.defaultConfig().legendConfig, {\n            container: legendContainer,\n            elements: elements,\n            reverseOrder: axisConfig.legend.reverseOrder\n          })\n        })();\n        var legendBBox = legendContainer.node().getBBox();\n        radius = Math.min(axisConfig.width - legendBBox.width - axisConfig.margin.left - axisConfig.margin.right, axisConfig.height - axisConfig.margin.top - axisConfig.margin.bottom) / 2;\n        radius = Math.max(10, radius);\n        chartCenter = [axisConfig.margin.left + radius, axisConfig.margin.top + radius];\n        radialScale.range([0, radius]);\n        liveConfig.layout.radialAxis.domain = radialScale.domain();\n        legendContainer.attr('transform', 'translate(' + [chartCenter[0] + radius, chartCenter[1] - radius] + ')');\n      } else {\n        legendContainer = svg.select('.legend-group').style({\n          display: 'none'\n        });\n      }\n\n      svg.attr({\n        width: axisConfig.width,\n        height: axisConfig.height\n      }).style({\n        opacity: axisConfig.opacity\n      });\n      chartGroup.attr('transform', 'translate(' + chartCenter + ')').style({\n        cursor: 'crosshair'\n      });\n      var centeringOffset = [(axisConfig.width - (axisConfig.margin.left + axisConfig.margin.right + radius * 2 + (legendBBox ? legendBBox.width : 0))) / 2, (axisConfig.height - (axisConfig.margin.top + axisConfig.margin.bottom + radius * 2)) / 2];\n      centeringOffset[0] = Math.max(0, centeringOffset[0]);\n      centeringOffset[1] = Math.max(0, centeringOffset[1]);\n      svg.select('.outer-group').attr('transform', 'translate(' + centeringOffset + ')');\n\n      if (axisConfig.title && axisConfig.title.text) {\n        var title = svg.select('g.title-group text').style(fontStyle).text(axisConfig.title.text);\n        var titleBBox = title.node().getBBox();\n        title.attr({\n          x: chartCenter[0] - titleBBox.width / 2,\n          y: chartCenter[1] - radius - 20\n        });\n      }\n\n      var radialAxis = svg.select('.radial.axis-group');\n\n      if (axisConfig.radialAxis.gridLinesVisible) {\n        var gridCircles = radialAxis.selectAll('circle.grid-circle').data(radialScale.ticks(5));\n        gridCircles.enter().append('circle').attr({\n          'class': 'grid-circle'\n        }).style(lineStyle);\n        gridCircles.attr('r', radialScale);\n        gridCircles.exit().remove();\n      }\n\n      radialAxis.select('circle.outside-circle').attr({\n        r: radius\n      }).style(lineStyle);\n      var backgroundCircle = svg.select('circle.background-circle').attr({\n        r: radius\n      }).style({\n        fill: axisConfig.backgroundColor,\n        stroke: axisConfig.stroke\n      });\n\n      function currentAngle(d, i) {\n        return angularScale(d) % 360 + axisConfig.orientation;\n      }\n\n      if (axisConfig.radialAxis.visible) {\n        var axis = d3.svg.axis().scale(radialScale).ticks(5).tickSize(5);\n        radialAxis.call(axis).attr({\n          transform: 'rotate(' + axisConfig.radialAxis.orientation + ')'\n        });\n        radialAxis.selectAll('.domain').style(lineStyle);\n        radialAxis.selectAll('g>text').text(function (d, i) {\n          return this.textContent + axisConfig.radialAxis.ticksSuffix;\n        }).style(fontStyle).style({\n          'text-anchor': 'start'\n        }).attr({\n          x: 0,\n          y: 0,\n          dx: 0,\n          dy: 0,\n          transform: function (d, i) {\n            if (axisConfig.radialAxis.tickOrientation === 'horizontal') {\n              return 'rotate(' + -axisConfig.radialAxis.orientation + ') translate(' + [0, fontStyle['font-size']] + ')';\n            } else return 'translate(' + [0, fontStyle['font-size']] + ')';\n          }\n        });\n        radialAxis.selectAll('g>line').style({\n          stroke: 'black'\n        });\n      }\n\n      var angularAxis = svg.select('.angular.axis-group').selectAll('g.angular-tick').data(angularAxisRange);\n      var angularAxisEnter = angularAxis.enter().append('g').classed('angular-tick', true);\n      angularAxis.attr({\n        transform: function (d, i) {\n          return 'rotate(' + currentAngle(d, i) + ')';\n        }\n      }).style({\n        display: axisConfig.angularAxis.visible ? 'block' : 'none'\n      });\n      angularAxis.exit().remove();\n      angularAxisEnter.append('line').classed('grid-line', true).classed('major', function (d, i) {\n        return i % (axisConfig.minorTicks + 1) == 0;\n      }).classed('minor', function (d, i) {\n        return !(i % (axisConfig.minorTicks + 1) == 0);\n      }).style(lineStyle);\n      angularAxisEnter.selectAll('.minor').style({\n        stroke: axisConfig.minorTickColor\n      });\n      angularAxis.select('line.grid-line').attr({\n        x1: axisConfig.tickLength ? radius - axisConfig.tickLength : 0,\n        x2: radius\n      }).style({\n        display: axisConfig.angularAxis.gridLinesVisible ? 'block' : 'none'\n      });\n      angularAxisEnter.append('text').classed('axis-text', true).style(fontStyle);\n      var ticksText = angularAxis.select('text.axis-text').attr({\n        x: radius + axisConfig.labelOffset,\n        dy: MID_SHIFT + 'em',\n        transform: function (d, i) {\n          var angle = currentAngle(d, i);\n          var rad = radius + axisConfig.labelOffset;\n          var orient = axisConfig.angularAxis.tickOrientation;\n          if (orient == 'horizontal') return 'rotate(' + -angle + ' ' + rad + ' 0)';else if (orient == 'radial') return angle < 270 && angle > 90 ? 'rotate(180 ' + rad + ' 0)' : null;else return 'rotate(' + (angle <= 180 && angle > 0 ? -90 : 90) + ' ' + rad + ' 0)';\n        }\n      }).style({\n        'text-anchor': 'middle',\n        display: axisConfig.angularAxis.labelsVisible ? 'block' : 'none'\n      }).text(function (d, i) {\n        if (i % (axisConfig.minorTicks + 1) != 0) return '';\n\n        if (ticks) {\n          return ticks[d] + axisConfig.angularAxis.ticksSuffix;\n        } else return d + axisConfig.angularAxis.ticksSuffix;\n      }).style(fontStyle);\n      if (axisConfig.angularAxis.rewriteTicks) ticksText.text(function (d, i) {\n        if (i % (axisConfig.minorTicks + 1) != 0) return '';\n        return axisConfig.angularAxis.rewriteTicks(this.textContent, i);\n      });\n      var rightmostTickEndX = d3.max(chartGroup.selectAll('.angular-tick text')[0].map(function (d, i) {\n        return d.getCTM().e + d.getBBox().width;\n      }));\n      legendContainer.attr({\n        transform: 'translate(' + [radius + rightmostTickEndX, axisConfig.margin.top] + ')'\n      });\n      var hasGeometry = svg.select('g.geometry-group').selectAll('g').size() > 0;\n      var geometryContainer = svg.select('g.geometry-group').selectAll('g.geometry').data(data);\n      geometryContainer.enter().append('g').attr({\n        'class': function (d, i) {\n          return 'geometry geometry' + i;\n        }\n      });\n      geometryContainer.exit().remove();\n\n      if (data[0] || hasGeometry) {\n        var geometryConfigs = [];\n        data.forEach(function (d, i) {\n          var geometryConfig = {};\n          geometryConfig.radialScale = radialScale;\n          geometryConfig.angularScale = angularScale;\n          geometryConfig.container = geometryContainer.filter(function (dB, iB) {\n            return iB == i;\n          });\n          geometryConfig.geometry = d.geometry;\n          geometryConfig.orientation = axisConfig.orientation;\n          geometryConfig.direction = axisConfig.direction;\n          geometryConfig.index = i;\n          geometryConfigs.push({\n            data: d,\n            geometryConfig: geometryConfig\n          });\n        });\n        var geometryConfigsGrouped = d3.nest().key(function (d, i) {\n          return typeof d.data.groupId != 'undefined' || 'unstacked';\n        }).entries(geometryConfigs);\n        var geometryConfigsGrouped2 = [];\n        geometryConfigsGrouped.forEach(function (d, i) {\n          if (d.key === 'unstacked') geometryConfigsGrouped2 = geometryConfigsGrouped2.concat(d.values.map(function (d, i) {\n            return [d];\n          }));else geometryConfigsGrouped2.push(d.values);\n        });\n        geometryConfigsGrouped2.forEach(function (d, i) {\n          var geometry;\n          if (Array.isArray(d)) geometry = d[0].geometryConfig.geometry;else geometry = d.geometryConfig.geometry;\n          var finalGeometryConfig = d.map(function (dB, iB) {\n            return extendDeepAll(µ[geometry].defaultConfig(), dB);\n          });\n          µ[geometry]().config(finalGeometryConfig)();\n        });\n      }\n\n      var guides = svg.select('.guides-group');\n      var tooltipContainer = svg.select('.tooltips-group');\n      var angularTooltip = µ.tooltipPanel().config({\n        container: tooltipContainer,\n        fontSize: 8\n      })();\n      var radialTooltip = µ.tooltipPanel().config({\n        container: tooltipContainer,\n        fontSize: 8\n      })();\n      var geometryTooltip = µ.tooltipPanel().config({\n        container: tooltipContainer,\n        hasTick: true\n      })();\n      var angularValue, radialValue;\n\n      if (!isOrdinal) {\n        var angularGuideLine = guides.select('line').attr({\n          x1: 0,\n          y1: 0,\n          y2: 0\n        }).style({\n          stroke: 'grey',\n          'pointer-events': 'none'\n        });\n        chartGroup.on('mousemove.angular-guide', function (d, i) {\n          var mouseAngle = µ.util.getMousePos(backgroundCircle).angle;\n          angularGuideLine.attr({\n            x2: -radius,\n            transform: 'rotate(' + mouseAngle + ')'\n          }).style({\n            opacity: .5\n          });\n          var angleWithOriginOffset = (mouseAngle + 180 + 360 - axisConfig.orientation) % 360;\n          angularValue = angularScale.invert(angleWithOriginOffset);\n          var pos = µ.util.convertToCartesian(radius + 12, mouseAngle + 180);\n          angularTooltip.text(µ.util.round(angularValue)).move([pos[0] + chartCenter[0], pos[1] + chartCenter[1]]);\n        }).on('mouseout.angular-guide', function (d, i) {\n          guides.select('line').style({\n            opacity: 0\n          });\n        });\n      }\n\n      var angularGuideCircle = guides.select('circle').style({\n        stroke: 'grey',\n        fill: 'none'\n      });\n      chartGroup.on('mousemove.radial-guide', function (d, i) {\n        var r = µ.util.getMousePos(backgroundCircle).radius;\n        angularGuideCircle.attr({\n          r: r\n        }).style({\n          opacity: .5\n        });\n        radialValue = radialScale.invert(µ.util.getMousePos(backgroundCircle).radius);\n        var pos = µ.util.convertToCartesian(r, axisConfig.radialAxis.orientation);\n        radialTooltip.text(µ.util.round(radialValue)).move([pos[0] + chartCenter[0], pos[1] + chartCenter[1]]);\n      }).on('mouseout.radial-guide', function (d, i) {\n        angularGuideCircle.style({\n          opacity: 0\n        });\n        geometryTooltip.hide();\n        angularTooltip.hide();\n        radialTooltip.hide();\n      });\n      svg.selectAll('.geometry-group .mark').on('mouseover.tooltip', function (d, i) {\n        var el = d3.select(this);\n        var color = this.style.fill;\n        var newColor = 'black';\n        var opacity = this.style.opacity || 1;\n        el.attr({\n          'data-opacity': opacity\n        });\n\n        if (color && color !== 'none') {\n          el.attr({\n            'data-fill': color\n          });\n          newColor = d3.hsl(color).darker().toString();\n          el.style({\n            fill: newColor,\n            opacity: 1\n          });\n          var textData = {\n            t: µ.util.round(d[0]),\n            r: µ.util.round(d[1])\n          };\n          if (isOrdinal) textData.t = ticks[d[0]];\n          var text = 't: ' + textData.t + ', r: ' + textData.r;\n          var bbox = this.getBoundingClientRect();\n          var svgBBox = svg.node().getBoundingClientRect();\n          var pos = [bbox.left + bbox.width / 2 - centeringOffset[0] - svgBBox.left, bbox.top + bbox.height / 2 - centeringOffset[1] - svgBBox.top];\n          geometryTooltip.config({\n            color: newColor\n          }).text(text);\n          geometryTooltip.move(pos);\n        } else {\n          color = this.style.stroke || 'black';\n          el.attr({\n            'data-stroke': color\n          });\n          newColor = d3.hsl(color).darker().toString();\n          el.style({\n            stroke: newColor,\n            opacity: 1\n          });\n        }\n      }).on('mousemove.tooltip', function (d, i) {\n        if (d3.event.which != 0) return false;\n        if (d3.select(this).attr('data-fill')) geometryTooltip.show();\n      }).on('mouseout.tooltip', function (d, i) {\n        geometryTooltip.hide();\n        var el = d3.select(this);\n        var fillColor = el.attr('data-fill');\n        if (fillColor) el.style({\n          fill: fillColor,\n          opacity: el.attr('data-opacity')\n        });else el.style({\n          stroke: el.attr('data-stroke'),\n          opacity: el.attr('data-opacity')\n        });\n      });\n    });\n    return exports;\n  }\n\n  exports.render = function (_container) {\n    render(_container);\n    return this;\n  };\n\n  exports.config = function (_x) {\n    if (!arguments.length) return config;\n    var xClone = µ.util.cloneJson(_x);\n    xClone.data.forEach(function (d, i) {\n      if (!config.data[i]) config.data[i] = {};\n      extendDeepAll(config.data[i], µ.Axis.defaultConfig().data[0]);\n      extendDeepAll(config.data[i], d);\n    });\n    extendDeepAll(config.layout, µ.Axis.defaultConfig().layout);\n    extendDeepAll(config.layout, xClone.layout);\n    return this;\n  };\n\n  exports.getLiveConfig = function () {\n    return liveConfig;\n  };\n\n  exports.getinputConfig = function () {\n    return inputConfig;\n  };\n\n  exports.radialScale = function (_x) {\n    return radialScale;\n  };\n\n  exports.angularScale = function (_x) {\n    return angularScale;\n  };\n\n  exports.svg = function () {\n    return svg;\n  };\n\n  d3.rebind(exports, dispatch, 'on');\n  return exports;\n};\n\nµ.Axis.defaultConfig = function (d, i) {\n  var config = {\n    data: [{\n      t: [1, 2, 3, 4],\n      r: [10, 11, 12, 13],\n      name: 'Line1',\n      geometry: 'LinePlot',\n      color: null,\n      strokeDash: 'solid',\n      strokeColor: null,\n      strokeSize: '1',\n      visibleInLegend: true,\n      opacity: 1\n    }],\n    layout: {\n      defaultColorRange: d3.scale.category10().range(),\n      title: null,\n      height: 450,\n      width: 500,\n      margin: {\n        top: 40,\n        right: 40,\n        bottom: 40,\n        left: 40\n      },\n      font: {\n        size: 12,\n        color: 'gray',\n        outlineColor: 'white',\n        family: 'Tahoma, sans-serif'\n      },\n      direction: 'clockwise',\n      orientation: 0,\n      labelOffset: 10,\n      radialAxis: {\n        domain: null,\n        orientation: -45,\n        ticksSuffix: '',\n        visible: true,\n        gridLinesVisible: true,\n        tickOrientation: 'horizontal',\n        rewriteTicks: null\n      },\n      angularAxis: {\n        domain: [0, 360],\n        ticksSuffix: '',\n        visible: true,\n        gridLinesVisible: true,\n        labelsVisible: true,\n        tickOrientation: 'horizontal',\n        rewriteTicks: null,\n        ticksCount: null,\n        ticksStep: null\n      },\n      minorTicks: 0,\n      tickLength: null,\n      tickColor: 'silver',\n      minorTickColor: '#eee',\n      backgroundColor: 'none',\n      needsEndSpacing: null,\n      showLegend: true,\n      legend: {\n        reverseOrder: false\n      },\n      opacity: 1\n    }\n  };\n  return config;\n};\n\nµ.util = {};\nµ.DATAEXTENT = 'dataExtent';\nµ.AREA = 'AreaChart';\nµ.LINE = 'LinePlot';\nµ.DOT = 'DotPlot';\nµ.BAR = 'BarChart';\n\nµ.util._override = function (_objA, _objB) {\n  for (var x in _objA) if (x in _objB) _objB[x] = _objA[x];\n};\n\nµ.util._extend = function (_objA, _objB) {\n  for (var x in _objA) _objB[x] = _objA[x];\n};\n\nµ.util._rndSnd = function () {\n  return Math.random() * 2 - 1 + (Math.random() * 2 - 1) + (Math.random() * 2 - 1);\n};\n\nµ.util.dataFromEquation2 = function (_equation, _step) {\n  var step = _step || 6;\n  var data = d3.range(0, 360 + step, step).map(function (deg, index) {\n    var theta = deg * Math.PI / 180;\n\n    var radius = _equation(theta);\n\n    return [deg, radius];\n  });\n  return data;\n};\n\nµ.util.dataFromEquation = function (_equation, _step, _name) {\n  var step = _step || 6;\n  var t = [],\n      r = [];\n  d3.range(0, 360 + step, step).forEach(function (deg, index) {\n    var theta = deg * Math.PI / 180;\n\n    var radius = _equation(theta);\n\n    t.push(deg);\n    r.push(radius);\n  });\n  var result = {\n    t: t,\n    r: r\n  };\n  if (_name) result.name = _name;\n  return result;\n};\n\nµ.util.ensureArray = function (_val, _count) {\n  if (typeof _val === 'undefined') return null;\n  var arr = [].concat(_val);\n  return d3.range(_count).map(function (d, i) {\n    return arr[i] || arr[0];\n  });\n};\n\nµ.util.fillArrays = function (_obj, _valueNames, _count) {\n  _valueNames.forEach(function (d, i) {\n    _obj[d] = µ.util.ensureArray(_obj[d], _count);\n  });\n\n  return _obj;\n};\n\nµ.util.cloneJson = function (json) {\n  return JSON.parse(JSON.stringify(json));\n};\n\nµ.util.validateKeys = function (obj, keys) {\n  if (typeof keys === 'string') keys = keys.split('.');\n  var next = keys.shift();\n  return obj[next] && (!keys.length || objHasKeys(obj[next], keys));\n};\n\nµ.util.sumArrays = function (a, b) {\n  return d3.zip(a, b).map(function (d, i) {\n    return d3.sum(d);\n  });\n};\n\nµ.util.arrayLast = function (a) {\n  return a[a.length - 1];\n};\n\nµ.util.arrayEqual = function (a, b) {\n  var i = Math.max(a.length, b.length, 1);\n\n  while (i-- >= 0 && a[i] === b[i]);\n\n  return i === -2;\n};\n\nµ.util.flattenArray = function (arr) {\n  var r = [];\n\n  while (!µ.util.arrayEqual(r, arr)) {\n    r = arr;\n    arr = [].concat.apply([], arr);\n  }\n\n  return arr;\n};\n\nµ.util.deduplicate = function (arr) {\n  return arr.filter(function (v, i, a) {\n    return a.indexOf(v) == i;\n  });\n};\n\nµ.util.convertToCartesian = function (radius, theta) {\n  var thetaRadians = theta * Math.PI / 180;\n  var x = radius * Math.cos(thetaRadians);\n  var y = radius * Math.sin(thetaRadians);\n  return [x, y];\n};\n\nµ.util.round = function (_value, _digits) {\n  var digits = _digits || 2;\n  var mult = Math.pow(10, digits);\n  return Math.round(_value * mult) / mult;\n};\n\nµ.util.getMousePos = function (_referenceElement) {\n  var mousePos = d3.mouse(_referenceElement.node());\n  var mouseX = mousePos[0];\n  var mouseY = mousePos[1];\n  var mouse = {};\n  mouse.x = mouseX;\n  mouse.y = mouseY;\n  mouse.pos = mousePos;\n  mouse.angle = (Math.atan2(mouseY, mouseX) + Math.PI) * 180 / Math.PI;\n  mouse.radius = Math.sqrt(mouseX * mouseX + mouseY * mouseY);\n  return mouse;\n};\n\nµ.util.duplicatesCount = function (arr) {\n  var uniques = {},\n      val;\n  var dups = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    val = arr[i];\n\n    if (val in uniques) {\n      uniques[val]++;\n      dups[val] = uniques[val];\n    } else {\n      uniques[val] = 1;\n    }\n  }\n\n  return dups;\n};\n\nµ.util.duplicates = function (arr) {\n  return Object.keys(µ.util.duplicatesCount(arr));\n};\n\nµ.util.translator = function (obj, sourceBranch, targetBranch, reverse) {\n  if (reverse) {\n    var targetBranchCopy = targetBranch.slice();\n    targetBranch = sourceBranch;\n    sourceBranch = targetBranchCopy;\n  }\n\n  var value = sourceBranch.reduce(function (previousValue, currentValue) {\n    if (typeof previousValue != 'undefined') return previousValue[currentValue];\n  }, obj);\n  if (typeof value === 'undefined') return;\n  sourceBranch.reduce(function (previousValue, currentValue, index) {\n    if (typeof previousValue == 'undefined') return;\n    if (index === sourceBranch.length - 1) delete previousValue[currentValue];\n    return previousValue[currentValue];\n  }, obj);\n  targetBranch.reduce(function (previousValue, currentValue, index) {\n    if (typeof previousValue[currentValue] === 'undefined') previousValue[currentValue] = {};\n    if (index === targetBranch.length - 1) previousValue[currentValue] = value;\n    return previousValue[currentValue];\n  }, obj);\n};\n\nµ.PolyChart = function module() {\n  var config = [µ.PolyChart.defaultConfig()];\n  var dispatch = d3.dispatch('hover');\n  var dashArray = {\n    solid: 'none',\n    dash: [5, 2],\n    dot: [2, 5]\n  };\n  var colorScale;\n\n  function exports() {\n    var geometryConfig = config[0].geometryConfig;\n    var container = geometryConfig.container;\n    if (typeof container == 'string') container = d3.select(container);\n    container.datum(config).each(function (_config, _index) {\n      var isStack = !!_config[0].data.yStack;\n\n      var data = _config.map(function (d, i) {\n        if (isStack) return d3.zip(d.data.t[0], d.data.r[0], d.data.yStack[0]);else return d3.zip(d.data.t[0], d.data.r[0]);\n      });\n\n      var angularScale = geometryConfig.angularScale;\n      var domainMin = geometryConfig.radialScale.domain()[0];\n      var generator = {};\n\n      generator.bar = function (d, i, pI) {\n        var dataConfig = _config[pI].data;\n        var h = geometryConfig.radialScale(d[1]) - geometryConfig.radialScale(0);\n        var stackTop = geometryConfig.radialScale(d[2] || 0);\n        var w = dataConfig.barWidth;\n        d3.select(this).attr({\n          'class': 'mark bar',\n          d: 'M' + [[h + stackTop, -w / 2], [h + stackTop, w / 2], [stackTop, w / 2], [stackTop, -w / 2]].join('L') + 'Z',\n          transform: function (d, i) {\n            return 'rotate(' + (geometryConfig.orientation + angularScale(d[0])) + ')';\n          }\n        });\n      };\n\n      generator.dot = function (d, i, pI) {\n        var stackedData = d[2] ? [d[0], d[1] + d[2]] : d;\n        var symbol = d3.svg.symbol().size(_config[pI].data.dotSize).type(_config[pI].data.dotType)(d, i);\n        d3.select(this).attr({\n          'class': 'mark dot',\n          d: symbol,\n          transform: function (d, i) {\n            var coord = convertToCartesian(getPolarCoordinates(stackedData));\n            return 'translate(' + [coord.x, coord.y] + ')';\n          }\n        });\n      };\n\n      var line = d3.svg.line.radial().interpolate(_config[0].data.lineInterpolation).radius(function (d) {\n        return geometryConfig.radialScale(d[1]);\n      }).angle(function (d) {\n        return geometryConfig.angularScale(d[0]) * Math.PI / 180;\n      });\n\n      generator.line = function (d, i, pI) {\n        var lineData = d[2] ? data[pI].map(function (d, i) {\n          return [d[0], d[1] + d[2]];\n        }) : data[pI];\n        d3.select(this).each(generator['dot']).style({\n          opacity: function (dB, iB) {\n            return +_config[pI].data.dotVisible;\n          },\n          fill: markStyle.stroke(d, i, pI)\n        }).attr({\n          'class': 'mark dot'\n        });\n        if (i > 0) return;\n        var lineSelection = d3.select(this.parentNode).selectAll('path.line').data([0]);\n        lineSelection.enter().insert('path');\n        lineSelection.attr({\n          'class': 'line',\n          d: line(lineData),\n          transform: function (dB, iB) {\n            return 'rotate(' + (geometryConfig.orientation + 90) + ')';\n          },\n          'pointer-events': 'none'\n        }).style({\n          fill: function (dB, iB) {\n            return markStyle.fill(d, i, pI);\n          },\n          'fill-opacity': 0,\n          stroke: function (dB, iB) {\n            return markStyle.stroke(d, i, pI);\n          },\n          'stroke-width': function (dB, iB) {\n            return markStyle['stroke-width'](d, i, pI);\n          },\n          'stroke-dasharray': function (dB, iB) {\n            return markStyle['stroke-dasharray'](d, i, pI);\n          },\n          opacity: function (dB, iB) {\n            return markStyle.opacity(d, i, pI);\n          },\n          display: function (dB, iB) {\n            return markStyle.display(d, i, pI);\n          }\n        });\n      };\n\n      var angularRange = geometryConfig.angularScale.range();\n      var triangleAngle = Math.abs(angularRange[1] - angularRange[0]) / data[0].length * Math.PI / 180;\n      var arc = d3.svg.arc().startAngle(function (d) {\n        return -triangleAngle / 2;\n      }).endAngle(function (d) {\n        return triangleAngle / 2;\n      }).innerRadius(function (d) {\n        return geometryConfig.radialScale(domainMin + (d[2] || 0));\n      }).outerRadius(function (d) {\n        return geometryConfig.radialScale(domainMin + (d[2] || 0)) + geometryConfig.radialScale(d[1]);\n      });\n\n      generator.arc = function (d, i, pI) {\n        d3.select(this).attr({\n          'class': 'mark arc',\n          d: arc,\n          transform: function (d, i) {\n            return 'rotate(' + (geometryConfig.orientation + angularScale(d[0]) + 90) + ')';\n          }\n        });\n      };\n\n      var markStyle = {\n        fill: function (d, i, pI) {\n          return _config[pI].data.color;\n        },\n        stroke: function (d, i, pI) {\n          return _config[pI].data.strokeColor;\n        },\n        'stroke-width': function (d, i, pI) {\n          return _config[pI].data.strokeSize + 'px';\n        },\n        'stroke-dasharray': function (d, i, pI) {\n          return dashArray[_config[pI].data.strokeDash];\n        },\n        opacity: function (d, i, pI) {\n          return _config[pI].data.opacity;\n        },\n        display: function (d, i, pI) {\n          return typeof _config[pI].data.visible === 'undefined' || _config[pI].data.visible ? 'block' : 'none';\n        }\n      };\n      var geometryLayer = d3.select(this).selectAll('g.layer').data(data);\n      geometryLayer.enter().append('g').attr({\n        'class': 'layer'\n      });\n      var geometry = geometryLayer.selectAll('path.mark').data(function (d, i) {\n        return d;\n      });\n      geometry.enter().append('path').attr({\n        'class': 'mark'\n      });\n      geometry.style(markStyle).each(generator[geometryConfig.geometryType]);\n      geometry.exit().remove();\n      geometryLayer.exit().remove();\n\n      function getPolarCoordinates(d, i) {\n        var r = geometryConfig.radialScale(d[1]);\n        var t = (geometryConfig.angularScale(d[0]) + geometryConfig.orientation) * Math.PI / 180;\n        return {\n          r: r,\n          t: t\n        };\n      }\n\n      function convertToCartesian(polarCoordinates) {\n        var x = polarCoordinates.r * Math.cos(polarCoordinates.t);\n        var y = polarCoordinates.r * Math.sin(polarCoordinates.t);\n        return {\n          x: x,\n          y: y\n        };\n      }\n    });\n  }\n\n  exports.config = function (_x) {\n    if (!arguments.length) return config;\n\n    _x.forEach(function (d, i) {\n      if (!config[i]) config[i] = {};\n      extendDeepAll(config[i], µ.PolyChart.defaultConfig());\n      extendDeepAll(config[i], d);\n    });\n\n    return this;\n  };\n\n  exports.getColorScale = function () {\n    return colorScale;\n  };\n\n  d3.rebind(exports, dispatch, 'on');\n  return exports;\n};\n\nµ.PolyChart.defaultConfig = function () {\n  var config = {\n    data: {\n      name: 'geom1',\n      t: [[1, 2, 3, 4]],\n      r: [[1, 2, 3, 4]],\n      dotType: 'circle',\n      dotSize: 64,\n      dotVisible: false,\n      barWidth: 20,\n      color: '#ffa500',\n      strokeSize: 1,\n      strokeColor: 'silver',\n      strokeDash: 'solid',\n      opacity: 1,\n      index: 0,\n      visible: true,\n      visibleInLegend: true\n    },\n    geometryConfig: {\n      geometry: 'LinePlot',\n      geometryType: 'arc',\n      direction: 'clockwise',\n      orientation: 0,\n      container: 'body',\n      radialScale: null,\n      angularScale: null,\n      colorScale: d3.scale.category20()\n    }\n  };\n  return config;\n};\n\nµ.BarChart = function module() {\n  return µ.PolyChart();\n};\n\nµ.BarChart.defaultConfig = function () {\n  var config = {\n    geometryConfig: {\n      geometryType: 'bar'\n    }\n  };\n  return config;\n};\n\nµ.AreaChart = function module() {\n  return µ.PolyChart();\n};\n\nµ.AreaChart.defaultConfig = function () {\n  var config = {\n    geometryConfig: {\n      geometryType: 'arc'\n    }\n  };\n  return config;\n};\n\nµ.DotPlot = function module() {\n  return µ.PolyChart();\n};\n\nµ.DotPlot.defaultConfig = function () {\n  var config = {\n    geometryConfig: {\n      geometryType: 'dot',\n      dotType: 'circle'\n    }\n  };\n  return config;\n};\n\nµ.LinePlot = function module() {\n  return µ.PolyChart();\n};\n\nµ.LinePlot.defaultConfig = function () {\n  var config = {\n    geometryConfig: {\n      geometryType: 'line'\n    }\n  };\n  return config;\n};\n\nµ.Legend = function module() {\n  var config = µ.Legend.defaultConfig();\n  var dispatch = d3.dispatch('hover');\n\n  function exports() {\n    var legendConfig = config.legendConfig;\n    var flattenData = config.data.map(function (d, i) {\n      return [].concat(d).map(function (dB, iB) {\n        var element = extendDeepAll({}, legendConfig.elements[i]);\n        element.name = dB;\n        element.color = [].concat(legendConfig.elements[i].color)[iB];\n        return element;\n      });\n    });\n    var data = d3.merge(flattenData);\n    data = data.filter(function (d, i) {\n      return legendConfig.elements[i] && (legendConfig.elements[i].visibleInLegend || typeof legendConfig.elements[i].visibleInLegend === 'undefined');\n    });\n    if (legendConfig.reverseOrder) data = data.reverse();\n    var container = legendConfig.container;\n    if (typeof container == 'string' || container.nodeName) container = d3.select(container);\n    var colors = data.map(function (d, i) {\n      return d.color;\n    });\n    var lineHeight = legendConfig.fontSize;\n    var isContinuous = legendConfig.isContinuous == null ? typeof data[0] === 'number' : legendConfig.isContinuous;\n    var height = isContinuous ? legendConfig.height : lineHeight * data.length;\n    var legendContainerGroup = container.classed('legend-group', true);\n    var svg = legendContainerGroup.selectAll('svg').data([0]);\n    var svgEnter = svg.enter().append('svg').attr({\n      width: 300,\n      height: height + lineHeight,\n      xmlns: 'http://www.w3.org/2000/svg',\n      'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n      version: '1.1'\n    });\n    svgEnter.append('g').classed('legend-axis', true);\n    svgEnter.append('g').classed('legend-marks', true);\n    var dataNumbered = d3.range(data.length);\n    var colorScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered).range(colors);\n    var dataScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered)[isContinuous ? 'range' : 'rangePoints']([0, height]);\n\n    var shapeGenerator = function (_type, _size) {\n      var squareSize = _size * 3;\n\n      if (_type === 'line') {\n        return 'M' + [[-_size / 2, -_size / 12], [_size / 2, -_size / 12], [_size / 2, _size / 12], [-_size / 2, _size / 12]] + 'Z';\n      } else if (d3.svg.symbolTypes.indexOf(_type) != -1) return d3.svg.symbol().type(_type).size(squareSize)();else return d3.svg.symbol().type('square').size(squareSize)();\n    };\n\n    if (isContinuous) {\n      var gradient = svg.select('.legend-marks').append('defs').append('linearGradient').attr({\n        id: 'grad1',\n        x1: '0%',\n        y1: '0%',\n        x2: '0%',\n        y2: '100%'\n      }).selectAll('stop').data(colors);\n      gradient.enter().append('stop');\n      gradient.attr({\n        offset: function (d, i) {\n          return i / (colors.length - 1) * 100 + '%';\n        }\n      }).style({\n        'stop-color': function (d, i) {\n          return d;\n        }\n      });\n      svg.append('rect').classed('legend-mark', true).attr({\n        height: legendConfig.height,\n        width: legendConfig.colorBandWidth,\n        fill: 'url(#grad1)'\n      });\n    } else {\n      var legendElement = svg.select('.legend-marks').selectAll('path.legend-mark').data(data);\n      legendElement.enter().append('path').classed('legend-mark', true);\n      legendElement.attr({\n        transform: function (d, i) {\n          return 'translate(' + [lineHeight / 2, dataScale(i) + lineHeight / 2] + ')';\n        },\n        d: function (d, i) {\n          var symbolType = d.symbol;\n          return shapeGenerator(symbolType, lineHeight);\n        },\n        fill: function (d, i) {\n          return colorScale(i);\n        }\n      });\n      legendElement.exit().remove();\n    }\n\n    var legendAxis = d3.svg.axis().scale(dataScale).orient('right');\n    var axis = svg.select('g.legend-axis').attr({\n      transform: 'translate(' + [isContinuous ? legendConfig.colorBandWidth : lineHeight, lineHeight / 2] + ')'\n    }).call(legendAxis);\n    axis.selectAll('.domain').style({\n      fill: 'none',\n      stroke: 'none'\n    });\n    axis.selectAll('line').style({\n      fill: 'none',\n      stroke: isContinuous ? legendConfig.textColor : 'none'\n    });\n    axis.selectAll('text').style({\n      fill: legendConfig.textColor,\n      'font-size': legendConfig.fontSize\n    }).text(function (d, i) {\n      return data[i].name;\n    });\n    return exports;\n  }\n\n  exports.config = function (_x) {\n    if (!arguments.length) return config;\n    extendDeepAll(config, _x);\n    return this;\n  };\n\n  d3.rebind(exports, dispatch, 'on');\n  return exports;\n};\n\nµ.Legend.defaultConfig = function (d, i) {\n  var config = {\n    data: ['a', 'b', 'c'],\n    legendConfig: {\n      elements: [{\n        symbol: 'line',\n        color: 'red'\n      }, {\n        symbol: 'square',\n        color: 'yellow'\n      }, {\n        symbol: 'diamond',\n        color: 'limegreen'\n      }],\n      height: 150,\n      colorBandWidth: 30,\n      fontSize: 12,\n      container: 'body',\n      isContinuous: null,\n      textColor: 'grey',\n      reverseOrder: false\n    }\n  };\n  return config;\n};\n\nµ.tooltipPanel = function () {\n  var tooltipEl, tooltipTextEl, backgroundEl;\n  var config = {\n    container: null,\n    hasTick: false,\n    fontSize: 12,\n    color: 'white',\n    padding: 5\n  };\n  var id = 'tooltip-' + µ.tooltipPanel.uid++;\n  var tickSize = 10;\n\n  var exports = function () {\n    tooltipEl = config.container.selectAll('g.' + id).data([0]);\n    var tooltipEnter = tooltipEl.enter().append('g').classed(id, true).style({\n      'pointer-events': 'none',\n      display: 'none'\n    });\n    backgroundEl = tooltipEnter.append('path').style({\n      fill: 'white',\n      'fill-opacity': .9\n    }).attr({\n      d: 'M0 0'\n    });\n    tooltipTextEl = tooltipEnter.append('text').attr({\n      dx: config.padding + tickSize,\n      dy: +config.fontSize * .3\n    });\n    return exports;\n  };\n\n  exports.text = function (_text) {\n    var l = d3.hsl(config.color).l;\n    var strokeColor = l >= .5 ? '#aaa' : 'white';\n    var fillColor = l >= .5 ? 'black' : 'white';\n    var text = _text || '';\n    tooltipTextEl.style({\n      fill: fillColor,\n      'font-size': config.fontSize + 'px'\n    }).text(text);\n    var padding = config.padding;\n    var bbox = tooltipTextEl.node().getBBox();\n    var boxStyle = {\n      fill: config.color,\n      stroke: strokeColor,\n      'stroke-width': '2px'\n    };\n    var backGroundW = bbox.width + padding * 2 + tickSize;\n    var backGroundH = bbox.height + padding * 2;\n    backgroundEl.attr({\n      d: 'M' + [[tickSize, -backGroundH / 2], [tickSize, -backGroundH / 4], [config.hasTick ? 0 : tickSize, 0], [tickSize, backGroundH / 4], [tickSize, backGroundH / 2], [backGroundW, backGroundH / 2], [backGroundW, -backGroundH / 2]].join('L') + 'Z'\n    }).style(boxStyle);\n    tooltipEl.attr({\n      transform: 'translate(' + [tickSize, -backGroundH / 2 + padding * 2] + ')'\n    });\n    tooltipEl.style({\n      display: 'block'\n    });\n    return exports;\n  };\n\n  exports.move = function (_pos) {\n    if (!tooltipEl) return;\n    tooltipEl.attr({\n      transform: 'translate(' + [_pos[0], _pos[1]] + ')'\n    }).style({\n      display: 'block'\n    });\n    return exports;\n  };\n\n  exports.hide = function () {\n    if (!tooltipEl) return;\n    tooltipEl.style({\n      display: 'none'\n    });\n    return exports;\n  };\n\n  exports.show = function () {\n    if (!tooltipEl) return;\n    tooltipEl.style({\n      display: 'block'\n    });\n    return exports;\n  };\n\n  exports.config = function (_x) {\n    extendDeepAll(config, _x);\n    return exports;\n  };\n\n  return exports;\n};\n\nµ.tooltipPanel.uid = 1;\nµ.adapter = {};\n\nµ.adapter.plotly = function module() {\n  var exports = {};\n\n  exports.convert = function (_inputConfig, reverse) {\n    var outputConfig = {};\n\n    if (_inputConfig.data) {\n      outputConfig.data = _inputConfig.data.map(function (d, i) {\n        var r = extendDeepAll({}, d);\n        var toTranslate = [[r, ['marker', 'color'], ['color']], [r, ['marker', 'opacity'], ['opacity']], [r, ['marker', 'line', 'color'], ['strokeColor']], [r, ['marker', 'line', 'dash'], ['strokeDash']], [r, ['marker', 'line', 'width'], ['strokeSize']], [r, ['marker', 'symbol'], ['dotType']], [r, ['marker', 'size'], ['dotSize']], [r, ['marker', 'barWidth'], ['barWidth']], [r, ['line', 'interpolation'], ['lineInterpolation']], [r, ['showlegend'], ['visibleInLegend']]];\n        toTranslate.forEach(function (d, i) {\n          µ.util.translator.apply(null, d.concat(reverse));\n        });\n        if (!reverse) delete r.marker;\n        if (reverse) delete r.groupId;\n\n        if (!reverse) {\n          if (r.type === 'scatter') {\n            if (r.mode === 'lines') r.geometry = 'LinePlot';else if (r.mode === 'markers') r.geometry = 'DotPlot';else if (r.mode === 'lines+markers') {\n              r.geometry = 'LinePlot';\n              r.dotVisible = true;\n            }\n          } else if (r.type === 'area') r.geometry = 'AreaChart';else if (r.type === 'bar') r.geometry = 'BarChart';\n\n          delete r.mode;\n          delete r.type;\n        } else {\n          if (r.geometry === 'LinePlot') {\n            r.type = 'scatter';\n\n            if (r.dotVisible === true) {\n              delete r.dotVisible;\n              r.mode = 'lines+markers';\n            } else r.mode = 'lines';\n          } else if (r.geometry === 'DotPlot') {\n            r.type = 'scatter';\n            r.mode = 'markers';\n          } else if (r.geometry === 'AreaChart') r.type = 'area';else if (r.geometry === 'BarChart') r.type = 'bar';\n\n          delete r.geometry;\n        }\n\n        return r;\n      });\n\n      if (!reverse && _inputConfig.layout && _inputConfig.layout.barmode === 'stack') {\n        var duplicates = µ.util.duplicates(outputConfig.data.map(function (d, i) {\n          return d.geometry;\n        }));\n        outputConfig.data.forEach(function (d, i) {\n          var idx = duplicates.indexOf(d.geometry);\n          if (idx != -1) outputConfig.data[i].groupId = idx;\n        });\n      }\n    }\n\n    if (_inputConfig.layout) {\n      var r = extendDeepAll({}, _inputConfig.layout);\n      var toTranslate = [[r, ['plot_bgcolor'], ['backgroundColor']], [r, ['showlegend'], ['showLegend']], [r, ['radialaxis'], ['radialAxis']], [r, ['angularaxis'], ['angularAxis']], [r.angularaxis, ['showline'], ['gridLinesVisible']], [r.angularaxis, ['showticklabels'], ['labelsVisible']], [r.angularaxis, ['nticks'], ['ticksCount']], [r.angularaxis, ['tickorientation'], ['tickOrientation']], [r.angularaxis, ['ticksuffix'], ['ticksSuffix']], [r.angularaxis, ['range'], ['domain']], [r.angularaxis, ['endpadding'], ['endPadding']], [r.radialaxis, ['showline'], ['gridLinesVisible']], [r.radialaxis, ['tickorientation'], ['tickOrientation']], [r.radialaxis, ['ticksuffix'], ['ticksSuffix']], [r.radialaxis, ['range'], ['domain']], [r.angularAxis, ['showline'], ['gridLinesVisible']], [r.angularAxis, ['showticklabels'], ['labelsVisible']], [r.angularAxis, ['nticks'], ['ticksCount']], [r.angularAxis, ['tickorientation'], ['tickOrientation']], [r.angularAxis, ['ticksuffix'], ['ticksSuffix']], [r.angularAxis, ['range'], ['domain']], [r.angularAxis, ['endpadding'], ['endPadding']], [r.radialAxis, ['showline'], ['gridLinesVisible']], [r.radialAxis, ['tickorientation'], ['tickOrientation']], [r.radialAxis, ['ticksuffix'], ['ticksSuffix']], [r.radialAxis, ['range'], ['domain']], [r.font, ['outlinecolor'], ['outlineColor']], [r.legend, ['traceorder'], ['reverseOrder']], [r, ['labeloffset'], ['labelOffset']], [r, ['defaultcolorrange'], ['defaultColorRange']]];\n      toTranslate.forEach(function (d, i) {\n        µ.util.translator.apply(null, d.concat(reverse));\n      });\n\n      if (!reverse) {\n        if (r.angularAxis && typeof r.angularAxis.ticklen !== 'undefined') r.tickLength = r.angularAxis.ticklen;\n        if (r.angularAxis && typeof r.angularAxis.tickcolor !== 'undefined') r.tickColor = r.angularAxis.tickcolor;\n      } else {\n        if (typeof r.tickLength !== 'undefined') {\n          r.angularaxis.ticklen = r.tickLength;\n          delete r.tickLength;\n        }\n\n        if (r.tickColor) {\n          r.angularaxis.tickcolor = r.tickColor;\n          delete r.tickColor;\n        }\n      }\n\n      if (r.legend && typeof r.legend.reverseOrder != 'boolean') {\n        r.legend.reverseOrder = r.legend.reverseOrder != 'normal';\n      }\n\n      if (r.legend && typeof r.legend.traceorder == 'boolean') {\n        r.legend.traceorder = r.legend.traceorder ? 'reversed' : 'normal';\n        delete r.legend.reverseOrder;\n      }\n\n      if (r.margin && typeof r.margin.t != 'undefined') {\n        var source = ['t', 'r', 'b', 'l', 'pad'];\n        var target = ['top', 'right', 'bottom', 'left', 'pad'];\n        var margin = {};\n        d3.entries(r.margin).forEach(function (dB, iB) {\n          margin[target[source.indexOf(dB.key)]] = dB.value;\n        });\n        r.margin = margin;\n      }\n\n      if (reverse) {\n        delete r.needsEndSpacing;\n        delete r.minorTickColor;\n        delete r.minorTicks;\n        delete r.angularaxis.ticksCount;\n        delete r.angularaxis.ticksCount;\n        delete r.angularaxis.ticksStep;\n        delete r.angularaxis.rewriteTicks;\n        delete r.angularaxis.nticks;\n        delete r.radialaxis.ticksCount;\n        delete r.radialaxis.ticksCount;\n        delete r.radialaxis.ticksStep;\n        delete r.radialaxis.rewriteTicks;\n        delete r.radialaxis.nticks;\n      }\n\n      outputConfig.layout = r;\n    }\n\n    return outputConfig;\n  };\n\n  return exports;\n};","map":null,"metadata":{},"sourceType":"script"}