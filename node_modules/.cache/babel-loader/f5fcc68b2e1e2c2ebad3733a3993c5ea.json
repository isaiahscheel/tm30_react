{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar boxPlot = require('../box/plot');\n\nvar linePoints = require('../scatter/line_points');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {\n  var fullLayout = gd._fullLayout;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n\n  function makePath(pts) {\n    var segments = linePoints(pts, {\n      xaxis: xa,\n      yaxis: ya,\n      connectGaps: true,\n      baseTolerance: 0.75,\n      shape: 'spline',\n      simplify: true,\n      linearized: true\n    });\n    return Drawing.smoothopen(segments[0], 1);\n  }\n\n  Lib.makeTraceGroups(violinLayer, cdViolins, 'trace violins').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace;\n\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n\n    var bPos = t.bPos;\n    var bdPos = t.bdPos;\n    var valAxis = plotinfo[t.valLetter + 'axis'];\n    var posAxis = plotinfo[t.posLetter + 'axis'];\n    var hasBothSides = trace.side === 'both';\n    var hasPositiveSide = hasBothSides || trace.side === 'positive';\n    var hasNegativeSide = hasBothSides || trace.side === 'negative';\n    var violins = plotGroup.selectAll('path.violin').data(Lib.identity);\n    violins.enter().append('path').style('vector-effect', 'non-scaling-stroke').attr('class', 'violin');\n    violins.exit().remove();\n    violins.each(function (d) {\n      var pathSel = d3.select(this);\n      var density = d.density;\n      var len = density.length;\n      var posCenter = posAxis.c2l(d.pos + bPos, true);\n      var posCenterPx = posAxis.l2p(posCenter);\n      var scale;\n\n      if (trace.width) {\n        scale = t.maxKDE / bdPos;\n      } else {\n        var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];\n        scale = trace.scalemode === 'count' ? groupStats.maxKDE / bdPos * (groupStats.maxCount / d.pts.length) : groupStats.maxKDE / bdPos;\n      }\n\n      var pathPos, pathNeg, path;\n      var i, k, pts, pt;\n\n      if (hasPositiveSide) {\n        pts = new Array(len);\n\n        for (i = 0; i < len; i++) {\n          pt = pts[i] = {};\n          pt[t.posLetter] = posCenter + density[i].v / scale;\n          pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n        }\n\n        pathPos = makePath(pts);\n      }\n\n      if (hasNegativeSide) {\n        pts = new Array(len);\n\n        for (k = 0, i = len - 1; k < len; k++, i--) {\n          pt = pts[k] = {};\n          pt[t.posLetter] = posCenter - density[i].v / scale;\n          pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n        }\n\n        pathNeg = makePath(pts);\n      }\n\n      if (hasBothSides) {\n        path = pathPos + 'L' + pathNeg.substr(1) + 'Z';\n      } else {\n        var startPt = [posCenterPx, valAxis.c2p(density[0].t)];\n        var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];\n\n        if (trace.orientation === 'h') {\n          startPt.reverse();\n          endPt.reverse();\n        }\n\n        if (hasPositiveSide) {\n          path = 'M' + startPt + 'L' + pathPos.substr(1) + 'L' + endPt;\n        } else {\n          path = 'M' + endPt + 'L' + pathNeg.substr(1) + 'L' + startPt;\n        }\n      }\n\n      pathSel.attr('d', path); // save a few things used in getPositionOnKdePath, getKdeValue\n      // on hover and for meanline draw block below\n\n      d.posCenterPx = posCenterPx;\n      d.posDensityScale = scale * bdPos;\n      d.path = pathSel.node();\n      d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);\n    });\n    var boxAttrs = trace.box;\n    var boxWidth = boxAttrs.width;\n    var boxLineWidth = (boxAttrs.line || {}).width;\n    var bdPosScaled;\n    var bPosPxOffset;\n\n    if (hasBothSides) {\n      bdPosScaled = bdPos * boxWidth;\n      bPosPxOffset = 0;\n    } else if (hasPositiveSide) {\n      bdPosScaled = [0, bdPos * boxWidth / 2];\n      bPosPxOffset = boxLineWidth * {\n        x: 1,\n        y: -1\n      }[t.posLetter];\n    } else {\n      bdPosScaled = [bdPos * boxWidth / 2, 0];\n      bPosPxOffset = boxLineWidth * {\n        x: -1,\n        y: 1\n      }[t.posLetter];\n    } // inner box\n\n\n    boxPlot.plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    }); // meanline insider box\n\n    boxPlot.plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    });\n    var fn;\n\n    if (!trace.box.visible && trace.meanline.visible) {\n      fn = Lib.identity;\n    } // N.B. use different class name than boxPlot.plotBoxMean,\n    // to avoid selectAll conflict\n\n\n    var meanPaths = plotGroup.selectAll('path.meanline').data(fn || []);\n    meanPaths.enter().append('path').attr('class', 'meanline').style('fill', 'none').style('vector-effect', 'non-scaling-stroke');\n    meanPaths.exit().remove();\n    meanPaths.each(function (d) {\n      var v = valAxis.c2p(d.mean, true);\n      var p = helpers.getPositionOnKdePath(d, trace, v);\n      d3.select(this).attr('d', trace.orientation === 'h' ? 'M' + v + ',' + p[0] + 'V' + p[1] : 'M' + p[0] + ',' + v + 'H' + p[1]);\n    });\n    boxPlot.plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}