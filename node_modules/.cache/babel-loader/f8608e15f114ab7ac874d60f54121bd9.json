{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar mouseChange = require('mouse-change');\n\nvar mouseWheel = require('mouse-wheel');\n\nvar mouseOffset = require('mouse-event-offset');\n\nvar cartesianConstants = require('../cartesian/constants');\n\nvar hasPassive = require('has-passive-events');\n\nmodule.exports = createCamera;\n\nfunction Camera2D(element, plot) {\n  this.element = element;\n  this.plot = plot;\n  this.mouseListener = null;\n  this.wheelListener = null;\n  this.lastInputTime = Date.now();\n  this.lastPos = [0, 0];\n  this.boxEnabled = false;\n  this.boxInited = false;\n  this.boxStart = [0, 0];\n  this.boxEnd = [0, 0];\n  this.dragStart = [0, 0];\n}\n\nfunction createCamera(scene) {\n  var element = scene.mouseContainer;\n  var plot = scene.glplot;\n  var result = new Camera2D(element, plot);\n\n  function unSetAutoRange() {\n    scene.xaxis.autorange = false;\n    scene.yaxis.autorange = false;\n  }\n\n  function getSubplotConstraint() {\n    // note: this assumes we only have one x and one y axis on this subplot\n    // when this constraint is lifted this block won't make sense\n    var constraints = scene.graphDiv._fullLayout._axisConstraintGroups;\n    var xaId = scene.xaxis._id;\n    var yaId = scene.yaxis._id;\n\n    for (var i = 0; i < constraints.length; i++) {\n      if (constraints[i][xaId] !== -1) {\n        if (constraints[i][yaId] !== -1) return true;\n        break;\n      }\n    }\n\n    return false;\n  }\n\n  result.mouseListener = mouseChange(element, handleInteraction); // enable simple touch interactions\n\n  element.addEventListener('touchstart', function (ev) {\n    var xy = mouseOffset(ev.changedTouches[0], element);\n    handleInteraction(0, xy[0], xy[1]);\n    handleInteraction(1, xy[0], xy[1]);\n    ev.preventDefault();\n  }, hasPassive ? {\n    passive: false\n  } : false);\n  element.addEventListener('touchmove', function (ev) {\n    ev.preventDefault();\n    var xy = mouseOffset(ev.changedTouches[0], element);\n    handleInteraction(1, xy[0], xy[1]);\n    ev.preventDefault();\n  }, hasPassive ? {\n    passive: false\n  } : false);\n  element.addEventListener('touchend', function (ev) {\n    handleInteraction(0, result.lastPos[0], result.lastPos[1]);\n    ev.preventDefault();\n  }, hasPassive ? {\n    passive: false\n  } : false);\n\n  function handleInteraction(buttons, x, y) {\n    var dataBox = scene.calcDataBox();\n    var viewBox = plot.viewBox;\n    var lastX = result.lastPos[0];\n    var lastY = result.lastPos[1];\n    var MINDRAG = cartesianConstants.MINDRAG * plot.pixelRatio;\n    var MINZOOM = cartesianConstants.MINZOOM * plot.pixelRatio;\n    var dx, dy;\n    x *= plot.pixelRatio;\n    y *= plot.pixelRatio; // mouseChange gives y about top; convert to about bottom\n\n    y = viewBox[3] - viewBox[1] - y;\n\n    function updateRange(i0, start, end) {\n      var range0 = Math.min(start, end);\n      var range1 = Math.max(start, end);\n\n      if (range0 !== range1) {\n        dataBox[i0] = range0;\n        dataBox[i0 + 2] = range1;\n        result.dataBox = dataBox;\n        scene.setRanges(dataBox);\n      } else {\n        scene.selectBox.selectBox = [0, 0, 1, 1];\n        scene.glplot.setDirty();\n      }\n    }\n\n    switch (scene.fullLayout.dragmode) {\n      case 'zoom':\n        if (buttons) {\n          var dataX = x / (viewBox[2] - viewBox[0]) * (dataBox[2] - dataBox[0]) + dataBox[0];\n          var dataY = y / (viewBox[3] - viewBox[1]) * (dataBox[3] - dataBox[1]) + dataBox[1];\n\n          if (!result.boxInited) {\n            result.boxStart[0] = dataX;\n            result.boxStart[1] = dataY;\n            result.dragStart[0] = x;\n            result.dragStart[1] = y;\n          }\n\n          result.boxEnd[0] = dataX;\n          result.boxEnd[1] = dataY; // we need to mark the box as initialized right away\n          // so that we can tell the start and end points apart\n\n          result.boxInited = true; // but don't actually enable the box until the cursor moves\n\n          if (!result.boxEnabled && (result.boxStart[0] !== result.boxEnd[0] || result.boxStart[1] !== result.boxEnd[1])) {\n            result.boxEnabled = true;\n          } // constrain aspect ratio if the axes require it\n\n\n          var smallDx = Math.abs(result.dragStart[0] - x) < MINZOOM;\n          var smallDy = Math.abs(result.dragStart[1] - y) < MINZOOM;\n\n          if (getSubplotConstraint() && !(smallDx && smallDy)) {\n            dx = result.boxEnd[0] - result.boxStart[0];\n            dy = result.boxEnd[1] - result.boxStart[1];\n            var dydx = (dataBox[3] - dataBox[1]) / (dataBox[2] - dataBox[0]);\n\n            if (Math.abs(dx * dydx) > Math.abs(dy)) {\n              result.boxEnd[1] = result.boxStart[1] + Math.abs(dx) * dydx * (dy >= 0 ? 1 : -1); // gl-select-box clips to the plot area bounds,\n              // which breaks the axis constraint, so don't allow\n              // this box to go out of bounds\n\n              if (result.boxEnd[1] < dataBox[1]) {\n                result.boxEnd[1] = dataBox[1];\n                result.boxEnd[0] = result.boxStart[0] + (dataBox[1] - result.boxStart[1]) / Math.abs(dydx);\n              } else if (result.boxEnd[1] > dataBox[3]) {\n                result.boxEnd[1] = dataBox[3];\n                result.boxEnd[0] = result.boxStart[0] + (dataBox[3] - result.boxStart[1]) / Math.abs(dydx);\n              }\n            } else {\n              result.boxEnd[0] = result.boxStart[0] + Math.abs(dy) / dydx * (dx >= 0 ? 1 : -1);\n\n              if (result.boxEnd[0] < dataBox[0]) {\n                result.boxEnd[0] = dataBox[0];\n                result.boxEnd[1] = result.boxStart[1] + (dataBox[0] - result.boxStart[0]) * Math.abs(dydx);\n              } else if (result.boxEnd[0] > dataBox[2]) {\n                result.boxEnd[0] = dataBox[2];\n                result.boxEnd[1] = result.boxStart[1] + (dataBox[2] - result.boxStart[0]) * Math.abs(dydx);\n              }\n            }\n          } else {\n            // otherwise clamp small changes to the origin so we get 1D zoom\n            if (smallDx) result.boxEnd[0] = result.boxStart[0];\n            if (smallDy) result.boxEnd[1] = result.boxStart[1];\n          }\n        } else if (result.boxEnabled) {\n          dx = result.boxStart[0] !== result.boxEnd[0];\n          dy = result.boxStart[1] !== result.boxEnd[1];\n\n          if (dx || dy) {\n            if (dx) {\n              updateRange(0, result.boxStart[0], result.boxEnd[0]);\n              scene.xaxis.autorange = false;\n            }\n\n            if (dy) {\n              updateRange(1, result.boxStart[1], result.boxEnd[1]);\n              scene.yaxis.autorange = false;\n            }\n\n            scene.relayoutCallback();\n          } else {\n            scene.glplot.setDirty();\n          }\n\n          result.boxEnabled = false;\n          result.boxInited = false;\n        } else if (result.boxInited) {\n          // if box was inited but button released then - reset the box\n          result.boxInited = false;\n        }\n\n        break;\n\n      case 'pan':\n        result.boxEnabled = false;\n        result.boxInited = false;\n\n        if (buttons) {\n          if (!result.panning) {\n            result.dragStart[0] = x;\n            result.dragStart[1] = y;\n          }\n\n          if (Math.abs(result.dragStart[0] - x) < MINDRAG) x = result.dragStart[0];\n          if (Math.abs(result.dragStart[1] - y) < MINDRAG) y = result.dragStart[1];\n          dx = (lastX - x) * (dataBox[2] - dataBox[0]) / (plot.viewBox[2] - plot.viewBox[0]);\n          dy = (lastY - y) * (dataBox[3] - dataBox[1]) / (plot.viewBox[3] - plot.viewBox[1]);\n          dataBox[0] += dx;\n          dataBox[2] += dx;\n          dataBox[1] += dy;\n          dataBox[3] += dy;\n          scene.setRanges(dataBox);\n          result.panning = true;\n          result.lastInputTime = Date.now();\n          unSetAutoRange();\n          scene.cameraChanged();\n          scene.handleAnnotations();\n        } else if (result.panning) {\n          result.panning = false;\n          scene.relayoutCallback();\n        }\n\n        break;\n    }\n\n    result.lastPos[0] = x;\n    result.lastPos[1] = y;\n  }\n\n  result.wheelListener = mouseWheel(element, function (dx, dy) {\n    if (!scene.scrollZoom) return false;\n    var dataBox = scene.calcDataBox();\n    var viewBox = plot.viewBox;\n    var lastX = result.lastPos[0];\n    var lastY = result.lastPos[1];\n    var scale = Math.exp(5.0 * dy / (viewBox[3] - viewBox[1]));\n    var cx = lastX / (viewBox[2] - viewBox[0]) * (dataBox[2] - dataBox[0]) + dataBox[0];\n    var cy = lastY / (viewBox[3] - viewBox[1]) * (dataBox[3] - dataBox[1]) + dataBox[1];\n    dataBox[0] = (dataBox[0] - cx) * scale + cx;\n    dataBox[2] = (dataBox[2] - cx) * scale + cx;\n    dataBox[1] = (dataBox[1] - cy) * scale + cy;\n    dataBox[3] = (dataBox[3] - cy) * scale + cy;\n    scene.setRanges(dataBox);\n    result.lastInputTime = Date.now();\n    unSetAutoRange();\n    scene.cameraChanged();\n    scene.handleAnnotations();\n    scene.relayoutCallback();\n    return true;\n  }, true);\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}