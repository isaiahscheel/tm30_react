{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plots = require('../../plots/plots');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar LINE_SPACING = require('../../constants/alignment').LINE_SPACING;\n\nvar constants = require('./constants');\n\nvar ScrollBox = require('./scrollbox');\n\nmodule.exports = function draw(gd) {\n  var fullLayout = gd._fullLayout;\n  var menuData = Lib.filterVisible(fullLayout[constants.name]);\n  /* Update menu data is bound to the header-group.\n   * The items in the header group are always present.\n   *\n   * Upon clicking on a header its corresponding button\n   * data is bound to the button-group.\n   *\n   * We draw all headers in one group before all buttons\n   * so that the buttons *always* appear above the headers.\n   *\n   * Note that only one set of buttons are visible at once.\n   *\n   * <g container />\n   *\n   *     <g header-group />\n   *         <g item header />\n   *         <text item header-arrow />\n   *     <g header-group />\n   *         <g item header />\n   *         <text item header-arrow />\n   *     ...\n   *\n   *     <g button-group />\n   *         <g item button />\n   *         <g item button />\n   *         ...\n   */\n\n  function clearAutoMargin(menuOpts) {\n    Plots.autoMargin(gd, autoMarginId(menuOpts));\n  } // draw update menu container\n\n\n  var menus = fullLayout._menulayer.selectAll('g.' + constants.containerClassName).data(menuData.length > 0 ? [0] : []);\n\n  menus.enter().append('g').classed(constants.containerClassName, true).style('cursor', 'pointer');\n  menus.exit().each(function () {\n    // Most components don't need to explicitly remove autoMargin, because\n    // marginPushers does this - but updatemenu updates don't go through\n    // a full replot so we need to explicitly remove it.\n    // This is for removing *all* updatemenus, removing individuals is\n    // handled below, in headerGroups.exit\n    d3.select(this).selectAll('g.' + constants.headerGroupClassName).each(clearAutoMargin);\n  }).remove(); // return early if no update menus are visible\n\n  if (menuData.length === 0) return; // join header group\n\n  var headerGroups = menus.selectAll('g.' + constants.headerGroupClassName).data(menuData, keyFunction);\n  headerGroups.enter().append('g').classed(constants.headerGroupClassName, true); // draw dropdown button container\n\n  var gButton = Lib.ensureSingle(menus, 'g', constants.dropdownButtonGroupClassName, function (s) {\n    s.style('pointer-events', 'all');\n  }); // find dimensions before plotting anything (this mutates menuOpts)\n\n  for (var i = 0; i < menuData.length; i++) {\n    var menuOpts = menuData[i];\n    findDimensions(gd, menuOpts);\n  } // setup scrollbox\n\n\n  var scrollBoxId = 'updatemenus' + fullLayout._uid;\n  var scrollBox = new ScrollBox(gd, gButton, scrollBoxId); // remove exiting header, remove dropped buttons and reset margins\n\n  if (headerGroups.enter().size()) {\n    // make sure gButton is on top of all headers\n    gButton.node().parentNode.appendChild(gButton.node());\n    gButton.call(removeAllButtons);\n  }\n\n  headerGroups.exit().each(function (menuOpts) {\n    gButton.call(removeAllButtons);\n    clearAutoMargin(menuOpts);\n  }).remove(); // draw headers!\n\n  headerGroups.each(function (menuOpts) {\n    var gHeader = d3.select(this);\n\n    var _gButton = menuOpts.type === 'dropdown' ? gButton : null;\n\n    Plots.manageCommandObserver(gd, menuOpts, menuOpts.buttons, function (data) {\n      setActive(gd, menuOpts, menuOpts.buttons[data.index], gHeader, _gButton, scrollBox, data.index, true);\n    });\n\n    if (menuOpts.type === 'dropdown') {\n      drawHeader(gd, gHeader, gButton, scrollBox, menuOpts); // if this menu is active, update the dropdown container\n\n      if (isActive(gButton, menuOpts)) {\n        drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);\n      }\n    } else {\n      drawButtons(gd, gHeader, null, null, menuOpts);\n    }\n  });\n}; // Note that '_index' is set at the default step,\n// it corresponds to the menu index in the user layout update menu container.\n// Because a menu can be set invisible,\n// this is a more 'consistent' field than the index in the menuData.\n\n\nfunction keyFunction(menuOpts) {\n  return menuOpts._index;\n}\n\nfunction isFolded(gButton) {\n  return +gButton.attr(constants.menuIndexAttrName) === -1;\n}\n\nfunction isActive(gButton, menuOpts) {\n  return +gButton.attr(constants.menuIndexAttrName) === menuOpts._index;\n}\n\nfunction setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex, isSilentUpdate) {\n  // update 'active' attribute in menuOpts\n  menuOpts.active = buttonIndex; // due to templating, it's possible this slider doesn't even exist yet\n\n  arrayEditor(gd.layout, constants.name, menuOpts).applyUpdate('active', buttonIndex);\n\n  if (menuOpts.type === 'buttons') {\n    drawButtons(gd, gHeader, null, null, menuOpts);\n  } else if (menuOpts.type === 'dropdown') {\n    // fold up buttons and redraw header\n    gButton.attr(constants.menuIndexAttrName, '-1');\n    drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);\n\n    if (!isSilentUpdate) {\n      drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);\n    }\n  }\n}\n\nfunction drawHeader(gd, gHeader, gButton, scrollBox, menuOpts) {\n  var header = Lib.ensureSingle(gHeader, 'g', constants.headerClassName, function (s) {\n    s.style('pointer-events', 'all');\n  });\n  var dims = menuOpts._dims;\n  var active = menuOpts.active;\n  var headerOpts = menuOpts.buttons[active] || constants.blankHeaderOpts;\n  var posOpts = {\n    y: menuOpts.pad.t,\n    yPad: 0,\n    x: menuOpts.pad.l,\n    xPad: 0,\n    index: 0\n  };\n  var positionOverrides = {\n    width: dims.headerWidth,\n    height: dims.headerHeight\n  };\n  header.call(drawItem, menuOpts, headerOpts, gd).call(setItemPosition, menuOpts, posOpts, positionOverrides); // draw drop arrow at the right edge\n\n  var arrow = Lib.ensureSingle(gHeader, 'text', constants.headerArrowClassName, function (s) {\n    s.classed('user-select-none', true).attr('text-anchor', 'end').call(Drawing.font, menuOpts.font).text(constants.arrowSymbol[menuOpts.direction]);\n  });\n  arrow.attr({\n    x: dims.headerWidth - constants.arrowOffsetX + menuOpts.pad.l,\n    y: dims.headerHeight / 2 + constants.textOffsetY + menuOpts.pad.t\n  });\n  header.on('click', function () {\n    gButton.call(removeAllButtons, String(isActive(gButton, menuOpts) ? -1 : menuOpts._index));\n    drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);\n  });\n  header.on('mouseover', function () {\n    header.call(styleOnMouseOver);\n  });\n  header.on('mouseout', function () {\n    header.call(styleOnMouseOut, menuOpts);\n  }); // translate header group\n\n  Drawing.setTranslate(gHeader, dims.lx, dims.ly);\n}\n\nfunction drawButtons(gd, gHeader, gButton, scrollBox, menuOpts) {\n  // If this is a set of buttons, set pointer events = all since we play\n  // some minor games with which container is which in order to simplify\n  // the drawing of *either* buttons or menus\n  if (!gButton) {\n    gButton = gHeader;\n    gButton.attr('pointer-events', 'all');\n  }\n\n  var buttonData = !isFolded(gButton) || menuOpts.type === 'buttons' ? menuOpts.buttons : [];\n  var klass = menuOpts.type === 'dropdown' ? constants.dropdownButtonClassName : constants.buttonClassName;\n  var buttons = gButton.selectAll('g.' + klass).data(Lib.filterVisible(buttonData));\n  var enter = buttons.enter().append('g').classed(klass, true);\n  var exit = buttons.exit();\n\n  if (menuOpts.type === 'dropdown') {\n    enter.attr('opacity', '0').transition().attr('opacity', '1');\n    exit.transition().attr('opacity', '0').remove();\n  } else {\n    exit.remove();\n  }\n\n  var x0 = 0;\n  var y0 = 0;\n  var dims = menuOpts._dims;\n  var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;\n\n  if (menuOpts.type === 'dropdown') {\n    if (isVertical) {\n      y0 = dims.headerHeight + constants.gapButtonHeader;\n    } else {\n      x0 = dims.headerWidth + constants.gapButtonHeader;\n    }\n  }\n\n  if (menuOpts.type === 'dropdown' && menuOpts.direction === 'up') {\n    y0 = -constants.gapButtonHeader + constants.gapButton - dims.openHeight;\n  }\n\n  if (menuOpts.type === 'dropdown' && menuOpts.direction === 'left') {\n    x0 = -constants.gapButtonHeader + constants.gapButton - dims.openWidth;\n  }\n\n  var posOpts = {\n    x: dims.lx + x0 + menuOpts.pad.l,\n    y: dims.ly + y0 + menuOpts.pad.t,\n    yPad: constants.gapButton,\n    xPad: constants.gapButton,\n    index: 0\n  };\n  var scrollBoxPosition = {\n    l: posOpts.x + menuOpts.borderwidth,\n    t: posOpts.y + menuOpts.borderwidth\n  };\n  buttons.each(function (buttonOpts, buttonIndex) {\n    var button = d3.select(this);\n    button.call(drawItem, menuOpts, buttonOpts, gd).call(setItemPosition, menuOpts, posOpts);\n    button.on('click', function () {\n      // skip `dragend` events\n      if (d3.event.defaultPrevented) return;\n\n      if (buttonOpts.execute) {\n        if (buttonOpts.args2 && menuOpts.active === buttonIndex) {\n          setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, -1);\n          Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args2);\n        } else {\n          setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex);\n          Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args);\n        }\n      }\n\n      gd.emit('plotly_buttonclicked', {\n        menu: menuOpts,\n        button: buttonOpts,\n        active: menuOpts.active\n      });\n    });\n    button.on('mouseover', function () {\n      button.call(styleOnMouseOver);\n    });\n    button.on('mouseout', function () {\n      button.call(styleOnMouseOut, menuOpts);\n      buttons.call(styleButtons, menuOpts);\n    });\n  });\n  buttons.call(styleButtons, menuOpts);\n\n  if (isVertical) {\n    scrollBoxPosition.w = Math.max(dims.openWidth, dims.headerWidth);\n    scrollBoxPosition.h = posOpts.y - scrollBoxPosition.t;\n  } else {\n    scrollBoxPosition.w = posOpts.x - scrollBoxPosition.l;\n    scrollBoxPosition.h = Math.max(dims.openHeight, dims.headerHeight);\n  }\n\n  scrollBoxPosition.direction = menuOpts.direction;\n\n  if (scrollBox) {\n    if (buttons.size()) {\n      drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, scrollBoxPosition);\n    } else {\n      hideScrollBox(scrollBox);\n    }\n  }\n}\n\nfunction drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, position) {\n  // enable the scrollbox\n  var direction = menuOpts.direction;\n  var isVertical = direction === 'up' || direction === 'down';\n  var dims = menuOpts._dims;\n  var active = menuOpts.active;\n  var translateX, translateY;\n  var i;\n\n  if (isVertical) {\n    translateY = 0;\n\n    for (i = 0; i < active; i++) {\n      translateY += dims.heights[i] + constants.gapButton;\n    }\n  } else {\n    translateX = 0;\n\n    for (i = 0; i < active; i++) {\n      translateX += dims.widths[i] + constants.gapButton;\n    }\n  }\n\n  scrollBox.enable(position, translateX, translateY);\n\n  if (scrollBox.hbar) {\n    scrollBox.hbar.attr('opacity', '0').transition().attr('opacity', '1');\n  }\n\n  if (scrollBox.vbar) {\n    scrollBox.vbar.attr('opacity', '0').transition().attr('opacity', '1');\n  }\n}\n\nfunction hideScrollBox(scrollBox) {\n  var hasHBar = !!scrollBox.hbar;\n  var hasVBar = !!scrollBox.vbar;\n\n  if (hasHBar) {\n    scrollBox.hbar.transition().attr('opacity', '0').each('end', function () {\n      hasHBar = false;\n      if (!hasVBar) scrollBox.disable();\n    });\n  }\n\n  if (hasVBar) {\n    scrollBox.vbar.transition().attr('opacity', '0').each('end', function () {\n      hasVBar = false;\n      if (!hasHBar) scrollBox.disable();\n    });\n  }\n}\n\nfunction drawItem(item, menuOpts, itemOpts, gd) {\n  item.call(drawItemRect, menuOpts).call(drawItemText, menuOpts, itemOpts, gd);\n}\n\nfunction drawItemRect(item, menuOpts) {\n  var rect = Lib.ensureSingle(item, 'rect', constants.itemRectClassName, function (s) {\n    s.attr({\n      rx: constants.rx,\n      ry: constants.ry,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  rect.call(Color.stroke, menuOpts.bordercolor).call(Color.fill, menuOpts.bgcolor).style('stroke-width', menuOpts.borderwidth + 'px');\n}\n\nfunction drawItemText(item, menuOpts, itemOpts, gd) {\n  var text = Lib.ensureSingle(item, 'text', constants.itemTextClassName, function (s) {\n    s.classed('user-select-none', true).attr({\n      'text-anchor': 'start',\n      'data-notex': 1\n    });\n  });\n  var tx = itemOpts.label;\n  var _meta = gd._fullLayout._meta;\n  if (_meta) tx = Lib.templateString(tx, _meta);\n  text.call(Drawing.font, menuOpts.font).text(tx).call(svgTextUtils.convertToTspans, gd);\n}\n\nfunction styleButtons(buttons, menuOpts) {\n  var active = menuOpts.active;\n  buttons.each(function (buttonOpts, i) {\n    var button = d3.select(this);\n\n    if (i === active && menuOpts.showactive) {\n      button.select('rect.' + constants.itemRectClassName).call(Color.fill, constants.activeColor);\n    }\n  });\n}\n\nfunction styleOnMouseOver(item) {\n  item.select('rect.' + constants.itemRectClassName).call(Color.fill, constants.hoverColor);\n}\n\nfunction styleOnMouseOut(item, menuOpts) {\n  item.select('rect.' + constants.itemRectClassName).call(Color.fill, menuOpts.bgcolor);\n} // find item dimensions (this mutates menuOpts)\n\n\nfunction findDimensions(gd, menuOpts) {\n  var dims = menuOpts._dims = {\n    width1: 0,\n    height1: 0,\n    heights: [],\n    widths: [],\n    totalWidth: 0,\n    totalHeight: 0,\n    openWidth: 0,\n    openHeight: 0,\n    lx: 0,\n    ly: 0\n  };\n  var fakeButtons = Drawing.tester.selectAll('g.' + constants.dropdownButtonClassName).data(Lib.filterVisible(menuOpts.buttons));\n  fakeButtons.enter().append('g').classed(constants.dropdownButtonClassName, true);\n  var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1; // loop over fake buttons to find width / height\n\n  fakeButtons.each(function (buttonOpts, i) {\n    var button = d3.select(this);\n    button.call(drawItem, menuOpts, buttonOpts, gd);\n    var text = button.select('.' + constants.itemTextClassName); // width is given by max width of all buttons\n\n    var tWidth = text.node() && Drawing.bBox(text.node()).width;\n    var wEff = Math.max(tWidth + constants.textPadX, constants.minWidth); // height is determined by item text\n\n    var tHeight = menuOpts.font.size * LINE_SPACING;\n    var tLines = svgTextUtils.lineCount(text);\n    var hEff = Math.max(tHeight * tLines, constants.minHeight) + constants.textOffsetY;\n    hEff = Math.ceil(hEff);\n    wEff = Math.ceil(wEff); // Store per-item sizes since a row of horizontal buttons, for example,\n    // don't all need to be the same width:\n\n    dims.widths[i] = wEff;\n    dims.heights[i] = hEff; // Height and width of individual element:\n\n    dims.height1 = Math.max(dims.height1, hEff);\n    dims.width1 = Math.max(dims.width1, wEff);\n\n    if (isVertical) {\n      dims.totalWidth = Math.max(dims.totalWidth, wEff);\n      dims.openWidth = dims.totalWidth;\n      dims.totalHeight += hEff + constants.gapButton;\n      dims.openHeight += hEff + constants.gapButton;\n    } else {\n      dims.totalWidth += wEff + constants.gapButton;\n      dims.openWidth += wEff + constants.gapButton;\n      dims.totalHeight = Math.max(dims.totalHeight, hEff);\n      dims.openHeight = dims.totalHeight;\n    }\n  });\n\n  if (isVertical) {\n    dims.totalHeight -= constants.gapButton;\n  } else {\n    dims.totalWidth -= constants.gapButton;\n  }\n\n  dims.headerWidth = dims.width1 + constants.arrowPadX;\n  dims.headerHeight = dims.height1;\n\n  if (menuOpts.type === 'dropdown') {\n    if (isVertical) {\n      dims.width1 += constants.arrowPadX;\n      dims.totalHeight = dims.height1;\n    } else {\n      dims.totalWidth = dims.width1;\n    }\n\n    dims.totalWidth += constants.arrowPadX;\n  }\n\n  fakeButtons.remove();\n  var paddedWidth = dims.totalWidth + menuOpts.pad.l + menuOpts.pad.r;\n  var paddedHeight = dims.totalHeight + menuOpts.pad.t + menuOpts.pad.b;\n  var graphSize = gd._fullLayout._size;\n  dims.lx = graphSize.l + graphSize.w * menuOpts.x;\n  dims.ly = graphSize.t + graphSize.h * (1 - menuOpts.y);\n  var xanchor = 'left';\n\n  if (Lib.isRightAnchor(menuOpts)) {\n    dims.lx -= paddedWidth;\n    xanchor = 'right';\n  }\n\n  if (Lib.isCenterAnchor(menuOpts)) {\n    dims.lx -= paddedWidth / 2;\n    xanchor = 'center';\n  }\n\n  var yanchor = 'top';\n\n  if (Lib.isBottomAnchor(menuOpts)) {\n    dims.ly -= paddedHeight;\n    yanchor = 'bottom';\n  }\n\n  if (Lib.isMiddleAnchor(menuOpts)) {\n    dims.ly -= paddedHeight / 2;\n    yanchor = 'middle';\n  }\n\n  dims.totalWidth = Math.ceil(dims.totalWidth);\n  dims.totalHeight = Math.ceil(dims.totalHeight);\n  dims.lx = Math.round(dims.lx);\n  dims.ly = Math.round(dims.ly);\n  Plots.autoMargin(gd, autoMarginId(menuOpts), {\n    x: menuOpts.x,\n    y: menuOpts.y,\n    l: paddedWidth * ({\n      right: 1,\n      center: 0.5\n    }[xanchor] || 0),\n    r: paddedWidth * ({\n      left: 1,\n      center: 0.5\n    }[xanchor] || 0),\n    b: paddedHeight * ({\n      top: 1,\n      middle: 0.5\n    }[yanchor] || 0),\n    t: paddedHeight * ({\n      bottom: 1,\n      middle: 0.5\n    }[yanchor] || 0)\n  });\n}\n\nfunction autoMarginId(menuOpts) {\n  return constants.autoMarginIdRoot + menuOpts._index;\n} // set item positions (mutates posOpts)\n\n\nfunction setItemPosition(item, menuOpts, posOpts, overrideOpts) {\n  overrideOpts = overrideOpts || {};\n  var rect = item.select('.' + constants.itemRectClassName);\n  var text = item.select('.' + constants.itemTextClassName);\n  var borderWidth = menuOpts.borderwidth;\n  var index = posOpts.index;\n  var dims = menuOpts._dims;\n  Drawing.setTranslate(item, borderWidth + posOpts.x, borderWidth + posOpts.y);\n  var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;\n  var finalHeight = overrideOpts.height || (isVertical ? dims.heights[index] : dims.height1);\n  rect.attr({\n    x: 0,\n    y: 0,\n    width: overrideOpts.width || (isVertical ? dims.width1 : dims.widths[index]),\n    height: finalHeight\n  });\n  var tHeight = menuOpts.font.size * LINE_SPACING;\n  var tLines = svgTextUtils.lineCount(text);\n  var spanOffset = (tLines - 1) * tHeight / 2;\n  svgTextUtils.positionText(text, constants.textOffsetX, finalHeight / 2 - spanOffset + constants.textOffsetY);\n\n  if (isVertical) {\n    posOpts.y += dims.heights[index] + posOpts.yPad;\n  } else {\n    posOpts.x += dims.widths[index] + posOpts.xPad;\n  }\n\n  posOpts.index++;\n}\n\nfunction removeAllButtons(gButton, newMenuIndexAttr) {\n  gButton.attr(constants.menuIndexAttrName, newMenuIndexAttr || '-1').selectAll('g.' + constants.dropdownButtonClassName).remove();\n}","map":null,"metadata":{},"sourceType":"script"}