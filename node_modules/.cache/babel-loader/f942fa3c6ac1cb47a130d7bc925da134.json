{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nmodule.exports = Sieve;\n\nvar distinctVals = require('../../lib').distinctVals;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n *\n * @param {Array} traces\n*   Array of calculated traces\n * @param {object} opts\n *  - @param {boolean} [sepNegVal]\n *      If true, then split data at the same position into a bar\n *      for positive values and another for negative values\n *  - @param {boolean} [overlapNoMerge]\n *     If true, then don't merge overlapping bars into a single bar\n */\n\n\nfunction Sieve(traces, opts) {\n  this.traces = traces;\n  this.sepNegVal = opts.sepNegVal;\n  this.overlapNoMerge = opts.overlapNoMerge; // for single-bin histograms - see histogram/calc\n\n  var width1 = Infinity;\n  var positions = [];\n\n  for (var i = 0; i < traces.length; i++) {\n    var trace = traces[i];\n\n    for (var j = 0; j < trace.length; j++) {\n      var bar = trace[j];\n      if (bar.p !== BADNUM) positions.push(bar.p);\n    }\n\n    if (trace[0] && trace[0].width1) {\n      width1 = Math.min(trace[0].width1, width1);\n    }\n  }\n\n  this.positions = positions;\n  var dv = distinctVals(positions);\n  this.distinctPositions = dv.vals;\n  if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;else this.minDiff = Math.min(dv.minDiff, width1);\n  this.binWidth = this.minDiff;\n  this.bins = {};\n}\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\n\n\nSieve.prototype.put = function put(position, value) {\n  var label = this.getLabel(position, value);\n  var oldValue = this.bins[label] || 0;\n  this.bins[label] = oldValue + value;\n  return oldValue;\n};\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {number} Current bin value\n */\n\n\nSieve.prototype.get = function get(position, value) {\n  var label = this.getLabel(position, value);\n  return this.bins[label] || 0;\n};\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\n * true; otherwise prefixed with '^')\n */\n\n\nSieve.prototype.getLabel = function getLabel(position, value) {\n  var prefix = value < 0 && this.sepNegVal ? 'v' : '^';\n  var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);\n  return prefix + label;\n};","map":null,"metadata":{},"sourceType":"script"}