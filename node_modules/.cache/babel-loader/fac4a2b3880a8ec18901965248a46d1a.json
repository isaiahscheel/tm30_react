{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar getTraceColor = require('../bar/hover').getTraceColor;\n\nvar fillText = Lib.fillText;\n\nvar makeHoverPointText = require('../scatterpolar/hover').makeHoverPointText;\n\nvar isPtInsidePolygon = require('../../plots/polar/helpers').isPtInsidePolygon;\n\nmodule.exports = function hoverPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var subplot = pointData.subplot;\n  var radialAxis = subplot.radialAxis;\n  var angularAxis = subplot.angularAxis;\n  var vangles = subplot.vangles;\n  var inboxFn = vangles ? isPtInsidePolygon : Lib.isPtInsideSector;\n  var maxHoverDistance = pointData.maxHoverDistance;\n  var period = angularAxis._period || 2 * Math.PI;\n  var rVal = Math.abs(radialAxis.g2p(Math.sqrt(xval * xval + yval * yval)));\n  var thetaVal = Math.atan2(yval, xval); // polar.(x|y)axis.p2c doesn't get the reversed radial axis range case right\n\n  if (radialAxis.range[0] > radialAxis.range[1]) {\n    thetaVal += Math.PI;\n  }\n\n  var distFn = function (di) {\n    if (inboxFn(rVal, thetaVal, [di.rp0, di.rp1], [di.thetag0, di.thetag1], vangles)) {\n      return maxHoverDistance + // add a little to the pseudo-distance for wider bars, so that like scatter,\n      // if you are over two overlapping bars, the narrower one wins.\n      Math.min(1, Math.abs(di.thetag1 - di.thetag0) / period) - 1 + // add a gradient so hovering near the end of a\n      // bar makes it a little closer match\n      (di.rp1 - rVal) / (di.rp1 - di.rp0) - 1;\n    } else {\n      return Infinity;\n    }\n  };\n\n  Fx.getClosest(cd, distFn, pointData);\n  if (pointData.index === false) return;\n  var index = pointData.index;\n  var cdi = cd[index];\n  pointData.x0 = pointData.x1 = cdi.ct[0];\n  pointData.y0 = pointData.y1 = cdi.ct[1];\n\n  var _cdi = Lib.extendFlat({}, cdi, {\n    r: cdi.s,\n    theta: cdi.p\n  });\n\n  fillText(cdi, trace, pointData);\n  makeHoverPointText(_cdi, trace, subplot, pointData);\n  pointData.hovertemplate = trace.hovertemplate;\n  pointData.color = getTraceColor(trace, cdi);\n  pointData.xLabelVal = pointData.yLabelVal = undefined;\n\n  if (cdi.s < 0) {\n    pointData.idealAlign = 'left';\n  }\n\n  return [pointData];\n};","map":null,"metadata":{},"sourceType":"script"}